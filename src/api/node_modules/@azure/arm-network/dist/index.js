'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreClient = require('@azure/core-client');
var coreRestPipeline = require('@azure/core-rest-pipeline');
var coreLro = require('@azure/core-lro');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var coreRestPipeline__namespace = /*#__PURE__*/_interopNamespace(coreRestPipeline);

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const pageMap = new WeakMap();
/**
 * Given the last `.value` produced by the `byPage` iterator,
 * returns a continuation token that can be used to begin paging from
 * that point later.
 * @param page An object from accessing `value` on the IteratorResult from a `byPage` iterator.
 * @returns The continuation token that can be passed into byPage() during future calls.
 */
function getContinuationToken(page) {
    var _a;
    if (typeof page !== "object" || page === null) {
        return undefined;
    }
    return (_a = pageMap.get(page)) === null || _a === void 0 ? void 0 : _a.continuationToken;
}
function setContinuationToken(page, continuationToken) {
    var _a;
    if (typeof page !== "object" || page === null || !continuationToken) {
        return;
    }
    const pageInfo = (_a = pageMap.get(page)) !== null && _a !== void 0 ? _a : {};
    pageInfo.continuationToken = continuationToken;
    pageMap.set(page, pageInfo);
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Known values of {@link ApplicationGatewaySkuName} that the service accepts. */
exports.KnownApplicationGatewaySkuName = void 0;
(function (KnownApplicationGatewaySkuName) {
    /** StandardSmall */
    KnownApplicationGatewaySkuName["StandardSmall"] = "Standard_Small";
    /** StandardMedium */
    KnownApplicationGatewaySkuName["StandardMedium"] = "Standard_Medium";
    /** StandardLarge */
    KnownApplicationGatewaySkuName["StandardLarge"] = "Standard_Large";
    /** WAFMedium */
    KnownApplicationGatewaySkuName["WAFMedium"] = "WAF_Medium";
    /** WAFLarge */
    KnownApplicationGatewaySkuName["WAFLarge"] = "WAF_Large";
    /** StandardV2 */
    KnownApplicationGatewaySkuName["StandardV2"] = "Standard_v2";
    /** WAFV2 */
    KnownApplicationGatewaySkuName["WAFV2"] = "WAF_v2";
})(exports.KnownApplicationGatewaySkuName || (exports.KnownApplicationGatewaySkuName = {}));
/** Known values of {@link ApplicationGatewayTier} that the service accepts. */
exports.KnownApplicationGatewayTier = void 0;
(function (KnownApplicationGatewayTier) {
    /** Standard */
    KnownApplicationGatewayTier["Standard"] = "Standard";
    /** WAF */
    KnownApplicationGatewayTier["WAF"] = "WAF";
    /** StandardV2 */
    KnownApplicationGatewayTier["StandardV2"] = "Standard_v2";
    /** WAFV2 */
    KnownApplicationGatewayTier["WAFV2"] = "WAF_v2";
})(exports.KnownApplicationGatewayTier || (exports.KnownApplicationGatewayTier = {}));
/** Known values of {@link ApplicationGatewaySslProtocol} that the service accepts. */
exports.KnownApplicationGatewaySslProtocol = void 0;
(function (KnownApplicationGatewaySslProtocol) {
    /** TLSv10 */
    KnownApplicationGatewaySslProtocol["TLSv10"] = "TLSv1_0";
    /** TLSv11 */
    KnownApplicationGatewaySslProtocol["TLSv11"] = "TLSv1_1";
    /** TLSv12 */
    KnownApplicationGatewaySslProtocol["TLSv12"] = "TLSv1_2";
    /** TLSv13 */
    KnownApplicationGatewaySslProtocol["TLSv13"] = "TLSv1_3";
})(exports.KnownApplicationGatewaySslProtocol || (exports.KnownApplicationGatewaySslProtocol = {}));
/** Known values of {@link ApplicationGatewaySslPolicyType} that the service accepts. */
exports.KnownApplicationGatewaySslPolicyType = void 0;
(function (KnownApplicationGatewaySslPolicyType) {
    /** Predefined */
    KnownApplicationGatewaySslPolicyType["Predefined"] = "Predefined";
    /** Custom */
    KnownApplicationGatewaySslPolicyType["Custom"] = "Custom";
    /** CustomV2 */
    KnownApplicationGatewaySslPolicyType["CustomV2"] = "CustomV2";
})(exports.KnownApplicationGatewaySslPolicyType || (exports.KnownApplicationGatewaySslPolicyType = {}));
/** Known values of {@link ApplicationGatewaySslPolicyName} that the service accepts. */
exports.KnownApplicationGatewaySslPolicyName = void 0;
(function (KnownApplicationGatewaySslPolicyName) {
    /** AppGwSslPolicy20150501 */
    KnownApplicationGatewaySslPolicyName["AppGwSslPolicy20150501"] = "AppGwSslPolicy20150501";
    /** AppGwSslPolicy20170401 */
    KnownApplicationGatewaySslPolicyName["AppGwSslPolicy20170401"] = "AppGwSslPolicy20170401";
    /** AppGwSslPolicy20170401S */
    KnownApplicationGatewaySslPolicyName["AppGwSslPolicy20170401S"] = "AppGwSslPolicy20170401S";
    /** AppGwSslPolicy20220101 */
    KnownApplicationGatewaySslPolicyName["AppGwSslPolicy20220101"] = "AppGwSslPolicy20220101";
    /** AppGwSslPolicy20220101S */
    KnownApplicationGatewaySslPolicyName["AppGwSslPolicy20220101S"] = "AppGwSslPolicy20220101S";
})(exports.KnownApplicationGatewaySslPolicyName || (exports.KnownApplicationGatewaySslPolicyName = {}));
/** Known values of {@link ApplicationGatewaySslCipherSuite} that the service accepts. */
exports.KnownApplicationGatewaySslCipherSuite = void 0;
(function (KnownApplicationGatewaySslCipherSuite) {
    /** TLSEcdheRSAWithAES256CBCSHA384 */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES256CBCSHA384"] = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
    /** TLSEcdheRSAWithAES128CBCSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES128CBCSHA256"] = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
    /** TLSEcdheRSAWithAES256CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES256CBCSHA"] = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
    /** TLSEcdheRSAWithAES128CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES128CBCSHA"] = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
    /** TLSDHERSAWithAES256GCMSHA384 */
    KnownApplicationGatewaySslCipherSuite["TLSDHERSAWithAES256GCMSHA384"] = "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384";
    /** TLSDHERSAWithAES128GCMSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSDHERSAWithAES128GCMSHA256"] = "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256";
    /** TLSDHERSAWithAES256CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSDHERSAWithAES256CBCSHA"] = "TLS_DHE_RSA_WITH_AES_256_CBC_SHA";
    /** TLSDHERSAWithAES128CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSDHERSAWithAES128CBCSHA"] = "TLS_DHE_RSA_WITH_AES_128_CBC_SHA";
    /** TLSRSAWithAES256GCMSHA384 */
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES256GCMSHA384"] = "TLS_RSA_WITH_AES_256_GCM_SHA384";
    /** TLSRSAWithAES128GCMSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES128GCMSHA256"] = "TLS_RSA_WITH_AES_128_GCM_SHA256";
    /** TLSRSAWithAES256CBCSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES256CBCSHA256"] = "TLS_RSA_WITH_AES_256_CBC_SHA256";
    /** TLSRSAWithAES128CBCSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES128CBCSHA256"] = "TLS_RSA_WITH_AES_128_CBC_SHA256";
    /** TLSRSAWithAES256CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES256CBCSHA"] = "TLS_RSA_WITH_AES_256_CBC_SHA";
    /** TLSRSAWithAES128CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSRSAWithAES128CBCSHA"] = "TLS_RSA_WITH_AES_128_CBC_SHA";
    /** TLSEcdheEcdsaWithAES256GCMSHA384 */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES256GCMSHA384"] = "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
    /** TLSEcdheEcdsaWithAES128GCMSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES128GCMSHA256"] = "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
    /** TLSEcdheEcdsaWithAES256CBCSHA384 */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES256CBCSHA384"] = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384";
    /** TLSEcdheEcdsaWithAES128CBCSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES128CBCSHA256"] = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
    /** TLSEcdheEcdsaWithAES256CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES256CBCSHA"] = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA";
    /** TLSEcdheEcdsaWithAES128CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheEcdsaWithAES128CBCSHA"] = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA";
    /** TLSDHEDSSWithAES256CBCSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWithAES256CBCSHA256"] = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256";
    /** TLSDHEDSSWithAES128CBCSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWithAES128CBCSHA256"] = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256";
    /** TLSDHEDSSWithAES256CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWithAES256CBCSHA"] = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA";
    /** TLSDHEDSSWithAES128CBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWithAES128CBCSHA"] = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA";
    /** TLSRSAWith3DESEDECBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSRSAWith3DESEDECBCSHA"] = "TLS_RSA_WITH_3DES_EDE_CBC_SHA";
    /** TLSDHEDSSWith3DESEDECBCSHA */
    KnownApplicationGatewaySslCipherSuite["TLSDHEDSSWith3DESEDECBCSHA"] = "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA";
    /** TLSEcdheRSAWithAES128GCMSHA256 */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES128GCMSHA256"] = "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
    /** TLSEcdheRSAWithAES256GCMSHA384 */
    KnownApplicationGatewaySslCipherSuite["TLSEcdheRSAWithAES256GCMSHA384"] = "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
})(exports.KnownApplicationGatewaySslCipherSuite || (exports.KnownApplicationGatewaySslCipherSuite = {}));
/** Known values of {@link ApplicationGatewayOperationalState} that the service accepts. */
exports.KnownApplicationGatewayOperationalState = void 0;
(function (KnownApplicationGatewayOperationalState) {
    /** Stopped */
    KnownApplicationGatewayOperationalState["Stopped"] = "Stopped";
    /** Starting */
    KnownApplicationGatewayOperationalState["Starting"] = "Starting";
    /** Running */
    KnownApplicationGatewayOperationalState["Running"] = "Running";
    /** Stopping */
    KnownApplicationGatewayOperationalState["Stopping"] = "Stopping";
})(exports.KnownApplicationGatewayOperationalState || (exports.KnownApplicationGatewayOperationalState = {}));
/** Known values of {@link ProvisioningState} that the service accepts. */
exports.KnownProvisioningState = void 0;
(function (KnownProvisioningState) {
    /** Succeeded */
    KnownProvisioningState["Succeeded"] = "Succeeded";
    /** Updating */
    KnownProvisioningState["Updating"] = "Updating";
    /** Deleting */
    KnownProvisioningState["Deleting"] = "Deleting";
    /** Failed */
    KnownProvisioningState["Failed"] = "Failed";
})(exports.KnownProvisioningState || (exports.KnownProvisioningState = {}));
/** Known values of {@link IPAllocationMethod} that the service accepts. */
exports.KnownIPAllocationMethod = void 0;
(function (KnownIPAllocationMethod) {
    /** Static */
    KnownIPAllocationMethod["Static"] = "Static";
    /** Dynamic */
    KnownIPAllocationMethod["Dynamic"] = "Dynamic";
})(exports.KnownIPAllocationMethod || (exports.KnownIPAllocationMethod = {}));
/** Known values of {@link ApplicationGatewayProtocol} that the service accepts. */
exports.KnownApplicationGatewayProtocol = void 0;
(function (KnownApplicationGatewayProtocol) {
    /** Http */
    KnownApplicationGatewayProtocol["Http"] = "Http";
    /** Https */
    KnownApplicationGatewayProtocol["Https"] = "Https";
    /** Tcp */
    KnownApplicationGatewayProtocol["Tcp"] = "Tcp";
    /** Tls */
    KnownApplicationGatewayProtocol["Tls"] = "Tls";
})(exports.KnownApplicationGatewayProtocol || (exports.KnownApplicationGatewayProtocol = {}));
/** Known values of {@link IPVersion} that the service accepts. */
exports.KnownIPVersion = void 0;
(function (KnownIPVersion) {
    /** IPv4 */
    KnownIPVersion["IPv4"] = "IPv4";
    /** IPv6 */
    KnownIPVersion["IPv6"] = "IPv6";
})(exports.KnownIPVersion || (exports.KnownIPVersion = {}));
/** Known values of {@link SecurityRuleProtocol} that the service accepts. */
exports.KnownSecurityRuleProtocol = void 0;
(function (KnownSecurityRuleProtocol) {
    /** Tcp */
    KnownSecurityRuleProtocol["Tcp"] = "Tcp";
    /** Udp */
    KnownSecurityRuleProtocol["Udp"] = "Udp";
    /** Icmp */
    KnownSecurityRuleProtocol["Icmp"] = "Icmp";
    /** Esp */
    KnownSecurityRuleProtocol["Esp"] = "Esp";
    /** Asterisk */
    KnownSecurityRuleProtocol["Asterisk"] = "*";
    /** Ah */
    KnownSecurityRuleProtocol["Ah"] = "Ah";
})(exports.KnownSecurityRuleProtocol || (exports.KnownSecurityRuleProtocol = {}));
/** Known values of {@link SecurityRuleAccess} that the service accepts. */
exports.KnownSecurityRuleAccess = void 0;
(function (KnownSecurityRuleAccess) {
    /** Allow */
    KnownSecurityRuleAccess["Allow"] = "Allow";
    /** Deny */
    KnownSecurityRuleAccess["Deny"] = "Deny";
})(exports.KnownSecurityRuleAccess || (exports.KnownSecurityRuleAccess = {}));
/** Known values of {@link SecurityRuleDirection} that the service accepts. */
exports.KnownSecurityRuleDirection = void 0;
(function (KnownSecurityRuleDirection) {
    /** Inbound */
    KnownSecurityRuleDirection["Inbound"] = "Inbound";
    /** Outbound */
    KnownSecurityRuleDirection["Outbound"] = "Outbound";
})(exports.KnownSecurityRuleDirection || (exports.KnownSecurityRuleDirection = {}));
/** Known values of {@link ExtendedLocationTypes} that the service accepts. */
exports.KnownExtendedLocationTypes = void 0;
(function (KnownExtendedLocationTypes) {
    /** EdgeZone */
    KnownExtendedLocationTypes["EdgeZone"] = "EdgeZone";
})(exports.KnownExtendedLocationTypes || (exports.KnownExtendedLocationTypes = {}));
/** Known values of {@link NetworkInterfaceNicType} that the service accepts. */
exports.KnownNetworkInterfaceNicType = void 0;
(function (KnownNetworkInterfaceNicType) {
    /** Standard */
    KnownNetworkInterfaceNicType["Standard"] = "Standard";
    /** Elastic */
    KnownNetworkInterfaceNicType["Elastic"] = "Elastic";
})(exports.KnownNetworkInterfaceNicType || (exports.KnownNetworkInterfaceNicType = {}));
/** Known values of {@link NetworkInterfaceMigrationPhase} that the service accepts. */
exports.KnownNetworkInterfaceMigrationPhase = void 0;
(function (KnownNetworkInterfaceMigrationPhase) {
    /** None */
    KnownNetworkInterfaceMigrationPhase["None"] = "None";
    /** Prepare */
    KnownNetworkInterfaceMigrationPhase["Prepare"] = "Prepare";
    /** Commit */
    KnownNetworkInterfaceMigrationPhase["Commit"] = "Commit";
    /** Abort */
    KnownNetworkInterfaceMigrationPhase["Abort"] = "Abort";
    /** Committed */
    KnownNetworkInterfaceMigrationPhase["Committed"] = "Committed";
})(exports.KnownNetworkInterfaceMigrationPhase || (exports.KnownNetworkInterfaceMigrationPhase = {}));
/** Known values of {@link NetworkInterfaceAuxiliaryMode} that the service accepts. */
exports.KnownNetworkInterfaceAuxiliaryMode = void 0;
(function (KnownNetworkInterfaceAuxiliaryMode) {
    /** None */
    KnownNetworkInterfaceAuxiliaryMode["None"] = "None";
    /** MaxConnections */
    KnownNetworkInterfaceAuxiliaryMode["MaxConnections"] = "MaxConnections";
    /** Floating */
    KnownNetworkInterfaceAuxiliaryMode["Floating"] = "Floating";
})(exports.KnownNetworkInterfaceAuxiliaryMode || (exports.KnownNetworkInterfaceAuxiliaryMode = {}));
/** Known values of {@link FlowLogFormatType} that the service accepts. */
exports.KnownFlowLogFormatType = void 0;
(function (KnownFlowLogFormatType) {
    /** Json */
    KnownFlowLogFormatType["Json"] = "JSON";
})(exports.KnownFlowLogFormatType || (exports.KnownFlowLogFormatType = {}));
/** Known values of {@link RouteNextHopType} that the service accepts. */
exports.KnownRouteNextHopType = void 0;
(function (KnownRouteNextHopType) {
    /** VirtualNetworkGateway */
    KnownRouteNextHopType["VirtualNetworkGateway"] = "VirtualNetworkGateway";
    /** VnetLocal */
    KnownRouteNextHopType["VnetLocal"] = "VnetLocal";
    /** Internet */
    KnownRouteNextHopType["Internet"] = "Internet";
    /** VirtualAppliance */
    KnownRouteNextHopType["VirtualAppliance"] = "VirtualAppliance";
    /** None */
    KnownRouteNextHopType["None"] = "None";
})(exports.KnownRouteNextHopType || (exports.KnownRouteNextHopType = {}));
/** Known values of {@link PublicIPAddressSkuName} that the service accepts. */
exports.KnownPublicIPAddressSkuName = void 0;
(function (KnownPublicIPAddressSkuName) {
    /** Basic */
    KnownPublicIPAddressSkuName["Basic"] = "Basic";
    /** Standard */
    KnownPublicIPAddressSkuName["Standard"] = "Standard";
})(exports.KnownPublicIPAddressSkuName || (exports.KnownPublicIPAddressSkuName = {}));
/** Known values of {@link PublicIPAddressSkuTier} that the service accepts. */
exports.KnownPublicIPAddressSkuTier = void 0;
(function (KnownPublicIPAddressSkuTier) {
    /** Regional */
    KnownPublicIPAddressSkuTier["Regional"] = "Regional";
    /** Global */
    KnownPublicIPAddressSkuTier["Global"] = "Global";
})(exports.KnownPublicIPAddressSkuTier || (exports.KnownPublicIPAddressSkuTier = {}));
/** Known values of {@link DdosSettingsProtectionMode} that the service accepts. */
exports.KnownDdosSettingsProtectionMode = void 0;
(function (KnownDdosSettingsProtectionMode) {
    /** VirtualNetworkInherited */
    KnownDdosSettingsProtectionMode["VirtualNetworkInherited"] = "VirtualNetworkInherited";
    /** Enabled */
    KnownDdosSettingsProtectionMode["Enabled"] = "Enabled";
    /** Disabled */
    KnownDdosSettingsProtectionMode["Disabled"] = "Disabled";
})(exports.KnownDdosSettingsProtectionMode || (exports.KnownDdosSettingsProtectionMode = {}));
/** Known values of {@link NatGatewaySkuName} that the service accepts. */
exports.KnownNatGatewaySkuName = void 0;
(function (KnownNatGatewaySkuName) {
    /** Standard */
    KnownNatGatewaySkuName["Standard"] = "Standard";
})(exports.KnownNatGatewaySkuName || (exports.KnownNatGatewaySkuName = {}));
/** Known values of {@link PublicIPAddressMigrationPhase} that the service accepts. */
exports.KnownPublicIPAddressMigrationPhase = void 0;
(function (KnownPublicIPAddressMigrationPhase) {
    /** None */
    KnownPublicIPAddressMigrationPhase["None"] = "None";
    /** Prepare */
    KnownPublicIPAddressMigrationPhase["Prepare"] = "Prepare";
    /** Commit */
    KnownPublicIPAddressMigrationPhase["Commit"] = "Commit";
    /** Abort */
    KnownPublicIPAddressMigrationPhase["Abort"] = "Abort";
    /** Committed */
    KnownPublicIPAddressMigrationPhase["Committed"] = "Committed";
})(exports.KnownPublicIPAddressMigrationPhase || (exports.KnownPublicIPAddressMigrationPhase = {}));
/** Known values of {@link DeleteOptions} that the service accepts. */
exports.KnownDeleteOptions = void 0;
(function (KnownDeleteOptions) {
    /** Delete */
    KnownDeleteOptions["Delete"] = "Delete";
    /** Detach */
    KnownDeleteOptions["Detach"] = "Detach";
})(exports.KnownDeleteOptions || (exports.KnownDeleteOptions = {}));
/** Known values of {@link VirtualNetworkPrivateEndpointNetworkPolicies} that the service accepts. */
exports.KnownVirtualNetworkPrivateEndpointNetworkPolicies = void 0;
(function (KnownVirtualNetworkPrivateEndpointNetworkPolicies) {
    /** Enabled */
    KnownVirtualNetworkPrivateEndpointNetworkPolicies["Enabled"] = "Enabled";
    /** Disabled */
    KnownVirtualNetworkPrivateEndpointNetworkPolicies["Disabled"] = "Disabled";
})(exports.KnownVirtualNetworkPrivateEndpointNetworkPolicies || (exports.KnownVirtualNetworkPrivateEndpointNetworkPolicies = {}));
/** Known values of {@link VirtualNetworkPrivateLinkServiceNetworkPolicies} that the service accepts. */
exports.KnownVirtualNetworkPrivateLinkServiceNetworkPolicies = void 0;
(function (KnownVirtualNetworkPrivateLinkServiceNetworkPolicies) {
    /** Enabled */
    KnownVirtualNetworkPrivateLinkServiceNetworkPolicies["Enabled"] = "Enabled";
    /** Disabled */
    KnownVirtualNetworkPrivateLinkServiceNetworkPolicies["Disabled"] = "Disabled";
})(exports.KnownVirtualNetworkPrivateLinkServiceNetworkPolicies || (exports.KnownVirtualNetworkPrivateLinkServiceNetworkPolicies = {}));
/** Known values of {@link GatewayLoadBalancerTunnelProtocol} that the service accepts. */
exports.KnownGatewayLoadBalancerTunnelProtocol = void 0;
(function (KnownGatewayLoadBalancerTunnelProtocol) {
    /** None */
    KnownGatewayLoadBalancerTunnelProtocol["None"] = "None";
    /** Native */
    KnownGatewayLoadBalancerTunnelProtocol["Native"] = "Native";
    /** Vxlan */
    KnownGatewayLoadBalancerTunnelProtocol["Vxlan"] = "VXLAN";
})(exports.KnownGatewayLoadBalancerTunnelProtocol || (exports.KnownGatewayLoadBalancerTunnelProtocol = {}));
/** Known values of {@link GatewayLoadBalancerTunnelInterfaceType} that the service accepts. */
exports.KnownGatewayLoadBalancerTunnelInterfaceType = void 0;
(function (KnownGatewayLoadBalancerTunnelInterfaceType) {
    /** None */
    KnownGatewayLoadBalancerTunnelInterfaceType["None"] = "None";
    /** Internal */
    KnownGatewayLoadBalancerTunnelInterfaceType["Internal"] = "Internal";
    /** External */
    KnownGatewayLoadBalancerTunnelInterfaceType["External"] = "External";
})(exports.KnownGatewayLoadBalancerTunnelInterfaceType || (exports.KnownGatewayLoadBalancerTunnelInterfaceType = {}));
/** Known values of {@link LoadBalancerBackendAddressAdminState} that the service accepts. */
exports.KnownLoadBalancerBackendAddressAdminState = void 0;
(function (KnownLoadBalancerBackendAddressAdminState) {
    /** None */
    KnownLoadBalancerBackendAddressAdminState["None"] = "None";
    /** Up */
    KnownLoadBalancerBackendAddressAdminState["Up"] = "Up";
    /** Down */
    KnownLoadBalancerBackendAddressAdminState["Down"] = "Down";
    /** Drain */
    KnownLoadBalancerBackendAddressAdminState["Drain"] = "Drain";
})(exports.KnownLoadBalancerBackendAddressAdminState || (exports.KnownLoadBalancerBackendAddressAdminState = {}));
/** Known values of {@link TransportProtocol} that the service accepts. */
exports.KnownTransportProtocol = void 0;
(function (KnownTransportProtocol) {
    /** Udp */
    KnownTransportProtocol["Udp"] = "Udp";
    /** Tcp */
    KnownTransportProtocol["Tcp"] = "Tcp";
    /** All */
    KnownTransportProtocol["All"] = "All";
})(exports.KnownTransportProtocol || (exports.KnownTransportProtocol = {}));
/** Known values of {@link ApplicationGatewayCookieBasedAffinity} that the service accepts. */
exports.KnownApplicationGatewayCookieBasedAffinity = void 0;
(function (KnownApplicationGatewayCookieBasedAffinity) {
    /** Enabled */
    KnownApplicationGatewayCookieBasedAffinity["Enabled"] = "Enabled";
    /** Disabled */
    KnownApplicationGatewayCookieBasedAffinity["Disabled"] = "Disabled";
})(exports.KnownApplicationGatewayCookieBasedAffinity || (exports.KnownApplicationGatewayCookieBasedAffinity = {}));
/** Known values of {@link ApplicationGatewayCustomErrorStatusCode} that the service accepts. */
exports.KnownApplicationGatewayCustomErrorStatusCode = void 0;
(function (KnownApplicationGatewayCustomErrorStatusCode) {
    /** HttpStatus400 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus400"] = "HttpStatus400";
    /** HttpStatus403 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus403"] = "HttpStatus403";
    /** HttpStatus404 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus404"] = "HttpStatus404";
    /** HttpStatus405 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus405"] = "HttpStatus405";
    /** HttpStatus408 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus408"] = "HttpStatus408";
    /** HttpStatus499 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus499"] = "HttpStatus499";
    /** HttpStatus500 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus500"] = "HttpStatus500";
    /** HttpStatus502 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus502"] = "HttpStatus502";
    /** HttpStatus503 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus503"] = "HttpStatus503";
    /** HttpStatus504 */
    KnownApplicationGatewayCustomErrorStatusCode["HttpStatus504"] = "HttpStatus504";
})(exports.KnownApplicationGatewayCustomErrorStatusCode || (exports.KnownApplicationGatewayCustomErrorStatusCode = {}));
/** Known values of {@link ApplicationGatewayClientRevocationOptions} that the service accepts. */
exports.KnownApplicationGatewayClientRevocationOptions = void 0;
(function (KnownApplicationGatewayClientRevocationOptions) {
    /** None */
    KnownApplicationGatewayClientRevocationOptions["None"] = "None";
    /** Ocsp */
    KnownApplicationGatewayClientRevocationOptions["Ocsp"] = "OCSP";
})(exports.KnownApplicationGatewayClientRevocationOptions || (exports.KnownApplicationGatewayClientRevocationOptions = {}));
/** Known values of {@link ApplicationGatewayRequestRoutingRuleType} that the service accepts. */
exports.KnownApplicationGatewayRequestRoutingRuleType = void 0;
(function (KnownApplicationGatewayRequestRoutingRuleType) {
    /** Basic */
    KnownApplicationGatewayRequestRoutingRuleType["Basic"] = "Basic";
    /** PathBasedRouting */
    KnownApplicationGatewayRequestRoutingRuleType["PathBasedRouting"] = "PathBasedRouting";
})(exports.KnownApplicationGatewayRequestRoutingRuleType || (exports.KnownApplicationGatewayRequestRoutingRuleType = {}));
/** Known values of {@link ApplicationGatewayRedirectType} that the service accepts. */
exports.KnownApplicationGatewayRedirectType = void 0;
(function (KnownApplicationGatewayRedirectType) {
    /** Permanent */
    KnownApplicationGatewayRedirectType["Permanent"] = "Permanent";
    /** Found */
    KnownApplicationGatewayRedirectType["Found"] = "Found";
    /** SeeOther */
    KnownApplicationGatewayRedirectType["SeeOther"] = "SeeOther";
    /** Temporary */
    KnownApplicationGatewayRedirectType["Temporary"] = "Temporary";
})(exports.KnownApplicationGatewayRedirectType || (exports.KnownApplicationGatewayRedirectType = {}));
/** Known values of {@link ApplicationGatewayFirewallMode} that the service accepts. */
exports.KnownApplicationGatewayFirewallMode = void 0;
(function (KnownApplicationGatewayFirewallMode) {
    /** Detection */
    KnownApplicationGatewayFirewallMode["Detection"] = "Detection";
    /** Prevention */
    KnownApplicationGatewayFirewallMode["Prevention"] = "Prevention";
})(exports.KnownApplicationGatewayFirewallMode || (exports.KnownApplicationGatewayFirewallMode = {}));
/** Known values of {@link ApplicationGatewayLoadDistributionAlgorithm} that the service accepts. */
exports.KnownApplicationGatewayLoadDistributionAlgorithm = void 0;
(function (KnownApplicationGatewayLoadDistributionAlgorithm) {
    /** RoundRobin */
    KnownApplicationGatewayLoadDistributionAlgorithm["RoundRobin"] = "RoundRobin";
    /** LeastConnections */
    KnownApplicationGatewayLoadDistributionAlgorithm["LeastConnections"] = "LeastConnections";
    /** IpHash */
    KnownApplicationGatewayLoadDistributionAlgorithm["IpHash"] = "IpHash";
})(exports.KnownApplicationGatewayLoadDistributionAlgorithm || (exports.KnownApplicationGatewayLoadDistributionAlgorithm = {}));
/** Known values of {@link ApplicationGatewayBackendHealthServerHealth} that the service accepts. */
exports.KnownApplicationGatewayBackendHealthServerHealth = void 0;
(function (KnownApplicationGatewayBackendHealthServerHealth) {
    /** Unknown */
    KnownApplicationGatewayBackendHealthServerHealth["Unknown"] = "Unknown";
    /** Up */
    KnownApplicationGatewayBackendHealthServerHealth["Up"] = "Up";
    /** Down */
    KnownApplicationGatewayBackendHealthServerHealth["Down"] = "Down";
    /** Partial */
    KnownApplicationGatewayBackendHealthServerHealth["Partial"] = "Partial";
    /** Draining */
    KnownApplicationGatewayBackendHealthServerHealth["Draining"] = "Draining";
})(exports.KnownApplicationGatewayBackendHealthServerHealth || (exports.KnownApplicationGatewayBackendHealthServerHealth = {}));
/** Known values of {@link ApplicationGatewayWafRuleStateTypes} that the service accepts. */
exports.KnownApplicationGatewayWafRuleStateTypes = void 0;
(function (KnownApplicationGatewayWafRuleStateTypes) {
    /** Enabled */
    KnownApplicationGatewayWafRuleStateTypes["Enabled"] = "Enabled";
    /** Disabled */
    KnownApplicationGatewayWafRuleStateTypes["Disabled"] = "Disabled";
})(exports.KnownApplicationGatewayWafRuleStateTypes || (exports.KnownApplicationGatewayWafRuleStateTypes = {}));
/** Known values of {@link ApplicationGatewayWafRuleActionTypes} that the service accepts. */
exports.KnownApplicationGatewayWafRuleActionTypes = void 0;
(function (KnownApplicationGatewayWafRuleActionTypes) {
    /** None */
    KnownApplicationGatewayWafRuleActionTypes["None"] = "None";
    /** AnomalyScoring */
    KnownApplicationGatewayWafRuleActionTypes["AnomalyScoring"] = "AnomalyScoring";
    /** Allow */
    KnownApplicationGatewayWafRuleActionTypes["Allow"] = "Allow";
    /** Block */
    KnownApplicationGatewayWafRuleActionTypes["Block"] = "Block";
    /** Log */
    KnownApplicationGatewayWafRuleActionTypes["Log"] = "Log";
})(exports.KnownApplicationGatewayWafRuleActionTypes || (exports.KnownApplicationGatewayWafRuleActionTypes = {}));
/** Known values of {@link ApplicationGatewayTierTypes} that the service accepts. */
exports.KnownApplicationGatewayTierTypes = void 0;
(function (KnownApplicationGatewayTierTypes) {
    /** Standard */
    KnownApplicationGatewayTierTypes["Standard"] = "Standard";
    /** WAF */
    KnownApplicationGatewayTierTypes["WAF"] = "WAF";
    /** StandardV2 */
    KnownApplicationGatewayTierTypes["StandardV2"] = "Standard_v2";
    /** WAFV2 */
    KnownApplicationGatewayTierTypes["WAFV2"] = "WAF_v2";
})(exports.KnownApplicationGatewayTierTypes || (exports.KnownApplicationGatewayTierTypes = {}));
/** Known values of {@link ApplicationGatewayRuleSetStatusOptions} that the service accepts. */
exports.KnownApplicationGatewayRuleSetStatusOptions = void 0;
(function (KnownApplicationGatewayRuleSetStatusOptions) {
    /** Preview */
    KnownApplicationGatewayRuleSetStatusOptions["Preview"] = "Preview";
    /** GA */
    KnownApplicationGatewayRuleSetStatusOptions["GA"] = "GA";
    /** Supported */
    KnownApplicationGatewayRuleSetStatusOptions["Supported"] = "Supported";
    /** Deprecated */
    KnownApplicationGatewayRuleSetStatusOptions["Deprecated"] = "Deprecated";
})(exports.KnownApplicationGatewayRuleSetStatusOptions || (exports.KnownApplicationGatewayRuleSetStatusOptions = {}));
/** Known values of {@link AzureFirewallRCActionType} that the service accepts. */
exports.KnownAzureFirewallRCActionType = void 0;
(function (KnownAzureFirewallRCActionType) {
    /** Allow */
    KnownAzureFirewallRCActionType["Allow"] = "Allow";
    /** Deny */
    KnownAzureFirewallRCActionType["Deny"] = "Deny";
})(exports.KnownAzureFirewallRCActionType || (exports.KnownAzureFirewallRCActionType = {}));
/** Known values of {@link AzureFirewallApplicationRuleProtocolType} that the service accepts. */
exports.KnownAzureFirewallApplicationRuleProtocolType = void 0;
(function (KnownAzureFirewallApplicationRuleProtocolType) {
    /** Http */
    KnownAzureFirewallApplicationRuleProtocolType["Http"] = "Http";
    /** Https */
    KnownAzureFirewallApplicationRuleProtocolType["Https"] = "Https";
    /** Mssql */
    KnownAzureFirewallApplicationRuleProtocolType["Mssql"] = "Mssql";
})(exports.KnownAzureFirewallApplicationRuleProtocolType || (exports.KnownAzureFirewallApplicationRuleProtocolType = {}));
/** Known values of {@link AzureFirewallNatRCActionType} that the service accepts. */
exports.KnownAzureFirewallNatRCActionType = void 0;
(function (KnownAzureFirewallNatRCActionType) {
    /** Snat */
    KnownAzureFirewallNatRCActionType["Snat"] = "Snat";
    /** Dnat */
    KnownAzureFirewallNatRCActionType["Dnat"] = "Dnat";
})(exports.KnownAzureFirewallNatRCActionType || (exports.KnownAzureFirewallNatRCActionType = {}));
/** Known values of {@link AzureFirewallNetworkRuleProtocol} that the service accepts. */
exports.KnownAzureFirewallNetworkRuleProtocol = void 0;
(function (KnownAzureFirewallNetworkRuleProtocol) {
    /** TCP */
    KnownAzureFirewallNetworkRuleProtocol["TCP"] = "TCP";
    /** UDP */
    KnownAzureFirewallNetworkRuleProtocol["UDP"] = "UDP";
    /** Any */
    KnownAzureFirewallNetworkRuleProtocol["Any"] = "Any";
    /** Icmp */
    KnownAzureFirewallNetworkRuleProtocol["Icmp"] = "ICMP";
})(exports.KnownAzureFirewallNetworkRuleProtocol || (exports.KnownAzureFirewallNetworkRuleProtocol = {}));
/** Known values of {@link AzureFirewallThreatIntelMode} that the service accepts. */
exports.KnownAzureFirewallThreatIntelMode = void 0;
(function (KnownAzureFirewallThreatIntelMode) {
    /** Alert */
    KnownAzureFirewallThreatIntelMode["Alert"] = "Alert";
    /** Deny */
    KnownAzureFirewallThreatIntelMode["Deny"] = "Deny";
    /** Off */
    KnownAzureFirewallThreatIntelMode["Off"] = "Off";
})(exports.KnownAzureFirewallThreatIntelMode || (exports.KnownAzureFirewallThreatIntelMode = {}));
/** Known values of {@link AzureFirewallSkuName} that the service accepts. */
exports.KnownAzureFirewallSkuName = void 0;
(function (KnownAzureFirewallSkuName) {
    /** AzfwVnet */
    KnownAzureFirewallSkuName["AzfwVnet"] = "AZFW_VNet";
    /** AzfwHub */
    KnownAzureFirewallSkuName["AzfwHub"] = "AZFW_Hub";
})(exports.KnownAzureFirewallSkuName || (exports.KnownAzureFirewallSkuName = {}));
/** Known values of {@link AzureFirewallSkuTier} that the service accepts. */
exports.KnownAzureFirewallSkuTier = void 0;
(function (KnownAzureFirewallSkuTier) {
    /** Standard */
    KnownAzureFirewallSkuTier["Standard"] = "Standard";
    /** Premium */
    KnownAzureFirewallSkuTier["Premium"] = "Premium";
    /** Basic */
    KnownAzureFirewallSkuTier["Basic"] = "Basic";
})(exports.KnownAzureFirewallSkuTier || (exports.KnownAzureFirewallSkuTier = {}));
/** Known values of {@link BastionHostSkuName} that the service accepts. */
exports.KnownBastionHostSkuName = void 0;
(function (KnownBastionHostSkuName) {
    /** Basic */
    KnownBastionHostSkuName["Basic"] = "Basic";
    /** Standard */
    KnownBastionHostSkuName["Standard"] = "Standard";
})(exports.KnownBastionHostSkuName || (exports.KnownBastionHostSkuName = {}));
/** Known values of {@link BastionConnectProtocol} that the service accepts. */
exports.KnownBastionConnectProtocol = void 0;
(function (KnownBastionConnectProtocol) {
    /** SSH */
    KnownBastionConnectProtocol["SSH"] = "SSH";
    /** RDP */
    KnownBastionConnectProtocol["RDP"] = "RDP";
})(exports.KnownBastionConnectProtocol || (exports.KnownBastionConnectProtocol = {}));
/** Known values of {@link CommissionedState} that the service accepts. */
exports.KnownCommissionedState = void 0;
(function (KnownCommissionedState) {
    /** Provisioning */
    KnownCommissionedState["Provisioning"] = "Provisioning";
    /** Provisioned */
    KnownCommissionedState["Provisioned"] = "Provisioned";
    /** Commissioning */
    KnownCommissionedState["Commissioning"] = "Commissioning";
    /** CommissionedNoInternetAdvertise */
    KnownCommissionedState["CommissionedNoInternetAdvertise"] = "CommissionedNoInternetAdvertise";
    /** Commissioned */
    KnownCommissionedState["Commissioned"] = "Commissioned";
    /** Decommissioning */
    KnownCommissionedState["Decommissioning"] = "Decommissioning";
    /** Deprovisioning */
    KnownCommissionedState["Deprovisioning"] = "Deprovisioning";
    /** Deprovisioned */
    KnownCommissionedState["Deprovisioned"] = "Deprovisioned";
})(exports.KnownCommissionedState || (exports.KnownCommissionedState = {}));
/** Known values of {@link Geo} that the service accepts. */
exports.KnownGeo = void 0;
(function (KnownGeo) {
    /** Global */
    KnownGeo["Global"] = "GLOBAL";
    /** Afri */
    KnownGeo["Afri"] = "AFRI";
    /** Apac */
    KnownGeo["Apac"] = "APAC";
    /** Euro */
    KnownGeo["Euro"] = "EURO";
    /** Latam */
    KnownGeo["Latam"] = "LATAM";
    /** NAM */
    KnownGeo["NAM"] = "NAM";
    /** ME */
    KnownGeo["ME"] = "ME";
    /** Oceania */
    KnownGeo["Oceania"] = "OCEANIA";
    /** AQ */
    KnownGeo["AQ"] = "AQ";
})(exports.KnownGeo || (exports.KnownGeo = {}));
/** Known values of {@link CustomIpPrefixType} that the service accepts. */
exports.KnownCustomIpPrefixType = void 0;
(function (KnownCustomIpPrefixType) {
    /** Singular */
    KnownCustomIpPrefixType["Singular"] = "Singular";
    /** Parent */
    KnownCustomIpPrefixType["Parent"] = "Parent";
    /** Child */
    KnownCustomIpPrefixType["Child"] = "Child";
})(exports.KnownCustomIpPrefixType || (exports.KnownCustomIpPrefixType = {}));
/** Known values of {@link ProtocolType} that the service accepts. */
exports.KnownProtocolType = void 0;
(function (KnownProtocolType) {
    /** DoNotUse */
    KnownProtocolType["DoNotUse"] = "DoNotUse";
    /** Icmp */
    KnownProtocolType["Icmp"] = "Icmp";
    /** Tcp */
    KnownProtocolType["Tcp"] = "Tcp";
    /** Udp */
    KnownProtocolType["Udp"] = "Udp";
    /** Gre */
    KnownProtocolType["Gre"] = "Gre";
    /** Esp */
    KnownProtocolType["Esp"] = "Esp";
    /** Ah */
    KnownProtocolType["Ah"] = "Ah";
    /** Vxlan */
    KnownProtocolType["Vxlan"] = "Vxlan";
    /** All */
    KnownProtocolType["All"] = "All";
})(exports.KnownProtocolType || (exports.KnownProtocolType = {}));
/** Known values of {@link AuthorizationUseStatus} that the service accepts. */
exports.KnownAuthorizationUseStatus = void 0;
(function (KnownAuthorizationUseStatus) {
    /** Available */
    KnownAuthorizationUseStatus["Available"] = "Available";
    /** InUse */
    KnownAuthorizationUseStatus["InUse"] = "InUse";
})(exports.KnownAuthorizationUseStatus || (exports.KnownAuthorizationUseStatus = {}));
/** Known values of {@link ExpressRoutePeeringType} that the service accepts. */
exports.KnownExpressRoutePeeringType = void 0;
(function (KnownExpressRoutePeeringType) {
    /** AzurePublicPeering */
    KnownExpressRoutePeeringType["AzurePublicPeering"] = "AzurePublicPeering";
    /** AzurePrivatePeering */
    KnownExpressRoutePeeringType["AzurePrivatePeering"] = "AzurePrivatePeering";
    /** MicrosoftPeering */
    KnownExpressRoutePeeringType["MicrosoftPeering"] = "MicrosoftPeering";
})(exports.KnownExpressRoutePeeringType || (exports.KnownExpressRoutePeeringType = {}));
/** Known values of {@link ExpressRoutePeeringState} that the service accepts. */
exports.KnownExpressRoutePeeringState = void 0;
(function (KnownExpressRoutePeeringState) {
    /** Disabled */
    KnownExpressRoutePeeringState["Disabled"] = "Disabled";
    /** Enabled */
    KnownExpressRoutePeeringState["Enabled"] = "Enabled";
})(exports.KnownExpressRoutePeeringState || (exports.KnownExpressRoutePeeringState = {}));
/** Known values of {@link ExpressRouteCircuitPeeringAdvertisedPublicPrefixState} that the service accepts. */
exports.KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState = void 0;
(function (KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState) {
    /** NotConfigured */
    KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState["NotConfigured"] = "NotConfigured";
    /** Configuring */
    KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState["Configuring"] = "Configuring";
    /** Configured */
    KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState["Configured"] = "Configured";
    /** ValidationNeeded */
    KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState["ValidationNeeded"] = "ValidationNeeded";
})(exports.KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState || (exports.KnownExpressRouteCircuitPeeringAdvertisedPublicPrefixState = {}));
/** Known values of {@link ExpressRouteCircuitPeeringState} that the service accepts. */
exports.KnownExpressRouteCircuitPeeringState = void 0;
(function (KnownExpressRouteCircuitPeeringState) {
    /** Disabled */
    KnownExpressRouteCircuitPeeringState["Disabled"] = "Disabled";
    /** Enabled */
    KnownExpressRouteCircuitPeeringState["Enabled"] = "Enabled";
})(exports.KnownExpressRouteCircuitPeeringState || (exports.KnownExpressRouteCircuitPeeringState = {}));
/** Known values of {@link CircuitConnectionStatus} that the service accepts. */
exports.KnownCircuitConnectionStatus = void 0;
(function (KnownCircuitConnectionStatus) {
    /** Connected */
    KnownCircuitConnectionStatus["Connected"] = "Connected";
    /** Connecting */
    KnownCircuitConnectionStatus["Connecting"] = "Connecting";
    /** Disconnected */
    KnownCircuitConnectionStatus["Disconnected"] = "Disconnected";
})(exports.KnownCircuitConnectionStatus || (exports.KnownCircuitConnectionStatus = {}));
/** Known values of {@link ExpressRouteCircuitSkuTier} that the service accepts. */
exports.KnownExpressRouteCircuitSkuTier = void 0;
(function (KnownExpressRouteCircuitSkuTier) {
    /** Standard */
    KnownExpressRouteCircuitSkuTier["Standard"] = "Standard";
    /** Premium */
    KnownExpressRouteCircuitSkuTier["Premium"] = "Premium";
    /** Basic */
    KnownExpressRouteCircuitSkuTier["Basic"] = "Basic";
    /** Local */
    KnownExpressRouteCircuitSkuTier["Local"] = "Local";
})(exports.KnownExpressRouteCircuitSkuTier || (exports.KnownExpressRouteCircuitSkuTier = {}));
/** Known values of {@link ExpressRouteCircuitSkuFamily} that the service accepts. */
exports.KnownExpressRouteCircuitSkuFamily = void 0;
(function (KnownExpressRouteCircuitSkuFamily) {
    /** UnlimitedData */
    KnownExpressRouteCircuitSkuFamily["UnlimitedData"] = "UnlimitedData";
    /** MeteredData */
    KnownExpressRouteCircuitSkuFamily["MeteredData"] = "MeteredData";
})(exports.KnownExpressRouteCircuitSkuFamily || (exports.KnownExpressRouteCircuitSkuFamily = {}));
/** Known values of {@link ServiceProviderProvisioningState} that the service accepts. */
exports.KnownServiceProviderProvisioningState = void 0;
(function (KnownServiceProviderProvisioningState) {
    /** NotProvisioned */
    KnownServiceProviderProvisioningState["NotProvisioned"] = "NotProvisioned";
    /** Provisioning */
    KnownServiceProviderProvisioningState["Provisioning"] = "Provisioning";
    /** Provisioned */
    KnownServiceProviderProvisioningState["Provisioned"] = "Provisioned";
    /** Deprovisioning */
    KnownServiceProviderProvisioningState["Deprovisioning"] = "Deprovisioning";
})(exports.KnownServiceProviderProvisioningState || (exports.KnownServiceProviderProvisioningState = {}));
/** Known values of {@link ExpressRoutePortsEncapsulation} that the service accepts. */
exports.KnownExpressRoutePortsEncapsulation = void 0;
(function (KnownExpressRoutePortsEncapsulation) {
    /** Dot1Q */
    KnownExpressRoutePortsEncapsulation["Dot1Q"] = "Dot1Q";
    /** QinQ */
    KnownExpressRoutePortsEncapsulation["QinQ"] = "QinQ";
})(exports.KnownExpressRoutePortsEncapsulation || (exports.KnownExpressRoutePortsEncapsulation = {}));
/** Known values of {@link ExpressRouteLinkConnectorType} that the service accepts. */
exports.KnownExpressRouteLinkConnectorType = void 0;
(function (KnownExpressRouteLinkConnectorType) {
    /** LC */
    KnownExpressRouteLinkConnectorType["LC"] = "LC";
    /** SC */
    KnownExpressRouteLinkConnectorType["SC"] = "SC";
})(exports.KnownExpressRouteLinkConnectorType || (exports.KnownExpressRouteLinkConnectorType = {}));
/** Known values of {@link ExpressRouteLinkAdminState} that the service accepts. */
exports.KnownExpressRouteLinkAdminState = void 0;
(function (KnownExpressRouteLinkAdminState) {
    /** Enabled */
    KnownExpressRouteLinkAdminState["Enabled"] = "Enabled";
    /** Disabled */
    KnownExpressRouteLinkAdminState["Disabled"] = "Disabled";
})(exports.KnownExpressRouteLinkAdminState || (exports.KnownExpressRouteLinkAdminState = {}));
/** Known values of {@link ExpressRouteLinkMacSecCipher} that the service accepts. */
exports.KnownExpressRouteLinkMacSecCipher = void 0;
(function (KnownExpressRouteLinkMacSecCipher) {
    /** GcmAes256 */
    KnownExpressRouteLinkMacSecCipher["GcmAes256"] = "GcmAes256";
    /** GcmAes128 */
    KnownExpressRouteLinkMacSecCipher["GcmAes128"] = "GcmAes128";
    /** GcmAesXpn128 */
    KnownExpressRouteLinkMacSecCipher["GcmAesXpn128"] = "GcmAesXpn128";
    /** GcmAesXpn256 */
    KnownExpressRouteLinkMacSecCipher["GcmAesXpn256"] = "GcmAesXpn256";
})(exports.KnownExpressRouteLinkMacSecCipher || (exports.KnownExpressRouteLinkMacSecCipher = {}));
/** Known values of {@link ExpressRouteLinkMacSecSciState} that the service accepts. */
exports.KnownExpressRouteLinkMacSecSciState = void 0;
(function (KnownExpressRouteLinkMacSecSciState) {
    /** Disabled */
    KnownExpressRouteLinkMacSecSciState["Disabled"] = "Disabled";
    /** Enabled */
    KnownExpressRouteLinkMacSecSciState["Enabled"] = "Enabled";
})(exports.KnownExpressRouteLinkMacSecSciState || (exports.KnownExpressRouteLinkMacSecSciState = {}));
/** Known values of {@link ExpressRoutePortsBillingType} that the service accepts. */
exports.KnownExpressRoutePortsBillingType = void 0;
(function (KnownExpressRoutePortsBillingType) {
    /** MeteredData */
    KnownExpressRoutePortsBillingType["MeteredData"] = "MeteredData";
    /** UnlimitedData */
    KnownExpressRoutePortsBillingType["UnlimitedData"] = "UnlimitedData";
})(exports.KnownExpressRoutePortsBillingType || (exports.KnownExpressRoutePortsBillingType = {}));
/** Known values of {@link ExpressRoutePortAuthorizationUseStatus} that the service accepts. */
exports.KnownExpressRoutePortAuthorizationUseStatus = void 0;
(function (KnownExpressRoutePortAuthorizationUseStatus) {
    /** Available */
    KnownExpressRoutePortAuthorizationUseStatus["Available"] = "Available";
    /** InUse */
    KnownExpressRoutePortAuthorizationUseStatus["InUse"] = "InUse";
})(exports.KnownExpressRoutePortAuthorizationUseStatus || (exports.KnownExpressRoutePortAuthorizationUseStatus = {}));
/** Known values of {@link AutoLearnPrivateRangesMode} that the service accepts. */
exports.KnownAutoLearnPrivateRangesMode = void 0;
(function (KnownAutoLearnPrivateRangesMode) {
    /** Enabled */
    KnownAutoLearnPrivateRangesMode["Enabled"] = "Enabled";
    /** Disabled */
    KnownAutoLearnPrivateRangesMode["Disabled"] = "Disabled";
})(exports.KnownAutoLearnPrivateRangesMode || (exports.KnownAutoLearnPrivateRangesMode = {}));
/** Known values of {@link FirewallPolicyIntrusionDetectionStateType} that the service accepts. */
exports.KnownFirewallPolicyIntrusionDetectionStateType = void 0;
(function (KnownFirewallPolicyIntrusionDetectionStateType) {
    /** Off */
    KnownFirewallPolicyIntrusionDetectionStateType["Off"] = "Off";
    /** Alert */
    KnownFirewallPolicyIntrusionDetectionStateType["Alert"] = "Alert";
    /** Deny */
    KnownFirewallPolicyIntrusionDetectionStateType["Deny"] = "Deny";
})(exports.KnownFirewallPolicyIntrusionDetectionStateType || (exports.KnownFirewallPolicyIntrusionDetectionStateType = {}));
/** Known values of {@link FirewallPolicyIntrusionDetectionProtocol} that the service accepts. */
exports.KnownFirewallPolicyIntrusionDetectionProtocol = void 0;
(function (KnownFirewallPolicyIntrusionDetectionProtocol) {
    /** TCP */
    KnownFirewallPolicyIntrusionDetectionProtocol["TCP"] = "TCP";
    /** UDP */
    KnownFirewallPolicyIntrusionDetectionProtocol["UDP"] = "UDP";
    /** Icmp */
    KnownFirewallPolicyIntrusionDetectionProtocol["Icmp"] = "ICMP";
    /** ANY */
    KnownFirewallPolicyIntrusionDetectionProtocol["ANY"] = "ANY";
})(exports.KnownFirewallPolicyIntrusionDetectionProtocol || (exports.KnownFirewallPolicyIntrusionDetectionProtocol = {}));
/** Known values of {@link FirewallPolicySkuTier} that the service accepts. */
exports.KnownFirewallPolicySkuTier = void 0;
(function (KnownFirewallPolicySkuTier) {
    /** Standard */
    KnownFirewallPolicySkuTier["Standard"] = "Standard";
    /** Premium */
    KnownFirewallPolicySkuTier["Premium"] = "Premium";
    /** Basic */
    KnownFirewallPolicySkuTier["Basic"] = "Basic";
})(exports.KnownFirewallPolicySkuTier || (exports.KnownFirewallPolicySkuTier = {}));
/** Known values of {@link FirewallPolicyRuleCollectionType} that the service accepts. */
exports.KnownFirewallPolicyRuleCollectionType = void 0;
(function (KnownFirewallPolicyRuleCollectionType) {
    /** FirewallPolicyNatRuleCollection */
    KnownFirewallPolicyRuleCollectionType["FirewallPolicyNatRuleCollection"] = "FirewallPolicyNatRuleCollection";
    /** FirewallPolicyFilterRuleCollection */
    KnownFirewallPolicyRuleCollectionType["FirewallPolicyFilterRuleCollection"] = "FirewallPolicyFilterRuleCollection";
})(exports.KnownFirewallPolicyRuleCollectionType || (exports.KnownFirewallPolicyRuleCollectionType = {}));
/** Known values of {@link FirewallPolicyIdpsQuerySortOrder} that the service accepts. */
exports.KnownFirewallPolicyIdpsQuerySortOrder = void 0;
(function (KnownFirewallPolicyIdpsQuerySortOrder) {
    /** Ascending */
    KnownFirewallPolicyIdpsQuerySortOrder["Ascending"] = "Ascending";
    /** Descending */
    KnownFirewallPolicyIdpsQuerySortOrder["Descending"] = "Descending";
})(exports.KnownFirewallPolicyIdpsQuerySortOrder || (exports.KnownFirewallPolicyIdpsQuerySortOrder = {}));
/** Known values of {@link IpAllocationType} that the service accepts. */
exports.KnownIpAllocationType = void 0;
(function (KnownIpAllocationType) {
    /** Undefined */
    KnownIpAllocationType["Undefined"] = "Undefined";
    /** Hypernet */
    KnownIpAllocationType["Hypernet"] = "Hypernet";
})(exports.KnownIpAllocationType || (exports.KnownIpAllocationType = {}));
/** Known values of {@link LoadBalancerSkuName} that the service accepts. */
exports.KnownLoadBalancerSkuName = void 0;
(function (KnownLoadBalancerSkuName) {
    /** Basic */
    KnownLoadBalancerSkuName["Basic"] = "Basic";
    /** Standard */
    KnownLoadBalancerSkuName["Standard"] = "Standard";
    /** Gateway */
    KnownLoadBalancerSkuName["Gateway"] = "Gateway";
})(exports.KnownLoadBalancerSkuName || (exports.KnownLoadBalancerSkuName = {}));
/** Known values of {@link LoadBalancerSkuTier} that the service accepts. */
exports.KnownLoadBalancerSkuTier = void 0;
(function (KnownLoadBalancerSkuTier) {
    /** Regional */
    KnownLoadBalancerSkuTier["Regional"] = "Regional";
    /** Global */
    KnownLoadBalancerSkuTier["Global"] = "Global";
})(exports.KnownLoadBalancerSkuTier || (exports.KnownLoadBalancerSkuTier = {}));
/** Known values of {@link LoadDistribution} that the service accepts. */
exports.KnownLoadDistribution = void 0;
(function (KnownLoadDistribution) {
    /** Default */
    KnownLoadDistribution["Default"] = "Default";
    /** SourceIP */
    KnownLoadDistribution["SourceIP"] = "SourceIP";
    /** SourceIPProtocol */
    KnownLoadDistribution["SourceIPProtocol"] = "SourceIPProtocol";
})(exports.KnownLoadDistribution || (exports.KnownLoadDistribution = {}));
/** Known values of {@link ProbeProtocol} that the service accepts. */
exports.KnownProbeProtocol = void 0;
(function (KnownProbeProtocol) {
    /** Http */
    KnownProbeProtocol["Http"] = "Http";
    /** Tcp */
    KnownProbeProtocol["Tcp"] = "Tcp";
    /** Https */
    KnownProbeProtocol["Https"] = "Https";
})(exports.KnownProbeProtocol || (exports.KnownProbeProtocol = {}));
/** Known values of {@link LoadBalancerOutboundRuleProtocol} that the service accepts. */
exports.KnownLoadBalancerOutboundRuleProtocol = void 0;
(function (KnownLoadBalancerOutboundRuleProtocol) {
    /** Tcp */
    KnownLoadBalancerOutboundRuleProtocol["Tcp"] = "Tcp";
    /** Udp */
    KnownLoadBalancerOutboundRuleProtocol["Udp"] = "Udp";
    /** All */
    KnownLoadBalancerOutboundRuleProtocol["All"] = "All";
})(exports.KnownLoadBalancerOutboundRuleProtocol || (exports.KnownLoadBalancerOutboundRuleProtocol = {}));
/** Known values of {@link EffectiveRouteSource} that the service accepts. */
exports.KnownEffectiveRouteSource = void 0;
(function (KnownEffectiveRouteSource) {
    /** Unknown */
    KnownEffectiveRouteSource["Unknown"] = "Unknown";
    /** User */
    KnownEffectiveRouteSource["User"] = "User";
    /** VirtualNetworkGateway */
    KnownEffectiveRouteSource["VirtualNetworkGateway"] = "VirtualNetworkGateway";
    /** Default */
    KnownEffectiveRouteSource["Default"] = "Default";
})(exports.KnownEffectiveRouteSource || (exports.KnownEffectiveRouteSource = {}));
/** Known values of {@link EffectiveRouteState} that the service accepts. */
exports.KnownEffectiveRouteState = void 0;
(function (KnownEffectiveRouteState) {
    /** Active */
    KnownEffectiveRouteState["Active"] = "Active";
    /** Invalid */
    KnownEffectiveRouteState["Invalid"] = "Invalid";
})(exports.KnownEffectiveRouteState || (exports.KnownEffectiveRouteState = {}));
/** Known values of {@link EffectiveSecurityRuleProtocol} that the service accepts. */
exports.KnownEffectiveSecurityRuleProtocol = void 0;
(function (KnownEffectiveSecurityRuleProtocol) {
    /** Tcp */
    KnownEffectiveSecurityRuleProtocol["Tcp"] = "Tcp";
    /** Udp */
    KnownEffectiveSecurityRuleProtocol["Udp"] = "Udp";
    /** All */
    KnownEffectiveSecurityRuleProtocol["All"] = "All";
})(exports.KnownEffectiveSecurityRuleProtocol || (exports.KnownEffectiveSecurityRuleProtocol = {}));
/** Known values of {@link ConfigurationType} that the service accepts. */
exports.KnownConfigurationType = void 0;
(function (KnownConfigurationType) {
    /** SecurityAdmin */
    KnownConfigurationType["SecurityAdmin"] = "SecurityAdmin";
    /** Connectivity */
    KnownConfigurationType["Connectivity"] = "Connectivity";
})(exports.KnownConfigurationType || (exports.KnownConfigurationType = {}));
/** Known values of {@link CreatedByType} that the service accepts. */
exports.KnownCreatedByType = void 0;
(function (KnownCreatedByType) {
    /** User */
    KnownCreatedByType["User"] = "User";
    /** Application */
    KnownCreatedByType["Application"] = "Application";
    /** ManagedIdentity */
    KnownCreatedByType["ManagedIdentity"] = "ManagedIdentity";
    /** Key */
    KnownCreatedByType["Key"] = "Key";
})(exports.KnownCreatedByType || (exports.KnownCreatedByType = {}));
/** Known values of {@link DeploymentStatus} that the service accepts. */
exports.KnownDeploymentStatus = void 0;
(function (KnownDeploymentStatus) {
    /** NotStarted */
    KnownDeploymentStatus["NotStarted"] = "NotStarted";
    /** Deploying */
    KnownDeploymentStatus["Deploying"] = "Deploying";
    /** Deployed */
    KnownDeploymentStatus["Deployed"] = "Deployed";
    /** Failed */
    KnownDeploymentStatus["Failed"] = "Failed";
})(exports.KnownDeploymentStatus || (exports.KnownDeploymentStatus = {}));
/** Known values of {@link ConnectivityTopology} that the service accepts. */
exports.KnownConnectivityTopology = void 0;
(function (KnownConnectivityTopology) {
    /** HubAndSpoke */
    KnownConnectivityTopology["HubAndSpoke"] = "HubAndSpoke";
    /** Mesh */
    KnownConnectivityTopology["Mesh"] = "Mesh";
})(exports.KnownConnectivityTopology || (exports.KnownConnectivityTopology = {}));
/** Known values of {@link IsGlobal} that the service accepts. */
exports.KnownIsGlobal = void 0;
(function (KnownIsGlobal) {
    /** False */
    KnownIsGlobal["False"] = "False";
    /** True */
    KnownIsGlobal["True"] = "True";
})(exports.KnownIsGlobal || (exports.KnownIsGlobal = {}));
/** Known values of {@link UseHubGateway} that the service accepts. */
exports.KnownUseHubGateway = void 0;
(function (KnownUseHubGateway) {
    /** False */
    KnownUseHubGateway["False"] = "False";
    /** True */
    KnownUseHubGateway["True"] = "True";
})(exports.KnownUseHubGateway || (exports.KnownUseHubGateway = {}));
/** Known values of {@link GroupConnectivity} that the service accepts. */
exports.KnownGroupConnectivity = void 0;
(function (KnownGroupConnectivity) {
    /** None */
    KnownGroupConnectivity["None"] = "None";
    /** DirectlyConnected */
    KnownGroupConnectivity["DirectlyConnected"] = "DirectlyConnected";
})(exports.KnownGroupConnectivity || (exports.KnownGroupConnectivity = {}));
/** Known values of {@link DeleteExistingPeering} that the service accepts. */
exports.KnownDeleteExistingPeering = void 0;
(function (KnownDeleteExistingPeering) {
    /** False */
    KnownDeleteExistingPeering["False"] = "False";
    /** True */
    KnownDeleteExistingPeering["True"] = "True";
})(exports.KnownDeleteExistingPeering || (exports.KnownDeleteExistingPeering = {}));
/** Known values of {@link EffectiveAdminRuleKind} that the service accepts. */
exports.KnownEffectiveAdminRuleKind = void 0;
(function (KnownEffectiveAdminRuleKind) {
    /** Custom */
    KnownEffectiveAdminRuleKind["Custom"] = "Custom";
    /** Default */
    KnownEffectiveAdminRuleKind["Default"] = "Default";
})(exports.KnownEffectiveAdminRuleKind || (exports.KnownEffectiveAdminRuleKind = {}));
/** Known values of {@link ScopeConnectionState} that the service accepts. */
exports.KnownScopeConnectionState = void 0;
(function (KnownScopeConnectionState) {
    /** Connected */
    KnownScopeConnectionState["Connected"] = "Connected";
    /** Pending */
    KnownScopeConnectionState["Pending"] = "Pending";
    /** Conflict */
    KnownScopeConnectionState["Conflict"] = "Conflict";
    /** Revoked */
    KnownScopeConnectionState["Revoked"] = "Revoked";
    /** Rejected */
    KnownScopeConnectionState["Rejected"] = "Rejected";
})(exports.KnownScopeConnectionState || (exports.KnownScopeConnectionState = {}));
/** Known values of {@link NetworkIntentPolicyBasedService} that the service accepts. */
exports.KnownNetworkIntentPolicyBasedService = void 0;
(function (KnownNetworkIntentPolicyBasedService) {
    /** None */
    KnownNetworkIntentPolicyBasedService["None"] = "None";
    /** All */
    KnownNetworkIntentPolicyBasedService["All"] = "All";
    /** AllowRulesOnly */
    KnownNetworkIntentPolicyBasedService["AllowRulesOnly"] = "AllowRulesOnly";
})(exports.KnownNetworkIntentPolicyBasedService || (exports.KnownNetworkIntentPolicyBasedService = {}));
/** Known values of {@link AdminRuleKind} that the service accepts. */
exports.KnownAdminRuleKind = void 0;
(function (KnownAdminRuleKind) {
    /** Custom */
    KnownAdminRuleKind["Custom"] = "Custom";
    /** Default */
    KnownAdminRuleKind["Default"] = "Default";
})(exports.KnownAdminRuleKind || (exports.KnownAdminRuleKind = {}));
/** Known values of {@link InboundSecurityRulesProtocol} that the service accepts. */
exports.KnownInboundSecurityRulesProtocol = void 0;
(function (KnownInboundSecurityRulesProtocol) {
    /** TCP */
    KnownInboundSecurityRulesProtocol["TCP"] = "TCP";
    /** UDP */
    KnownInboundSecurityRulesProtocol["UDP"] = "UDP";
})(exports.KnownInboundSecurityRulesProtocol || (exports.KnownInboundSecurityRulesProtocol = {}));
/** Known values of {@link AssociationType} that the service accepts. */
exports.KnownAssociationType = void 0;
(function (KnownAssociationType) {
    /** Associated */
    KnownAssociationType["Associated"] = "Associated";
    /** Contains */
    KnownAssociationType["Contains"] = "Contains";
})(exports.KnownAssociationType || (exports.KnownAssociationType = {}));
/** Known values of {@link Direction} that the service accepts. */
exports.KnownDirection = void 0;
(function (KnownDirection) {
    /** Inbound */
    KnownDirection["Inbound"] = "Inbound";
    /** Outbound */
    KnownDirection["Outbound"] = "Outbound";
})(exports.KnownDirection || (exports.KnownDirection = {}));
/** Known values of {@link IpFlowProtocol} that the service accepts. */
exports.KnownIpFlowProtocol = void 0;
(function (KnownIpFlowProtocol) {
    /** TCP */
    KnownIpFlowProtocol["TCP"] = "TCP";
    /** UDP */
    KnownIpFlowProtocol["UDP"] = "UDP";
})(exports.KnownIpFlowProtocol || (exports.KnownIpFlowProtocol = {}));
/** Known values of {@link Access} that the service accepts. */
exports.KnownAccess = void 0;
(function (KnownAccess) {
    /** Allow */
    KnownAccess["Allow"] = "Allow";
    /** Deny */
    KnownAccess["Deny"] = "Deny";
})(exports.KnownAccess || (exports.KnownAccess = {}));
/** Known values of {@link NextHopType} that the service accepts. */
exports.KnownNextHopType = void 0;
(function (KnownNextHopType) {
    /** Internet */
    KnownNextHopType["Internet"] = "Internet";
    /** VirtualAppliance */
    KnownNextHopType["VirtualAppliance"] = "VirtualAppliance";
    /** VirtualNetworkGateway */
    KnownNextHopType["VirtualNetworkGateway"] = "VirtualNetworkGateway";
    /** VnetLocal */
    KnownNextHopType["VnetLocal"] = "VnetLocal";
    /** HyperNetGateway */
    KnownNextHopType["HyperNetGateway"] = "HyperNetGateway";
    /** None */
    KnownNextHopType["None"] = "None";
})(exports.KnownNextHopType || (exports.KnownNextHopType = {}));
/** Known values of {@link PcProtocol} that the service accepts. */
exports.KnownPcProtocol = void 0;
(function (KnownPcProtocol) {
    /** TCP */
    KnownPcProtocol["TCP"] = "TCP";
    /** UDP */
    KnownPcProtocol["UDP"] = "UDP";
    /** Any */
    KnownPcProtocol["Any"] = "Any";
})(exports.KnownPcProtocol || (exports.KnownPcProtocol = {}));
/** Known values of {@link PcStatus} that the service accepts. */
exports.KnownPcStatus = void 0;
(function (KnownPcStatus) {
    /** NotStarted */
    KnownPcStatus["NotStarted"] = "NotStarted";
    /** Running */
    KnownPcStatus["Running"] = "Running";
    /** Stopped */
    KnownPcStatus["Stopped"] = "Stopped";
    /** Error */
    KnownPcStatus["Error"] = "Error";
    /** Unknown */
    KnownPcStatus["Unknown"] = "Unknown";
})(exports.KnownPcStatus || (exports.KnownPcStatus = {}));
/** Known values of {@link PcError} that the service accepts. */
exports.KnownPcError = void 0;
(function (KnownPcError) {
    /** InternalError */
    KnownPcError["InternalError"] = "InternalError";
    /** AgentStopped */
    KnownPcError["AgentStopped"] = "AgentStopped";
    /** CaptureFailed */
    KnownPcError["CaptureFailed"] = "CaptureFailed";
    /** LocalFileFailed */
    KnownPcError["LocalFileFailed"] = "LocalFileFailed";
    /** StorageFailed */
    KnownPcError["StorageFailed"] = "StorageFailed";
})(exports.KnownPcError || (exports.KnownPcError = {}));
/** Known values of {@link Protocol} that the service accepts. */
exports.KnownProtocol = void 0;
(function (KnownProtocol) {
    /** Tcp */
    KnownProtocol["Tcp"] = "Tcp";
    /** Http */
    KnownProtocol["Http"] = "Http";
    /** Https */
    KnownProtocol["Https"] = "Https";
    /** Icmp */
    KnownProtocol["Icmp"] = "Icmp";
})(exports.KnownProtocol || (exports.KnownProtocol = {}));
/** Known values of {@link HttpMethod} that the service accepts. */
exports.KnownHttpMethod = void 0;
(function (KnownHttpMethod) {
    /** Get */
    KnownHttpMethod["Get"] = "Get";
})(exports.KnownHttpMethod || (exports.KnownHttpMethod = {}));
/** Known values of {@link Origin} that the service accepts. */
exports.KnownOrigin = void 0;
(function (KnownOrigin) {
    /** Local */
    KnownOrigin["Local"] = "Local";
    /** Inbound */
    KnownOrigin["Inbound"] = "Inbound";
    /** Outbound */
    KnownOrigin["Outbound"] = "Outbound";
})(exports.KnownOrigin || (exports.KnownOrigin = {}));
/** Known values of {@link Severity} that the service accepts. */
exports.KnownSeverity = void 0;
(function (KnownSeverity) {
    /** Error */
    KnownSeverity["Error"] = "Error";
    /** Warning */
    KnownSeverity["Warning"] = "Warning";
})(exports.KnownSeverity || (exports.KnownSeverity = {}));
/** Known values of {@link IssueType} that the service accepts. */
exports.KnownIssueType = void 0;
(function (KnownIssueType) {
    /** Unknown */
    KnownIssueType["Unknown"] = "Unknown";
    /** AgentStopped */
    KnownIssueType["AgentStopped"] = "AgentStopped";
    /** GuestFirewall */
    KnownIssueType["GuestFirewall"] = "GuestFirewall";
    /** DnsResolution */
    KnownIssueType["DnsResolution"] = "DnsResolution";
    /** SocketBind */
    KnownIssueType["SocketBind"] = "SocketBind";
    /** NetworkSecurityRule */
    KnownIssueType["NetworkSecurityRule"] = "NetworkSecurityRule";
    /** UserDefinedRoute */
    KnownIssueType["UserDefinedRoute"] = "UserDefinedRoute";
    /** PortThrottled */
    KnownIssueType["PortThrottled"] = "PortThrottled";
    /** Platform */
    KnownIssueType["Platform"] = "Platform";
})(exports.KnownIssueType || (exports.KnownIssueType = {}));
/** Known values of {@link ConnectionStatus} that the service accepts. */
exports.KnownConnectionStatus = void 0;
(function (KnownConnectionStatus) {
    /** Unknown */
    KnownConnectionStatus["Unknown"] = "Unknown";
    /** Connected */
    KnownConnectionStatus["Connected"] = "Connected";
    /** Disconnected */
    KnownConnectionStatus["Disconnected"] = "Disconnected";
    /** Degraded */
    KnownConnectionStatus["Degraded"] = "Degraded";
})(exports.KnownConnectionStatus || (exports.KnownConnectionStatus = {}));
/** Known values of {@link VerbosityLevel} that the service accepts. */
exports.KnownVerbosityLevel = void 0;
(function (KnownVerbosityLevel) {
    /** Normal */
    KnownVerbosityLevel["Normal"] = "Normal";
    /** Minimum */
    KnownVerbosityLevel["Minimum"] = "Minimum";
    /** Full */
    KnownVerbosityLevel["Full"] = "Full";
})(exports.KnownVerbosityLevel || (exports.KnownVerbosityLevel = {}));
/** Known values of {@link EndpointType} that the service accepts. */
exports.KnownEndpointType = void 0;
(function (KnownEndpointType) {
    /** AzureVM */
    KnownEndpointType["AzureVM"] = "AzureVM";
    /** AzureVNet */
    KnownEndpointType["AzureVNet"] = "AzureVNet";
    /** AzureSubnet */
    KnownEndpointType["AzureSubnet"] = "AzureSubnet";
    /** ExternalAddress */
    KnownEndpointType["ExternalAddress"] = "ExternalAddress";
    /** MMAWorkspaceMachine */
    KnownEndpointType["MMAWorkspaceMachine"] = "MMAWorkspaceMachine";
    /** MMAWorkspaceNetwork */
    KnownEndpointType["MMAWorkspaceNetwork"] = "MMAWorkspaceNetwork";
    /** AzureArcVM */
    KnownEndpointType["AzureArcVM"] = "AzureArcVM";
    /** AzureVmss */
    KnownEndpointType["AzureVmss"] = "AzureVMSS";
})(exports.KnownEndpointType || (exports.KnownEndpointType = {}));
/** Known values of {@link ConnectionMonitorEndpointFilterType} that the service accepts. */
exports.KnownConnectionMonitorEndpointFilterType = void 0;
(function (KnownConnectionMonitorEndpointFilterType) {
    /** Include */
    KnownConnectionMonitorEndpointFilterType["Include"] = "Include";
})(exports.KnownConnectionMonitorEndpointFilterType || (exports.KnownConnectionMonitorEndpointFilterType = {}));
/** Known values of {@link ConnectionMonitorEndpointFilterItemType} that the service accepts. */
exports.KnownConnectionMonitorEndpointFilterItemType = void 0;
(function (KnownConnectionMonitorEndpointFilterItemType) {
    /** AgentAddress */
    KnownConnectionMonitorEndpointFilterItemType["AgentAddress"] = "AgentAddress";
})(exports.KnownConnectionMonitorEndpointFilterItemType || (exports.KnownConnectionMonitorEndpointFilterItemType = {}));
/** Known values of {@link CoverageLevel} that the service accepts. */
exports.KnownCoverageLevel = void 0;
(function (KnownCoverageLevel) {
    /** Default */
    KnownCoverageLevel["Default"] = "Default";
    /** Low */
    KnownCoverageLevel["Low"] = "Low";
    /** BelowAverage */
    KnownCoverageLevel["BelowAverage"] = "BelowAverage";
    /** Average */
    KnownCoverageLevel["Average"] = "Average";
    /** AboveAverage */
    KnownCoverageLevel["AboveAverage"] = "AboveAverage";
    /** Full */
    KnownCoverageLevel["Full"] = "Full";
})(exports.KnownCoverageLevel || (exports.KnownCoverageLevel = {}));
/** Known values of {@link ConnectionMonitorTestConfigurationProtocol} that the service accepts. */
exports.KnownConnectionMonitorTestConfigurationProtocol = void 0;
(function (KnownConnectionMonitorTestConfigurationProtocol) {
    /** Tcp */
    KnownConnectionMonitorTestConfigurationProtocol["Tcp"] = "Tcp";
    /** Http */
    KnownConnectionMonitorTestConfigurationProtocol["Http"] = "Http";
    /** Icmp */
    KnownConnectionMonitorTestConfigurationProtocol["Icmp"] = "Icmp";
})(exports.KnownConnectionMonitorTestConfigurationProtocol || (exports.KnownConnectionMonitorTestConfigurationProtocol = {}));
/** Known values of {@link PreferredIPVersion} that the service accepts. */
exports.KnownPreferredIPVersion = void 0;
(function (KnownPreferredIPVersion) {
    /** IPv4 */
    KnownPreferredIPVersion["IPv4"] = "IPv4";
    /** IPv6 */
    KnownPreferredIPVersion["IPv6"] = "IPv6";
})(exports.KnownPreferredIPVersion || (exports.KnownPreferredIPVersion = {}));
/** Known values of {@link HttpConfigurationMethod} that the service accepts. */
exports.KnownHttpConfigurationMethod = void 0;
(function (KnownHttpConfigurationMethod) {
    /** Get */
    KnownHttpConfigurationMethod["Get"] = "Get";
    /** Post */
    KnownHttpConfigurationMethod["Post"] = "Post";
})(exports.KnownHttpConfigurationMethod || (exports.KnownHttpConfigurationMethod = {}));
/** Known values of {@link DestinationPortBehavior} that the service accepts. */
exports.KnownDestinationPortBehavior = void 0;
(function (KnownDestinationPortBehavior) {
    /** None */
    KnownDestinationPortBehavior["None"] = "None";
    /** ListenIfAvailable */
    KnownDestinationPortBehavior["ListenIfAvailable"] = "ListenIfAvailable";
})(exports.KnownDestinationPortBehavior || (exports.KnownDestinationPortBehavior = {}));
/** Known values of {@link OutputType} that the service accepts. */
exports.KnownOutputType = void 0;
(function (KnownOutputType) {
    /** Workspace */
    KnownOutputType["Workspace"] = "Workspace";
})(exports.KnownOutputType || (exports.KnownOutputType = {}));
/** Known values of {@link ConnectionMonitorType} that the service accepts. */
exports.KnownConnectionMonitorType = void 0;
(function (KnownConnectionMonitorType) {
    /** MultiEndpoint */
    KnownConnectionMonitorType["MultiEndpoint"] = "MultiEndpoint";
    /** SingleSourceDestination */
    KnownConnectionMonitorType["SingleSourceDestination"] = "SingleSourceDestination";
})(exports.KnownConnectionMonitorType || (exports.KnownConnectionMonitorType = {}));
/** Known values of {@link ConnectionMonitorSourceStatus} that the service accepts. */
exports.KnownConnectionMonitorSourceStatus = void 0;
(function (KnownConnectionMonitorSourceStatus) {
    /** Unknown */
    KnownConnectionMonitorSourceStatus["Unknown"] = "Unknown";
    /** Active */
    KnownConnectionMonitorSourceStatus["Active"] = "Active";
    /** Inactive */
    KnownConnectionMonitorSourceStatus["Inactive"] = "Inactive";
})(exports.KnownConnectionMonitorSourceStatus || (exports.KnownConnectionMonitorSourceStatus = {}));
/** Known values of {@link ConnectionState} that the service accepts. */
exports.KnownConnectionState = void 0;
(function (KnownConnectionState) {
    /** Reachable */
    KnownConnectionState["Reachable"] = "Reachable";
    /** Unreachable */
    KnownConnectionState["Unreachable"] = "Unreachable";
    /** Unknown */
    KnownConnectionState["Unknown"] = "Unknown";
})(exports.KnownConnectionState || (exports.KnownConnectionState = {}));
/** Known values of {@link EvaluationState} that the service accepts. */
exports.KnownEvaluationState = void 0;
(function (KnownEvaluationState) {
    /** NotStarted */
    KnownEvaluationState["NotStarted"] = "NotStarted";
    /** InProgress */
    KnownEvaluationState["InProgress"] = "InProgress";
    /** Completed */
    KnownEvaluationState["Completed"] = "Completed";
})(exports.KnownEvaluationState || (exports.KnownEvaluationState = {}));
/** Known values of {@link IsWorkloadProtected} that the service accepts. */
exports.KnownIsWorkloadProtected = void 0;
(function (KnownIsWorkloadProtected) {
    /** False */
    KnownIsWorkloadProtected["False"] = "False";
    /** True */
    KnownIsWorkloadProtected["True"] = "True";
})(exports.KnownIsWorkloadProtected || (exports.KnownIsWorkloadProtected = {}));
/** Known values of {@link PublicIPPrefixSkuName} that the service accepts. */
exports.KnownPublicIPPrefixSkuName = void 0;
(function (KnownPublicIPPrefixSkuName) {
    /** Standard */
    KnownPublicIPPrefixSkuName["Standard"] = "Standard";
})(exports.KnownPublicIPPrefixSkuName || (exports.KnownPublicIPPrefixSkuName = {}));
/** Known values of {@link PublicIPPrefixSkuTier} that the service accepts. */
exports.KnownPublicIPPrefixSkuTier = void 0;
(function (KnownPublicIPPrefixSkuTier) {
    /** Regional */
    KnownPublicIPPrefixSkuTier["Regional"] = "Regional";
    /** Global */
    KnownPublicIPPrefixSkuTier["Global"] = "Global";
})(exports.KnownPublicIPPrefixSkuTier || (exports.KnownPublicIPPrefixSkuTier = {}));
/** Known values of {@link RouteFilterRuleType} that the service accepts. */
exports.KnownRouteFilterRuleType = void 0;
(function (KnownRouteFilterRuleType) {
    /** Community */
    KnownRouteFilterRuleType["Community"] = "Community";
})(exports.KnownRouteFilterRuleType || (exports.KnownRouteFilterRuleType = {}));
/** Known values of {@link SecurityProviderName} that the service accepts. */
exports.KnownSecurityProviderName = void 0;
(function (KnownSecurityProviderName) {
    /** ZScaler */
    KnownSecurityProviderName["ZScaler"] = "ZScaler";
    /** IBoss */
    KnownSecurityProviderName["IBoss"] = "IBoss";
    /** Checkpoint */
    KnownSecurityProviderName["Checkpoint"] = "Checkpoint";
})(exports.KnownSecurityProviderName || (exports.KnownSecurityProviderName = {}));
/** Known values of {@link SecurityPartnerProviderConnectionStatus} that the service accepts. */
exports.KnownSecurityPartnerProviderConnectionStatus = void 0;
(function (KnownSecurityPartnerProviderConnectionStatus) {
    /** Unknown */
    KnownSecurityPartnerProviderConnectionStatus["Unknown"] = "Unknown";
    /** PartiallyConnected */
    KnownSecurityPartnerProviderConnectionStatus["PartiallyConnected"] = "PartiallyConnected";
    /** Connected */
    KnownSecurityPartnerProviderConnectionStatus["Connected"] = "Connected";
    /** NotConnected */
    KnownSecurityPartnerProviderConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownSecurityPartnerProviderConnectionStatus || (exports.KnownSecurityPartnerProviderConnectionStatus = {}));
/** Known values of {@link UsageUnit} that the service accepts. */
exports.KnownUsageUnit = void 0;
(function (KnownUsageUnit) {
    /** Count */
    KnownUsageUnit["Count"] = "Count";
})(exports.KnownUsageUnit || (exports.KnownUsageUnit = {}));
/** Known values of {@link VirtualNetworkEncryptionEnforcement} that the service accepts. */
exports.KnownVirtualNetworkEncryptionEnforcement = void 0;
(function (KnownVirtualNetworkEncryptionEnforcement) {
    /** DropUnencrypted */
    KnownVirtualNetworkEncryptionEnforcement["DropUnencrypted"] = "DropUnencrypted";
    /** AllowUnencrypted */
    KnownVirtualNetworkEncryptionEnforcement["AllowUnencrypted"] = "AllowUnencrypted";
})(exports.KnownVirtualNetworkEncryptionEnforcement || (exports.KnownVirtualNetworkEncryptionEnforcement = {}));
/** Known values of {@link VirtualNetworkPeeringState} that the service accepts. */
exports.KnownVirtualNetworkPeeringState = void 0;
(function (KnownVirtualNetworkPeeringState) {
    /** Initiated */
    KnownVirtualNetworkPeeringState["Initiated"] = "Initiated";
    /** Connected */
    KnownVirtualNetworkPeeringState["Connected"] = "Connected";
    /** Disconnected */
    KnownVirtualNetworkPeeringState["Disconnected"] = "Disconnected";
})(exports.KnownVirtualNetworkPeeringState || (exports.KnownVirtualNetworkPeeringState = {}));
/** Known values of {@link VirtualNetworkPeeringLevel} that the service accepts. */
exports.KnownVirtualNetworkPeeringLevel = void 0;
(function (KnownVirtualNetworkPeeringLevel) {
    /** FullyInSync */
    KnownVirtualNetworkPeeringLevel["FullyInSync"] = "FullyInSync";
    /** RemoteNotInSync */
    KnownVirtualNetworkPeeringLevel["RemoteNotInSync"] = "RemoteNotInSync";
    /** LocalNotInSync */
    KnownVirtualNetworkPeeringLevel["LocalNotInSync"] = "LocalNotInSync";
    /** LocalAndRemoteNotInSync */
    KnownVirtualNetworkPeeringLevel["LocalAndRemoteNotInSync"] = "LocalAndRemoteNotInSync";
})(exports.KnownVirtualNetworkPeeringLevel || (exports.KnownVirtualNetworkPeeringLevel = {}));
/** Known values of {@link SyncRemoteAddressSpace} that the service accepts. */
exports.KnownSyncRemoteAddressSpace = void 0;
(function (KnownSyncRemoteAddressSpace) {
    /** True */
    KnownSyncRemoteAddressSpace["True"] = "true";
})(exports.KnownSyncRemoteAddressSpace || (exports.KnownSyncRemoteAddressSpace = {}));
/** Known values of {@link VirtualNetworkGatewayType} that the service accepts. */
exports.KnownVirtualNetworkGatewayType = void 0;
(function (KnownVirtualNetworkGatewayType) {
    /** Vpn */
    KnownVirtualNetworkGatewayType["Vpn"] = "Vpn";
    /** ExpressRoute */
    KnownVirtualNetworkGatewayType["ExpressRoute"] = "ExpressRoute";
    /** LocalGateway */
    KnownVirtualNetworkGatewayType["LocalGateway"] = "LocalGateway";
})(exports.KnownVirtualNetworkGatewayType || (exports.KnownVirtualNetworkGatewayType = {}));
/** Known values of {@link VpnType} that the service accepts. */
exports.KnownVpnType = void 0;
(function (KnownVpnType) {
    /** PolicyBased */
    KnownVpnType["PolicyBased"] = "PolicyBased";
    /** RouteBased */
    KnownVpnType["RouteBased"] = "RouteBased";
})(exports.KnownVpnType || (exports.KnownVpnType = {}));
/** Known values of {@link VpnGatewayGeneration} that the service accepts. */
exports.KnownVpnGatewayGeneration = void 0;
(function (KnownVpnGatewayGeneration) {
    /** None */
    KnownVpnGatewayGeneration["None"] = "None";
    /** Generation1 */
    KnownVpnGatewayGeneration["Generation1"] = "Generation1";
    /** Generation2 */
    KnownVpnGatewayGeneration["Generation2"] = "Generation2";
})(exports.KnownVpnGatewayGeneration || (exports.KnownVpnGatewayGeneration = {}));
/** Known values of {@link VirtualNetworkGatewaySkuName} that the service accepts. */
exports.KnownVirtualNetworkGatewaySkuName = void 0;
(function (KnownVirtualNetworkGatewaySkuName) {
    /** Basic */
    KnownVirtualNetworkGatewaySkuName["Basic"] = "Basic";
    /** HighPerformance */
    KnownVirtualNetworkGatewaySkuName["HighPerformance"] = "HighPerformance";
    /** Standard */
    KnownVirtualNetworkGatewaySkuName["Standard"] = "Standard";
    /** UltraPerformance */
    KnownVirtualNetworkGatewaySkuName["UltraPerformance"] = "UltraPerformance";
    /** VpnGw1 */
    KnownVirtualNetworkGatewaySkuName["VpnGw1"] = "VpnGw1";
    /** VpnGw2 */
    KnownVirtualNetworkGatewaySkuName["VpnGw2"] = "VpnGw2";
    /** VpnGw3 */
    KnownVirtualNetworkGatewaySkuName["VpnGw3"] = "VpnGw3";
    /** VpnGw4 */
    KnownVirtualNetworkGatewaySkuName["VpnGw4"] = "VpnGw4";
    /** VpnGw5 */
    KnownVirtualNetworkGatewaySkuName["VpnGw5"] = "VpnGw5";
    /** VpnGw1AZ */
    KnownVirtualNetworkGatewaySkuName["VpnGw1AZ"] = "VpnGw1AZ";
    /** VpnGw2AZ */
    KnownVirtualNetworkGatewaySkuName["VpnGw2AZ"] = "VpnGw2AZ";
    /** VpnGw3AZ */
    KnownVirtualNetworkGatewaySkuName["VpnGw3AZ"] = "VpnGw3AZ";
    /** VpnGw4AZ */
    KnownVirtualNetworkGatewaySkuName["VpnGw4AZ"] = "VpnGw4AZ";
    /** VpnGw5AZ */
    KnownVirtualNetworkGatewaySkuName["VpnGw5AZ"] = "VpnGw5AZ";
    /** ErGw1AZ */
    KnownVirtualNetworkGatewaySkuName["ErGw1AZ"] = "ErGw1AZ";
    /** ErGw2AZ */
    KnownVirtualNetworkGatewaySkuName["ErGw2AZ"] = "ErGw2AZ";
    /** ErGw3AZ */
    KnownVirtualNetworkGatewaySkuName["ErGw3AZ"] = "ErGw3AZ";
})(exports.KnownVirtualNetworkGatewaySkuName || (exports.KnownVirtualNetworkGatewaySkuName = {}));
/** Known values of {@link VirtualNetworkGatewaySkuTier} that the service accepts. */
exports.KnownVirtualNetworkGatewaySkuTier = void 0;
(function (KnownVirtualNetworkGatewaySkuTier) {
    /** Basic */
    KnownVirtualNetworkGatewaySkuTier["Basic"] = "Basic";
    /** HighPerformance */
    KnownVirtualNetworkGatewaySkuTier["HighPerformance"] = "HighPerformance";
    /** Standard */
    KnownVirtualNetworkGatewaySkuTier["Standard"] = "Standard";
    /** UltraPerformance */
    KnownVirtualNetworkGatewaySkuTier["UltraPerformance"] = "UltraPerformance";
    /** VpnGw1 */
    KnownVirtualNetworkGatewaySkuTier["VpnGw1"] = "VpnGw1";
    /** VpnGw2 */
    KnownVirtualNetworkGatewaySkuTier["VpnGw2"] = "VpnGw2";
    /** VpnGw3 */
    KnownVirtualNetworkGatewaySkuTier["VpnGw3"] = "VpnGw3";
    /** VpnGw4 */
    KnownVirtualNetworkGatewaySkuTier["VpnGw4"] = "VpnGw4";
    /** VpnGw5 */
    KnownVirtualNetworkGatewaySkuTier["VpnGw5"] = "VpnGw5";
    /** VpnGw1AZ */
    KnownVirtualNetworkGatewaySkuTier["VpnGw1AZ"] = "VpnGw1AZ";
    /** VpnGw2AZ */
    KnownVirtualNetworkGatewaySkuTier["VpnGw2AZ"] = "VpnGw2AZ";
    /** VpnGw3AZ */
    KnownVirtualNetworkGatewaySkuTier["VpnGw3AZ"] = "VpnGw3AZ";
    /** VpnGw4AZ */
    KnownVirtualNetworkGatewaySkuTier["VpnGw4AZ"] = "VpnGw4AZ";
    /** VpnGw5AZ */
    KnownVirtualNetworkGatewaySkuTier["VpnGw5AZ"] = "VpnGw5AZ";
    /** ErGw1AZ */
    KnownVirtualNetworkGatewaySkuTier["ErGw1AZ"] = "ErGw1AZ";
    /** ErGw2AZ */
    KnownVirtualNetworkGatewaySkuTier["ErGw2AZ"] = "ErGw2AZ";
    /** ErGw3AZ */
    KnownVirtualNetworkGatewaySkuTier["ErGw3AZ"] = "ErGw3AZ";
})(exports.KnownVirtualNetworkGatewaySkuTier || (exports.KnownVirtualNetworkGatewaySkuTier = {}));
/** Known values of {@link VpnClientProtocol} that the service accepts. */
exports.KnownVpnClientProtocol = void 0;
(function (KnownVpnClientProtocol) {
    /** IkeV2 */
    KnownVpnClientProtocol["IkeV2"] = "IkeV2";
    /** Sstp */
    KnownVpnClientProtocol["Sstp"] = "SSTP";
    /** OpenVPN */
    KnownVpnClientProtocol["OpenVPN"] = "OpenVPN";
})(exports.KnownVpnClientProtocol || (exports.KnownVpnClientProtocol = {}));
/** Known values of {@link VpnAuthenticationType} that the service accepts. */
exports.KnownVpnAuthenticationType = void 0;
(function (KnownVpnAuthenticationType) {
    /** Certificate */
    KnownVpnAuthenticationType["Certificate"] = "Certificate";
    /** Radius */
    KnownVpnAuthenticationType["Radius"] = "Radius";
    /** AAD */
    KnownVpnAuthenticationType["AAD"] = "AAD";
})(exports.KnownVpnAuthenticationType || (exports.KnownVpnAuthenticationType = {}));
/** Known values of {@link IpsecEncryption} that the service accepts. */
exports.KnownIpsecEncryption = void 0;
(function (KnownIpsecEncryption) {
    /** None */
    KnownIpsecEncryption["None"] = "None";
    /** DES */
    KnownIpsecEncryption["DES"] = "DES";
    /** DES3 */
    KnownIpsecEncryption["DES3"] = "DES3";
    /** AES128 */
    KnownIpsecEncryption["AES128"] = "AES128";
    /** AES192 */
    KnownIpsecEncryption["AES192"] = "AES192";
    /** AES256 */
    KnownIpsecEncryption["AES256"] = "AES256";
    /** Gcmaes128 */
    KnownIpsecEncryption["Gcmaes128"] = "GCMAES128";
    /** Gcmaes192 */
    KnownIpsecEncryption["Gcmaes192"] = "GCMAES192";
    /** Gcmaes256 */
    KnownIpsecEncryption["Gcmaes256"] = "GCMAES256";
})(exports.KnownIpsecEncryption || (exports.KnownIpsecEncryption = {}));
/** Known values of {@link IpsecIntegrity} that the service accepts. */
exports.KnownIpsecIntegrity = void 0;
(function (KnownIpsecIntegrity) {
    /** MD5 */
    KnownIpsecIntegrity["MD5"] = "MD5";
    /** SHA1 */
    KnownIpsecIntegrity["SHA1"] = "SHA1";
    /** SHA256 */
    KnownIpsecIntegrity["SHA256"] = "SHA256";
    /** Gcmaes128 */
    KnownIpsecIntegrity["Gcmaes128"] = "GCMAES128";
    /** Gcmaes192 */
    KnownIpsecIntegrity["Gcmaes192"] = "GCMAES192";
    /** Gcmaes256 */
    KnownIpsecIntegrity["Gcmaes256"] = "GCMAES256";
})(exports.KnownIpsecIntegrity || (exports.KnownIpsecIntegrity = {}));
/** Known values of {@link IkeEncryption} that the service accepts. */
exports.KnownIkeEncryption = void 0;
(function (KnownIkeEncryption) {
    /** DES */
    KnownIkeEncryption["DES"] = "DES";
    /** DES3 */
    KnownIkeEncryption["DES3"] = "DES3";
    /** AES128 */
    KnownIkeEncryption["AES128"] = "AES128";
    /** AES192 */
    KnownIkeEncryption["AES192"] = "AES192";
    /** AES256 */
    KnownIkeEncryption["AES256"] = "AES256";
    /** Gcmaes256 */
    KnownIkeEncryption["Gcmaes256"] = "GCMAES256";
    /** Gcmaes128 */
    KnownIkeEncryption["Gcmaes128"] = "GCMAES128";
})(exports.KnownIkeEncryption || (exports.KnownIkeEncryption = {}));
/** Known values of {@link IkeIntegrity} that the service accepts. */
exports.KnownIkeIntegrity = void 0;
(function (KnownIkeIntegrity) {
    /** MD5 */
    KnownIkeIntegrity["MD5"] = "MD5";
    /** SHA1 */
    KnownIkeIntegrity["SHA1"] = "SHA1";
    /** SHA256 */
    KnownIkeIntegrity["SHA256"] = "SHA256";
    /** SHA384 */
    KnownIkeIntegrity["SHA384"] = "SHA384";
    /** Gcmaes256 */
    KnownIkeIntegrity["Gcmaes256"] = "GCMAES256";
    /** Gcmaes128 */
    KnownIkeIntegrity["Gcmaes128"] = "GCMAES128";
})(exports.KnownIkeIntegrity || (exports.KnownIkeIntegrity = {}));
/** Known values of {@link DhGroup} that the service accepts. */
exports.KnownDhGroup = void 0;
(function (KnownDhGroup) {
    /** None */
    KnownDhGroup["None"] = "None";
    /** DHGroup1 */
    KnownDhGroup["DHGroup1"] = "DHGroup1";
    /** DHGroup2 */
    KnownDhGroup["DHGroup2"] = "DHGroup2";
    /** DHGroup14 */
    KnownDhGroup["DHGroup14"] = "DHGroup14";
    /** DHGroup2048 */
    KnownDhGroup["DHGroup2048"] = "DHGroup2048";
    /** ECP256 */
    KnownDhGroup["ECP256"] = "ECP256";
    /** ECP384 */
    KnownDhGroup["ECP384"] = "ECP384";
    /** DHGroup24 */
    KnownDhGroup["DHGroup24"] = "DHGroup24";
})(exports.KnownDhGroup || (exports.KnownDhGroup = {}));
/** Known values of {@link PfsGroup} that the service accepts. */
exports.KnownPfsGroup = void 0;
(function (KnownPfsGroup) {
    /** None */
    KnownPfsGroup["None"] = "None";
    /** PFS1 */
    KnownPfsGroup["PFS1"] = "PFS1";
    /** PFS2 */
    KnownPfsGroup["PFS2"] = "PFS2";
    /** PFS2048 */
    KnownPfsGroup["PFS2048"] = "PFS2048";
    /** ECP256 */
    KnownPfsGroup["ECP256"] = "ECP256";
    /** ECP384 */
    KnownPfsGroup["ECP384"] = "ECP384";
    /** PFS24 */
    KnownPfsGroup["PFS24"] = "PFS24";
    /** PFS14 */
    KnownPfsGroup["PFS14"] = "PFS14";
    /** Pfsmm */
    KnownPfsGroup["Pfsmm"] = "PFSMM";
})(exports.KnownPfsGroup || (exports.KnownPfsGroup = {}));
/** Known values of {@link VpnPolicyMemberAttributeType} that the service accepts. */
exports.KnownVpnPolicyMemberAttributeType = void 0;
(function (KnownVpnPolicyMemberAttributeType) {
    /** CertificateGroupId */
    KnownVpnPolicyMemberAttributeType["CertificateGroupId"] = "CertificateGroupId";
    /** AADGroupId */
    KnownVpnPolicyMemberAttributeType["AADGroupId"] = "AADGroupId";
    /** RadiusAzureGroupId */
    KnownVpnPolicyMemberAttributeType["RadiusAzureGroupId"] = "RadiusAzureGroupId";
})(exports.KnownVpnPolicyMemberAttributeType || (exports.KnownVpnPolicyMemberAttributeType = {}));
/** Known values of {@link VpnNatRuleType} that the service accepts. */
exports.KnownVpnNatRuleType = void 0;
(function (KnownVpnNatRuleType) {
    /** Static */
    KnownVpnNatRuleType["Static"] = "Static";
    /** Dynamic */
    KnownVpnNatRuleType["Dynamic"] = "Dynamic";
})(exports.KnownVpnNatRuleType || (exports.KnownVpnNatRuleType = {}));
/** Known values of {@link VpnNatRuleMode} that the service accepts. */
exports.KnownVpnNatRuleMode = void 0;
(function (KnownVpnNatRuleMode) {
    /** EgressSnat */
    KnownVpnNatRuleMode["EgressSnat"] = "EgressSnat";
    /** IngressSnat */
    KnownVpnNatRuleMode["IngressSnat"] = "IngressSnat";
})(exports.KnownVpnNatRuleMode || (exports.KnownVpnNatRuleMode = {}));
/** Known values of {@link VirtualNetworkGatewayConnectionType} that the service accepts. */
exports.KnownVirtualNetworkGatewayConnectionType = void 0;
(function (KnownVirtualNetworkGatewayConnectionType) {
    /** IPsec */
    KnownVirtualNetworkGatewayConnectionType["IPsec"] = "IPsec";
    /** Vnet2Vnet */
    KnownVirtualNetworkGatewayConnectionType["Vnet2Vnet"] = "Vnet2Vnet";
    /** ExpressRoute */
    KnownVirtualNetworkGatewayConnectionType["ExpressRoute"] = "ExpressRoute";
    /** VPNClient */
    KnownVirtualNetworkGatewayConnectionType["VPNClient"] = "VPNClient";
})(exports.KnownVirtualNetworkGatewayConnectionType || (exports.KnownVirtualNetworkGatewayConnectionType = {}));
/** Known values of {@link VirtualNetworkGatewayConnectionProtocol} that the service accepts. */
exports.KnownVirtualNetworkGatewayConnectionProtocol = void 0;
(function (KnownVirtualNetworkGatewayConnectionProtocol) {
    /** IKEv2 */
    KnownVirtualNetworkGatewayConnectionProtocol["IKEv2"] = "IKEv2";
    /** IKEv1 */
    KnownVirtualNetworkGatewayConnectionProtocol["IKEv1"] = "IKEv1";
})(exports.KnownVirtualNetworkGatewayConnectionProtocol || (exports.KnownVirtualNetworkGatewayConnectionProtocol = {}));
/** Known values of {@link VirtualNetworkGatewayConnectionMode} that the service accepts. */
exports.KnownVirtualNetworkGatewayConnectionMode = void 0;
(function (KnownVirtualNetworkGatewayConnectionMode) {
    /** Default */
    KnownVirtualNetworkGatewayConnectionMode["Default"] = "Default";
    /** ResponderOnly */
    KnownVirtualNetworkGatewayConnectionMode["ResponderOnly"] = "ResponderOnly";
    /** InitiatorOnly */
    KnownVirtualNetworkGatewayConnectionMode["InitiatorOnly"] = "InitiatorOnly";
})(exports.KnownVirtualNetworkGatewayConnectionMode || (exports.KnownVirtualNetworkGatewayConnectionMode = {}));
/** Known values of {@link VirtualNetworkGatewayConnectionStatus} that the service accepts. */
exports.KnownVirtualNetworkGatewayConnectionStatus = void 0;
(function (KnownVirtualNetworkGatewayConnectionStatus) {
    /** Unknown */
    KnownVirtualNetworkGatewayConnectionStatus["Unknown"] = "Unknown";
    /** Connecting */
    KnownVirtualNetworkGatewayConnectionStatus["Connecting"] = "Connecting";
    /** Connected */
    KnownVirtualNetworkGatewayConnectionStatus["Connected"] = "Connected";
    /** NotConnected */
    KnownVirtualNetworkGatewayConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownVirtualNetworkGatewayConnectionStatus || (exports.KnownVirtualNetworkGatewayConnectionStatus = {}));
/** Known values of {@link ProcessorArchitecture} that the service accepts. */
exports.KnownProcessorArchitecture = void 0;
(function (KnownProcessorArchitecture) {
    /** Amd64 */
    KnownProcessorArchitecture["Amd64"] = "Amd64";
    /** X86 */
    KnownProcessorArchitecture["X86"] = "X86";
})(exports.KnownProcessorArchitecture || (exports.KnownProcessorArchitecture = {}));
/** Known values of {@link AuthenticationMethod} that the service accepts. */
exports.KnownAuthenticationMethod = void 0;
(function (KnownAuthenticationMethod) {
    /** Eaptls */
    KnownAuthenticationMethod["Eaptls"] = "EAPTLS";
    /** EapmschaPv2 */
    KnownAuthenticationMethod["EapmschaPv2"] = "EAPMSCHAPv2";
})(exports.KnownAuthenticationMethod || (exports.KnownAuthenticationMethod = {}));
/** Known values of {@link BgpPeerState} that the service accepts. */
exports.KnownBgpPeerState = void 0;
(function (KnownBgpPeerState) {
    /** Unknown */
    KnownBgpPeerState["Unknown"] = "Unknown";
    /** Stopped */
    KnownBgpPeerState["Stopped"] = "Stopped";
    /** Idle */
    KnownBgpPeerState["Idle"] = "Idle";
    /** Connecting */
    KnownBgpPeerState["Connecting"] = "Connecting";
    /** Connected */
    KnownBgpPeerState["Connected"] = "Connected";
})(exports.KnownBgpPeerState || (exports.KnownBgpPeerState = {}));
/** Known values of {@link OfficeTrafficCategory} that the service accepts. */
exports.KnownOfficeTrafficCategory = void 0;
(function (KnownOfficeTrafficCategory) {
    /** Optimize */
    KnownOfficeTrafficCategory["Optimize"] = "Optimize";
    /** OptimizeAndAllow */
    KnownOfficeTrafficCategory["OptimizeAndAllow"] = "OptimizeAndAllow";
    /** All */
    KnownOfficeTrafficCategory["All"] = "All";
    /** None */
    KnownOfficeTrafficCategory["None"] = "None";
})(exports.KnownOfficeTrafficCategory || (exports.KnownOfficeTrafficCategory = {}));
/** Known values of {@link VirtualWanSecurityProviderType} that the service accepts. */
exports.KnownVirtualWanSecurityProviderType = void 0;
(function (KnownVirtualWanSecurityProviderType) {
    /** External */
    KnownVirtualWanSecurityProviderType["External"] = "External";
    /** Native */
    KnownVirtualWanSecurityProviderType["Native"] = "Native";
})(exports.KnownVirtualWanSecurityProviderType || (exports.KnownVirtualWanSecurityProviderType = {}));
/** Known values of {@link VpnGatewayTunnelingProtocol} that the service accepts. */
exports.KnownVpnGatewayTunnelingProtocol = void 0;
(function (KnownVpnGatewayTunnelingProtocol) {
    /** IkeV2 */
    KnownVpnGatewayTunnelingProtocol["IkeV2"] = "IkeV2";
    /** OpenVPN */
    KnownVpnGatewayTunnelingProtocol["OpenVPN"] = "OpenVPN";
})(exports.KnownVpnGatewayTunnelingProtocol || (exports.KnownVpnGatewayTunnelingProtocol = {}));
/** Known values of {@link VnetLocalRouteOverrideCriteria} that the service accepts. */
exports.KnownVnetLocalRouteOverrideCriteria = void 0;
(function (KnownVnetLocalRouteOverrideCriteria) {
    /** Contains */
    KnownVnetLocalRouteOverrideCriteria["Contains"] = "Contains";
    /** Equal */
    KnownVnetLocalRouteOverrideCriteria["Equal"] = "Equal";
})(exports.KnownVnetLocalRouteOverrideCriteria || (exports.KnownVnetLocalRouteOverrideCriteria = {}));
/** Known values of {@link RoutingState} that the service accepts. */
exports.KnownRoutingState = void 0;
(function (KnownRoutingState) {
    /** None */
    KnownRoutingState["None"] = "None";
    /** Provisioned */
    KnownRoutingState["Provisioned"] = "Provisioned";
    /** Provisioning */
    KnownRoutingState["Provisioning"] = "Provisioning";
    /** Failed */
    KnownRoutingState["Failed"] = "Failed";
})(exports.KnownRoutingState || (exports.KnownRoutingState = {}));
/** Known values of {@link PreferredRoutingGateway} that the service accepts. */
exports.KnownPreferredRoutingGateway = void 0;
(function (KnownPreferredRoutingGateway) {
    /** ExpressRoute */
    KnownPreferredRoutingGateway["ExpressRoute"] = "ExpressRoute";
    /** VpnGateway */
    KnownPreferredRoutingGateway["VpnGateway"] = "VpnGateway";
    /** None */
    KnownPreferredRoutingGateway["None"] = "None";
})(exports.KnownPreferredRoutingGateway || (exports.KnownPreferredRoutingGateway = {}));
/** Known values of {@link HubRoutingPreference} that the service accepts. */
exports.KnownHubRoutingPreference = void 0;
(function (KnownHubRoutingPreference) {
    /** ExpressRoute */
    KnownHubRoutingPreference["ExpressRoute"] = "ExpressRoute";
    /** VpnGateway */
    KnownHubRoutingPreference["VpnGateway"] = "VpnGateway";
    /** ASPath */
    KnownHubRoutingPreference["ASPath"] = "ASPath";
})(exports.KnownHubRoutingPreference || (exports.KnownHubRoutingPreference = {}));
/** Known values of {@link RouteMapMatchCondition} that the service accepts. */
exports.KnownRouteMapMatchCondition = void 0;
(function (KnownRouteMapMatchCondition) {
    /** Unknown */
    KnownRouteMapMatchCondition["Unknown"] = "Unknown";
    /** Contains */
    KnownRouteMapMatchCondition["Contains"] = "Contains";
    /** Equals */
    KnownRouteMapMatchCondition["Equals"] = "Equals";
    /** NotContains */
    KnownRouteMapMatchCondition["NotContains"] = "NotContains";
    /** NotEquals */
    KnownRouteMapMatchCondition["NotEquals"] = "NotEquals";
})(exports.KnownRouteMapMatchCondition || (exports.KnownRouteMapMatchCondition = {}));
/** Known values of {@link RouteMapActionType} that the service accepts. */
exports.KnownRouteMapActionType = void 0;
(function (KnownRouteMapActionType) {
    /** Unknown */
    KnownRouteMapActionType["Unknown"] = "Unknown";
    /** Remove */
    KnownRouteMapActionType["Remove"] = "Remove";
    /** Add */
    KnownRouteMapActionType["Add"] = "Add";
    /** Replace */
    KnownRouteMapActionType["Replace"] = "Replace";
    /** Drop */
    KnownRouteMapActionType["Drop"] = "Drop";
})(exports.KnownRouteMapActionType || (exports.KnownRouteMapActionType = {}));
/** Known values of {@link NextStep} that the service accepts. */
exports.KnownNextStep = void 0;
(function (KnownNextStep) {
    /** Unknown */
    KnownNextStep["Unknown"] = "Unknown";
    /** Continue */
    KnownNextStep["Continue"] = "Continue";
    /** Terminate */
    KnownNextStep["Terminate"] = "Terminate";
})(exports.KnownNextStep || (exports.KnownNextStep = {}));
/** Known values of {@link VpnConnectionStatus} that the service accepts. */
exports.KnownVpnConnectionStatus = void 0;
(function (KnownVpnConnectionStatus) {
    /** Unknown */
    KnownVpnConnectionStatus["Unknown"] = "Unknown";
    /** Connecting */
    KnownVpnConnectionStatus["Connecting"] = "Connecting";
    /** Connected */
    KnownVpnConnectionStatus["Connected"] = "Connected";
    /** NotConnected */
    KnownVpnConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownVpnConnectionStatus || (exports.KnownVpnConnectionStatus = {}));
/** Known values of {@link VpnLinkConnectionMode} that the service accepts. */
exports.KnownVpnLinkConnectionMode = void 0;
(function (KnownVpnLinkConnectionMode) {
    /** Default */
    KnownVpnLinkConnectionMode["Default"] = "Default";
    /** ResponderOnly */
    KnownVpnLinkConnectionMode["ResponderOnly"] = "ResponderOnly";
    /** InitiatorOnly */
    KnownVpnLinkConnectionMode["InitiatorOnly"] = "InitiatorOnly";
})(exports.KnownVpnLinkConnectionMode || (exports.KnownVpnLinkConnectionMode = {}));
/** Known values of {@link HubBgpConnectionStatus} that the service accepts. */
exports.KnownHubBgpConnectionStatus = void 0;
(function (KnownHubBgpConnectionStatus) {
    /** Unknown */
    KnownHubBgpConnectionStatus["Unknown"] = "Unknown";
    /** Connecting */
    KnownHubBgpConnectionStatus["Connecting"] = "Connecting";
    /** Connected */
    KnownHubBgpConnectionStatus["Connected"] = "Connected";
    /** NotConnected */
    KnownHubBgpConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownHubBgpConnectionStatus || (exports.KnownHubBgpConnectionStatus = {}));
/** Known values of {@link WebApplicationFirewallEnabledState} that the service accepts. */
exports.KnownWebApplicationFirewallEnabledState = void 0;
(function (KnownWebApplicationFirewallEnabledState) {
    /** Disabled */
    KnownWebApplicationFirewallEnabledState["Disabled"] = "Disabled";
    /** Enabled */
    KnownWebApplicationFirewallEnabledState["Enabled"] = "Enabled";
})(exports.KnownWebApplicationFirewallEnabledState || (exports.KnownWebApplicationFirewallEnabledState = {}));
/** Known values of {@link WebApplicationFirewallMode} that the service accepts. */
exports.KnownWebApplicationFirewallMode = void 0;
(function (KnownWebApplicationFirewallMode) {
    /** Prevention */
    KnownWebApplicationFirewallMode["Prevention"] = "Prevention";
    /** Detection */
    KnownWebApplicationFirewallMode["Detection"] = "Detection";
})(exports.KnownWebApplicationFirewallMode || (exports.KnownWebApplicationFirewallMode = {}));
/** Known values of {@link WebApplicationFirewallState} that the service accepts. */
exports.KnownWebApplicationFirewallState = void 0;
(function (KnownWebApplicationFirewallState) {
    /** Disabled */
    KnownWebApplicationFirewallState["Disabled"] = "Disabled";
    /** Enabled */
    KnownWebApplicationFirewallState["Enabled"] = "Enabled";
})(exports.KnownWebApplicationFirewallState || (exports.KnownWebApplicationFirewallState = {}));
/** Known values of {@link WebApplicationFirewallRuleType} that the service accepts. */
exports.KnownWebApplicationFirewallRuleType = void 0;
(function (KnownWebApplicationFirewallRuleType) {
    /** MatchRule */
    KnownWebApplicationFirewallRuleType["MatchRule"] = "MatchRule";
    /** Invalid */
    KnownWebApplicationFirewallRuleType["Invalid"] = "Invalid";
})(exports.KnownWebApplicationFirewallRuleType || (exports.KnownWebApplicationFirewallRuleType = {}));
/** Known values of {@link WebApplicationFirewallMatchVariable} that the service accepts. */
exports.KnownWebApplicationFirewallMatchVariable = void 0;
(function (KnownWebApplicationFirewallMatchVariable) {
    /** RemoteAddr */
    KnownWebApplicationFirewallMatchVariable["RemoteAddr"] = "RemoteAddr";
    /** RequestMethod */
    KnownWebApplicationFirewallMatchVariable["RequestMethod"] = "RequestMethod";
    /** QueryString */
    KnownWebApplicationFirewallMatchVariable["QueryString"] = "QueryString";
    /** PostArgs */
    KnownWebApplicationFirewallMatchVariable["PostArgs"] = "PostArgs";
    /** RequestUri */
    KnownWebApplicationFirewallMatchVariable["RequestUri"] = "RequestUri";
    /** RequestHeaders */
    KnownWebApplicationFirewallMatchVariable["RequestHeaders"] = "RequestHeaders";
    /** RequestBody */
    KnownWebApplicationFirewallMatchVariable["RequestBody"] = "RequestBody";
    /** RequestCookies */
    KnownWebApplicationFirewallMatchVariable["RequestCookies"] = "RequestCookies";
})(exports.KnownWebApplicationFirewallMatchVariable || (exports.KnownWebApplicationFirewallMatchVariable = {}));
/** Known values of {@link WebApplicationFirewallOperator} that the service accepts. */
exports.KnownWebApplicationFirewallOperator = void 0;
(function (KnownWebApplicationFirewallOperator) {
    /** IPMatch */
    KnownWebApplicationFirewallOperator["IPMatch"] = "IPMatch";
    /** Equal */
    KnownWebApplicationFirewallOperator["Equal"] = "Equal";
    /** Contains */
    KnownWebApplicationFirewallOperator["Contains"] = "Contains";
    /** LessThan */
    KnownWebApplicationFirewallOperator["LessThan"] = "LessThan";
    /** GreaterThan */
    KnownWebApplicationFirewallOperator["GreaterThan"] = "GreaterThan";
    /** LessThanOrEqual */
    KnownWebApplicationFirewallOperator["LessThanOrEqual"] = "LessThanOrEqual";
    /** GreaterThanOrEqual */
    KnownWebApplicationFirewallOperator["GreaterThanOrEqual"] = "GreaterThanOrEqual";
    /** BeginsWith */
    KnownWebApplicationFirewallOperator["BeginsWith"] = "BeginsWith";
    /** EndsWith */
    KnownWebApplicationFirewallOperator["EndsWith"] = "EndsWith";
    /** Regex */
    KnownWebApplicationFirewallOperator["Regex"] = "Regex";
    /** GeoMatch */
    KnownWebApplicationFirewallOperator["GeoMatch"] = "GeoMatch";
    /** Any */
    KnownWebApplicationFirewallOperator["Any"] = "Any";
})(exports.KnownWebApplicationFirewallOperator || (exports.KnownWebApplicationFirewallOperator = {}));
/** Known values of {@link WebApplicationFirewallTransform} that the service accepts. */
exports.KnownWebApplicationFirewallTransform = void 0;
(function (KnownWebApplicationFirewallTransform) {
    /** Uppercase */
    KnownWebApplicationFirewallTransform["Uppercase"] = "Uppercase";
    /** Lowercase */
    KnownWebApplicationFirewallTransform["Lowercase"] = "Lowercase";
    /** Trim */
    KnownWebApplicationFirewallTransform["Trim"] = "Trim";
    /** UrlDecode */
    KnownWebApplicationFirewallTransform["UrlDecode"] = "UrlDecode";
    /** UrlEncode */
    KnownWebApplicationFirewallTransform["UrlEncode"] = "UrlEncode";
    /** RemoveNulls */
    KnownWebApplicationFirewallTransform["RemoveNulls"] = "RemoveNulls";
    /** HtmlEntityDecode */
    KnownWebApplicationFirewallTransform["HtmlEntityDecode"] = "HtmlEntityDecode";
})(exports.KnownWebApplicationFirewallTransform || (exports.KnownWebApplicationFirewallTransform = {}));
/** Known values of {@link WebApplicationFirewallAction} that the service accepts. */
exports.KnownWebApplicationFirewallAction = void 0;
(function (KnownWebApplicationFirewallAction) {
    /** Allow */
    KnownWebApplicationFirewallAction["Allow"] = "Allow";
    /** Block */
    KnownWebApplicationFirewallAction["Block"] = "Block";
    /** Log */
    KnownWebApplicationFirewallAction["Log"] = "Log";
})(exports.KnownWebApplicationFirewallAction || (exports.KnownWebApplicationFirewallAction = {}));
/** Known values of {@link WebApplicationFirewallPolicyResourceState} that the service accepts. */
exports.KnownWebApplicationFirewallPolicyResourceState = void 0;
(function (KnownWebApplicationFirewallPolicyResourceState) {
    /** Creating */
    KnownWebApplicationFirewallPolicyResourceState["Creating"] = "Creating";
    /** Enabling */
    KnownWebApplicationFirewallPolicyResourceState["Enabling"] = "Enabling";
    /** Enabled */
    KnownWebApplicationFirewallPolicyResourceState["Enabled"] = "Enabled";
    /** Disabling */
    KnownWebApplicationFirewallPolicyResourceState["Disabling"] = "Disabling";
    /** Disabled */
    KnownWebApplicationFirewallPolicyResourceState["Disabled"] = "Disabled";
    /** Deleting */
    KnownWebApplicationFirewallPolicyResourceState["Deleting"] = "Deleting";
})(exports.KnownWebApplicationFirewallPolicyResourceState || (exports.KnownWebApplicationFirewallPolicyResourceState = {}));
/** Known values of {@link OwaspCrsExclusionEntryMatchVariable} that the service accepts. */
exports.KnownOwaspCrsExclusionEntryMatchVariable = void 0;
(function (KnownOwaspCrsExclusionEntryMatchVariable) {
    /** RequestHeaderNames */
    KnownOwaspCrsExclusionEntryMatchVariable["RequestHeaderNames"] = "RequestHeaderNames";
    /** RequestCookieNames */
    KnownOwaspCrsExclusionEntryMatchVariable["RequestCookieNames"] = "RequestCookieNames";
    /** RequestArgNames */
    KnownOwaspCrsExclusionEntryMatchVariable["RequestArgNames"] = "RequestArgNames";
    /** RequestHeaderKeys */
    KnownOwaspCrsExclusionEntryMatchVariable["RequestHeaderKeys"] = "RequestHeaderKeys";
    /** RequestHeaderValues */
    KnownOwaspCrsExclusionEntryMatchVariable["RequestHeaderValues"] = "RequestHeaderValues";
    /** RequestCookieKeys */
    KnownOwaspCrsExclusionEntryMatchVariable["RequestCookieKeys"] = "RequestCookieKeys";
    /** RequestCookieValues */
    KnownOwaspCrsExclusionEntryMatchVariable["RequestCookieValues"] = "RequestCookieValues";
    /** RequestArgKeys */
    KnownOwaspCrsExclusionEntryMatchVariable["RequestArgKeys"] = "RequestArgKeys";
    /** RequestArgValues */
    KnownOwaspCrsExclusionEntryMatchVariable["RequestArgValues"] = "RequestArgValues";
})(exports.KnownOwaspCrsExclusionEntryMatchVariable || (exports.KnownOwaspCrsExclusionEntryMatchVariable = {}));
/** Known values of {@link OwaspCrsExclusionEntrySelectorMatchOperator} that the service accepts. */
exports.KnownOwaspCrsExclusionEntrySelectorMatchOperator = void 0;
(function (KnownOwaspCrsExclusionEntrySelectorMatchOperator) {
    /** Equals */
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["Equals"] = "Equals";
    /** Contains */
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["Contains"] = "Contains";
    /** StartsWith */
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["StartsWith"] = "StartsWith";
    /** EndsWith */
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["EndsWith"] = "EndsWith";
    /** EqualsAny */
    KnownOwaspCrsExclusionEntrySelectorMatchOperator["EqualsAny"] = "EqualsAny";
})(exports.KnownOwaspCrsExclusionEntrySelectorMatchOperator || (exports.KnownOwaspCrsExclusionEntrySelectorMatchOperator = {}));
/** Known values of {@link ManagedRuleEnabledState} that the service accepts. */
exports.KnownManagedRuleEnabledState = void 0;
(function (KnownManagedRuleEnabledState) {
    /** Disabled */
    KnownManagedRuleEnabledState["Disabled"] = "Disabled";
    /** Enabled */
    KnownManagedRuleEnabledState["Enabled"] = "Enabled";
})(exports.KnownManagedRuleEnabledState || (exports.KnownManagedRuleEnabledState = {}));
/** Known values of {@link ActionType} that the service accepts. */
exports.KnownActionType = void 0;
(function (KnownActionType) {
    /** AnomalyScoring */
    KnownActionType["AnomalyScoring"] = "AnomalyScoring";
    /** Allow */
    KnownActionType["Allow"] = "Allow";
    /** Block */
    KnownActionType["Block"] = "Block";
    /** Log */
    KnownActionType["Log"] = "Log";
})(exports.KnownActionType || (exports.KnownActionType = {}));
/** Known values of {@link FirewallPolicyNatRuleCollectionActionType} that the service accepts. */
exports.KnownFirewallPolicyNatRuleCollectionActionType = void 0;
(function (KnownFirewallPolicyNatRuleCollectionActionType) {
    /** Dnat */
    KnownFirewallPolicyNatRuleCollectionActionType["Dnat"] = "DNAT";
})(exports.KnownFirewallPolicyNatRuleCollectionActionType || (exports.KnownFirewallPolicyNatRuleCollectionActionType = {}));
/** Known values of {@link FirewallPolicyRuleType} that the service accepts. */
exports.KnownFirewallPolicyRuleType = void 0;
(function (KnownFirewallPolicyRuleType) {
    /** ApplicationRule */
    KnownFirewallPolicyRuleType["ApplicationRule"] = "ApplicationRule";
    /** NetworkRule */
    KnownFirewallPolicyRuleType["NetworkRule"] = "NetworkRule";
    /** NatRule */
    KnownFirewallPolicyRuleType["NatRule"] = "NatRule";
})(exports.KnownFirewallPolicyRuleType || (exports.KnownFirewallPolicyRuleType = {}));
/** Known values of {@link FirewallPolicyFilterRuleCollectionActionType} that the service accepts. */
exports.KnownFirewallPolicyFilterRuleCollectionActionType = void 0;
(function (KnownFirewallPolicyFilterRuleCollectionActionType) {
    /** Allow */
    KnownFirewallPolicyFilterRuleCollectionActionType["Allow"] = "Allow";
    /** Deny */
    KnownFirewallPolicyFilterRuleCollectionActionType["Deny"] = "Deny";
})(exports.KnownFirewallPolicyFilterRuleCollectionActionType || (exports.KnownFirewallPolicyFilterRuleCollectionActionType = {}));
/** Known values of {@link FirewallPolicyRuleApplicationProtocolType} that the service accepts. */
exports.KnownFirewallPolicyRuleApplicationProtocolType = void 0;
(function (KnownFirewallPolicyRuleApplicationProtocolType) {
    /** Http */
    KnownFirewallPolicyRuleApplicationProtocolType["Http"] = "Http";
    /** Https */
    KnownFirewallPolicyRuleApplicationProtocolType["Https"] = "Https";
})(exports.KnownFirewallPolicyRuleApplicationProtocolType || (exports.KnownFirewallPolicyRuleApplicationProtocolType = {}));
/** Known values of {@link FirewallPolicyRuleNetworkProtocol} that the service accepts. */
exports.KnownFirewallPolicyRuleNetworkProtocol = void 0;
(function (KnownFirewallPolicyRuleNetworkProtocol) {
    /** TCP */
    KnownFirewallPolicyRuleNetworkProtocol["TCP"] = "TCP";
    /** UDP */
    KnownFirewallPolicyRuleNetworkProtocol["UDP"] = "UDP";
    /** Any */
    KnownFirewallPolicyRuleNetworkProtocol["Any"] = "Any";
    /** Icmp */
    KnownFirewallPolicyRuleNetworkProtocol["Icmp"] = "ICMP";
})(exports.KnownFirewallPolicyRuleNetworkProtocol || (exports.KnownFirewallPolicyRuleNetworkProtocol = {}));
/** Known values of {@link NetworkOperationStatus} that the service accepts. */
exports.KnownNetworkOperationStatus = void 0;
(function (KnownNetworkOperationStatus) {
    /** InProgress */
    KnownNetworkOperationStatus["InProgress"] = "InProgress";
    /** Succeeded */
    KnownNetworkOperationStatus["Succeeded"] = "Succeeded";
    /** Failed */
    KnownNetworkOperationStatus["Failed"] = "Failed";
})(exports.KnownNetworkOperationStatus || (exports.KnownNetworkOperationStatus = {}));
/** Known values of {@link SecurityConfigurationRuleProtocol} that the service accepts. */
exports.KnownSecurityConfigurationRuleProtocol = void 0;
(function (KnownSecurityConfigurationRuleProtocol) {
    /** Tcp */
    KnownSecurityConfigurationRuleProtocol["Tcp"] = "Tcp";
    /** Udp */
    KnownSecurityConfigurationRuleProtocol["Udp"] = "Udp";
    /** Icmp */
    KnownSecurityConfigurationRuleProtocol["Icmp"] = "Icmp";
    /** Esp */
    KnownSecurityConfigurationRuleProtocol["Esp"] = "Esp";
    /** Any */
    KnownSecurityConfigurationRuleProtocol["Any"] = "Any";
    /** Ah */
    KnownSecurityConfigurationRuleProtocol["Ah"] = "Ah";
})(exports.KnownSecurityConfigurationRuleProtocol || (exports.KnownSecurityConfigurationRuleProtocol = {}));
/** Known values of {@link AddressPrefixType} that the service accepts. */
exports.KnownAddressPrefixType = void 0;
(function (KnownAddressPrefixType) {
    /** IPPrefix */
    KnownAddressPrefixType["IPPrefix"] = "IPPrefix";
    /** ServiceTag */
    KnownAddressPrefixType["ServiceTag"] = "ServiceTag";
})(exports.KnownAddressPrefixType || (exports.KnownAddressPrefixType = {}));
/** Known values of {@link SecurityConfigurationRuleAccess} that the service accepts. */
exports.KnownSecurityConfigurationRuleAccess = void 0;
(function (KnownSecurityConfigurationRuleAccess) {
    /** Allow */
    KnownSecurityConfigurationRuleAccess["Allow"] = "Allow";
    /** Deny */
    KnownSecurityConfigurationRuleAccess["Deny"] = "Deny";
    /** AlwaysAllow */
    KnownSecurityConfigurationRuleAccess["AlwaysAllow"] = "AlwaysAllow";
})(exports.KnownSecurityConfigurationRuleAccess || (exports.KnownSecurityConfigurationRuleAccess = {}));
/** Known values of {@link SecurityConfigurationRuleDirection} that the service accepts. */
exports.KnownSecurityConfigurationRuleDirection = void 0;
(function (KnownSecurityConfigurationRuleDirection) {
    /** Inbound */
    KnownSecurityConfigurationRuleDirection["Inbound"] = "Inbound";
    /** Outbound */
    KnownSecurityConfigurationRuleDirection["Outbound"] = "Outbound";
})(exports.KnownSecurityConfigurationRuleDirection || (exports.KnownSecurityConfigurationRuleDirection = {}));
/** Known values of {@link TunnelConnectionStatus} that the service accepts. */
exports.KnownTunnelConnectionStatus = void 0;
(function (KnownTunnelConnectionStatus) {
    /** Unknown */
    KnownTunnelConnectionStatus["Unknown"] = "Unknown";
    /** Connecting */
    KnownTunnelConnectionStatus["Connecting"] = "Connecting";
    /** Connected */
    KnownTunnelConnectionStatus["Connected"] = "Connected";
    /** NotConnected */
    KnownTunnelConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownTunnelConnectionStatus || (exports.KnownTunnelConnectionStatus = {}));
/** Known values of {@link HubVirtualNetworkConnectionStatus} that the service accepts. */
exports.KnownHubVirtualNetworkConnectionStatus = void 0;
(function (KnownHubVirtualNetworkConnectionStatus) {
    /** Unknown */
    KnownHubVirtualNetworkConnectionStatus["Unknown"] = "Unknown";
    /** Connecting */
    KnownHubVirtualNetworkConnectionStatus["Connecting"] = "Connecting";
    /** Connected */
    KnownHubVirtualNetworkConnectionStatus["Connected"] = "Connected";
    /** NotConnected */
    KnownHubVirtualNetworkConnectionStatus["NotConnected"] = "NotConnected";
})(exports.KnownHubVirtualNetworkConnectionStatus || (exports.KnownHubVirtualNetworkConnectionStatus = {}));

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
function createLroSpec(inputs) {
    const { args, spec, sendOperationFn } = inputs;
    return {
        requestMethod: spec.httpMethod,
        requestPath: spec.path,
        sendInitialRequest: () => sendOperationFn(args, spec),
        sendPollRequest: (path, options) => {
            const restSpec = tslib.__rest(spec, ["requestBody"]);
            return sendOperationFn(args, Object.assign(Object.assign({}, restSpec), { httpMethod: "GET", path, abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal }));
        }
    };
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const CloudError = {
    type: {
        name: "Composite",
        className: "CloudError",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "CloudErrorBody"
                }
            }
        }
    }
};
const CloudErrorBody = {
    type: {
        name: "Composite",
        className: "CloudErrorBody",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CloudErrorBody"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewaySku = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplicationGatewaySslPolicy = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySslPolicy",
        modelProperties: {
            disabledSslProtocols: {
                serializedName: "disabledSslProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            policyType: {
                serializedName: "policyType",
                type: {
                    name: "String"
                }
            },
            policyName: {
                serializedName: "policyName",
                type: {
                    name: "String"
                }
            },
            cipherSuites: {
                serializedName: "cipherSuites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            minProtocolVersion: {
                serializedName: "minProtocolVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubResource = {
    type: {
        name: "Composite",
        className: "SubResource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayProbeHealthResponseMatch = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayProbeHealthResponseMatch",
        modelProperties: {
            body: {
                serializedName: "body",
                type: {
                    name: "String"
                }
            },
            statusCodes: {
                serializedName: "statusCodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const Resource = {
    type: {
        name: "Composite",
        className: "Resource",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ExtendedLocation = {
    type: {
        name: "Composite",
        className: "ExtendedLocation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceConnectionState = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnectionState",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            actionsRequired: {
                serializedName: "actionsRequired",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CustomDnsConfigPropertiesFormat = {
    type: {
        name: "Composite",
        className: "CustomDnsConfigPropertiesFormat",
        modelProperties: {
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            ipAddresses: {
                serializedName: "ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivateEndpointIPConfiguration = {
    type: {
        name: "Composite",
        className: "PrivateEndpointIPConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            groupId: {
                serializedName: "properties.groupId",
                type: {
                    name: "String"
                }
            },
            memberName: {
                serializedName: "properties.memberName",
                type: {
                    name: "String"
                }
            },
            privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkInterfaceDnsSettings = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceDnsSettings",
        modelProperties: {
            dnsServers: {
                serializedName: "dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            appliedDnsServers: {
                serializedName: "appliedDnsServers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            internalDnsNameLabel: {
                serializedName: "internalDnsNameLabel",
                type: {
                    name: "String"
                }
            },
            internalFqdn: {
                serializedName: "internalFqdn",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            internalDomainNameSuffix: {
                serializedName: "internalDomainNameSuffix",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceSet = {
    type: {
        name: "Composite",
        className: "ResourceSet",
        modelProperties: {
            subscriptions: {
                serializedName: "subscriptions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const RetentionPolicyParameters = {
    type: {
        name: "Composite",
        className: "RetentionPolicyParameters",
        modelProperties: {
            days: {
                defaultValue: 0,
                serializedName: "days",
                type: {
                    name: "Number"
                }
            },
            enabled: {
                defaultValue: false,
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const FlowLogFormatParameters = {
    type: {
        name: "Composite",
        className: "FlowLogFormatParameters",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            version: {
                defaultValue: 0,
                serializedName: "version",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TrafficAnalyticsProperties = {
    type: {
        name: "Composite",
        className: "TrafficAnalyticsProperties",
        modelProperties: {
            networkWatcherFlowAnalyticsConfiguration: {
                serializedName: "networkWatcherFlowAnalyticsConfiguration",
                type: {
                    name: "Composite",
                    className: "TrafficAnalyticsConfigurationProperties"
                }
            }
        }
    }
};
const TrafficAnalyticsConfigurationProperties = {
    type: {
        name: "Composite",
        className: "TrafficAnalyticsConfigurationProperties",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                type: {
                    name: "Boolean"
                }
            },
            workspaceId: {
                serializedName: "workspaceId",
                type: {
                    name: "String"
                }
            },
            workspaceRegion: {
                serializedName: "workspaceRegion",
                type: {
                    name: "String"
                }
            },
            workspaceResourceId: {
                serializedName: "workspaceResourceId",
                type: {
                    name: "String"
                }
            },
            trafficAnalyticsInterval: {
                serializedName: "trafficAnalyticsInterval",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ServiceEndpointPropertiesFormat = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPropertiesFormat",
        modelProperties: {
            service: {
                serializedName: "service",
                type: {
                    name: "String"
                }
            },
            locations: {
                serializedName: "locations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPAddressSku = {
    type: {
        name: "Composite",
        className: "PublicIPAddressSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPAddressDnsSettings = {
    type: {
        name: "Composite",
        className: "PublicIPAddressDnsSettings",
        modelProperties: {
            domainNameLabel: {
                serializedName: "domainNameLabel",
                type: {
                    name: "String"
                }
            },
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            reverseFqdn: {
                serializedName: "reverseFqdn",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DdosSettings = {
    type: {
        name: "Composite",
        className: "DdosSettings",
        modelProperties: {
            protectionMode: {
                serializedName: "protectionMode",
                type: {
                    name: "String"
                }
            },
            ddosProtectionPlan: {
                serializedName: "ddosProtectionPlan",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const IpTag = {
    type: {
        name: "Composite",
        className: "IpTag",
        modelProperties: {
            ipTagType: {
                serializedName: "ipTagType",
                type: {
                    name: "String"
                }
            },
            tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NatGatewaySku = {
    type: {
        name: "Composite",
        className: "NatGatewaySku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayLoadBalancerTunnelInterface = {
    type: {
        name: "Composite",
        className: "GatewayLoadBalancerTunnelInterface",
        modelProperties: {
            port: {
                serializedName: "port",
                type: {
                    name: "Number"
                }
            },
            identifier: {
                serializedName: "identifier",
                type: {
                    name: "Number"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerBackendAddress = {
    type: {
        name: "Composite",
        className: "LoadBalancerBackendAddress",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            virtualNetwork: {
                serializedName: "properties.virtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            ipAddress: {
                serializedName: "properties.ipAddress",
                type: {
                    name: "String"
                }
            },
            networkInterfaceIPConfiguration: {
                serializedName: "properties.networkInterfaceIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            loadBalancerFrontendIPConfiguration: {
                serializedName: "properties.loadBalancerFrontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            inboundNatRulesPortMapping: {
                serializedName: "properties.inboundNatRulesPortMapping",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NatRulePortMapping"
                        }
                    }
                }
            },
            adminState: {
                serializedName: "properties.adminState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NatRulePortMapping = {
    type: {
        name: "Composite",
        className: "NatRulePortMapping",
        modelProperties: {
            inboundNatRuleName: {
                serializedName: "inboundNatRuleName",
                type: {
                    name: "String"
                }
            },
            frontendPort: {
                serializedName: "frontendPort",
                type: {
                    name: "Number"
                }
            },
            backendPort: {
                serializedName: "backendPort",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties",
        modelProperties: {
            groupId: {
                serializedName: "groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            requiredMemberName: {
                serializedName: "requiredMemberName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            fqdns: {
                serializedName: "fqdns",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayBackendAddress = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendAddress",
        modelProperties: {
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayConnectionDraining = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayConnectionDraining",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            drainTimeoutInSec: {
                constraints: {
                    InclusiveMaximum: 3600,
                    InclusiveMinimum: 1
                },
                serializedName: "drainTimeoutInSec",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplicationGatewayCustomError = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayCustomError",
        modelProperties: {
            statusCode: {
                serializedName: "statusCode",
                type: {
                    name: "String"
                }
            },
            customErrorPageUrl: {
                serializedName: "customErrorPageUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayClientAuthConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayClientAuthConfiguration",
        modelProperties: {
            verifyClientCertIssuerDN: {
                serializedName: "verifyClientCertIssuerDN",
                type: {
                    name: "Boolean"
                }
            },
            verifyClientRevocation: {
                serializedName: "verifyClientRevocation",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayRewriteRule = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRewriteRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            ruleSequence: {
                serializedName: "ruleSequence",
                type: {
                    name: "Number"
                }
            },
            conditions: {
                serializedName: "conditions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRewriteRuleCondition"
                        }
                    }
                }
            },
            actionSet: {
                serializedName: "actionSet",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayRewriteRuleActionSet"
                }
            }
        }
    }
};
const ApplicationGatewayRewriteRuleCondition = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRewriteRuleCondition",
        modelProperties: {
            variable: {
                serializedName: "variable",
                type: {
                    name: "String"
                }
            },
            pattern: {
                serializedName: "pattern",
                type: {
                    name: "String"
                }
            },
            ignoreCase: {
                serializedName: "ignoreCase",
                type: {
                    name: "Boolean"
                }
            },
            negate: {
                serializedName: "negate",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ApplicationGatewayRewriteRuleActionSet = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRewriteRuleActionSet",
        modelProperties: {
            requestHeaderConfigurations: {
                serializedName: "requestHeaderConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayHeaderConfiguration"
                        }
                    }
                }
            },
            responseHeaderConfigurations: {
                serializedName: "responseHeaderConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayHeaderConfiguration"
                        }
                    }
                }
            },
            urlConfiguration: {
                serializedName: "urlConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayUrlConfiguration"
                }
            }
        }
    }
};
const ApplicationGatewayHeaderConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayHeaderConfiguration",
        modelProperties: {
            headerName: {
                serializedName: "headerName",
                type: {
                    name: "String"
                }
            },
            headerValue: {
                serializedName: "headerValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayUrlConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayUrlConfiguration",
        modelProperties: {
            modifiedPath: {
                serializedName: "modifiedPath",
                type: {
                    name: "String"
                }
            },
            modifiedQueryString: {
                serializedName: "modifiedQueryString",
                type: {
                    name: "String"
                }
            },
            reroute: {
                serializedName: "reroute",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ApplicationGatewayWebApplicationFirewallConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayWebApplicationFirewallConfiguration",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            firewallMode: {
                serializedName: "firewallMode",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetType: {
                serializedName: "ruleSetType",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetVersion: {
                serializedName: "ruleSetVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            disabledRuleGroups: {
                serializedName: "disabledRuleGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallDisabledRuleGroup"
                        }
                    }
                }
            },
            requestBodyCheck: {
                serializedName: "requestBodyCheck",
                type: {
                    name: "Boolean"
                }
            },
            maxRequestBodySize: {
                constraints: {
                    InclusiveMaximum: 128,
                    InclusiveMinimum: 8
                },
                serializedName: "maxRequestBodySize",
                type: {
                    name: "Number"
                }
            },
            maxRequestBodySizeInKb: {
                constraints: {
                    InclusiveMaximum: 128,
                    InclusiveMinimum: 8
                },
                serializedName: "maxRequestBodySizeInKb",
                type: {
                    name: "Number"
                }
            },
            fileUploadLimitInMb: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "fileUploadLimitInMb",
                type: {
                    name: "Number"
                }
            },
            exclusions: {
                serializedName: "exclusions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallExclusion"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayFirewallDisabledRuleGroup = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallDisabledRuleGroup",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayFirewallExclusion = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallExclusion",
        modelProperties: {
            matchVariable: {
                serializedName: "matchVariable",
                required: true,
                type: {
                    name: "String"
                }
            },
            selectorMatchOperator: {
                serializedName: "selectorMatchOperator",
                required: true,
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayAutoscaleConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAutoscaleConfiguration",
        modelProperties: {
            minCapacity: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "minCapacity",
                required: true,
                type: {
                    name: "Number"
                }
            },
            maxCapacity: {
                constraints: {
                    InclusiveMinimum: 2
                },
                serializedName: "maxCapacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ApplicationGatewayGlobalConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayGlobalConfiguration",
        modelProperties: {
            enableRequestBuffering: {
                serializedName: "enableRequestBuffering",
                type: {
                    name: "Boolean"
                }
            },
            enableResponseBuffering: {
                serializedName: "enableResponseBuffering",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ManagedServiceIdentity = {
    type: {
        name: "Composite",
        className: "ManagedServiceIdentity",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "SystemAssigned",
                        "UserAssigned",
                        "SystemAssigned, UserAssigned",
                        "None"
                    ]
                }
            },
            userAssignedIdentities: {
                serializedName: "userAssignedIdentities",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "Composite",
                            className: "Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties"
                        }
                    }
                }
            }
        }
    }
};
const Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties = {
    type: {
        name: "Composite",
        className: "Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties",
        modelProperties: {
            principalId: {
                serializedName: "principalId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            clientId: {
                serializedName: "clientId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagsObject = {
    type: {
        name: "Composite",
        className: "TagsObject",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const ApplicationGatewayListResult = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealth = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealth",
        modelProperties: {
            backendAddressPools: {
                serializedName: "backendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendHealthPool"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealthPool = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealthPool",
        modelProperties: {
            backendAddressPool: {
                serializedName: "backendAddressPool",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayBackendAddressPool"
                }
            },
            backendHttpSettingsCollection: {
                serializedName: "backendHttpSettingsCollection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendHealthHttpSettings"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealthHttpSettings = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealthHttpSettings",
        modelProperties: {
            backendHttpSettings: {
                serializedName: "backendHttpSettings",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayBackendHttpSettings"
                }
            },
            servers: {
                serializedName: "servers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendHealthServer"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealthServer = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealthServer",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            ipConfiguration: {
                serializedName: "ipConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceIPConfiguration"
                }
            },
            health: {
                serializedName: "health",
                type: {
                    name: "String"
                }
            },
            healthProbeLog: {
                serializedName: "healthProbeLog",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayOnDemandProbe = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayOnDemandProbe",
        modelProperties: {
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            host: {
                serializedName: "host",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            timeout: {
                serializedName: "timeout",
                type: {
                    name: "Number"
                }
            },
            pickHostNameFromBackendHttpSettings: {
                serializedName: "pickHostNameFromBackendHttpSettings",
                type: {
                    name: "Boolean"
                }
            },
            match: {
                serializedName: "match",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayProbeHealthResponseMatch"
                }
            },
            backendAddressPool: {
                serializedName: "backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            backendHttpSettings: {
                serializedName: "backendHttpSettings",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const ApplicationGatewayBackendHealthOnDemand = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHealthOnDemand",
        modelProperties: {
            backendAddressPool: {
                serializedName: "backendAddressPool",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayBackendAddressPool"
                }
            },
            backendHealthHttpSettings: {
                serializedName: "backendHealthHttpSettings",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayBackendHealthHttpSettings"
                }
            }
        }
    }
};
const ApplicationGatewayPrivateLinkResourceListResult = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateLinkResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateLinkResource"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayPrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorModel = {
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorDetails"
                        }
                    }
                }
            },
            innerError: {
                serializedName: "innerError",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorDetails = {
    type: {
        name: "Composite",
        className: "ErrorDetails",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayAvailableWafRuleSetsResult = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAvailableWafRuleSetsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallRuleSet"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayFirewallRuleGroup = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallRuleGroup",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallRule"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayFirewallRule = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallRule",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                required: true,
                type: {
                    name: "Number"
                }
            },
            ruleIdString: {
                serializedName: "ruleIdString",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayAvailableSslPredefinedPolicies = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAvailableSslPredefinedPolicies",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewaySslPredefinedPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayWafDynamicManifestResult = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayWafDynamicManifestResult",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            availableRuleSets: {
                serializedName: "properties.availableRuleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallManifestRuleSet"
                        }
                    }
                }
            },
            ruleSetType: {
                serializedName: "properties.defaultRuleSet.ruleSetType",
                type: {
                    name: "String"
                }
            },
            ruleSetVersion: {
                serializedName: "properties.defaultRuleSet.ruleSetVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayFirewallManifestRuleSet = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallManifestRuleSet",
        modelProperties: {
            ruleSetType: {
                serializedName: "ruleSetType",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetVersion: {
                serializedName: "ruleSetVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            tiers: {
                serializedName: "tiers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ruleGroups: {
                serializedName: "ruleGroups",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallRuleGroup"
                        }
                    }
                }
            }
        }
    }
};
const ApplicationGatewayWafDynamicManifestResultList = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayWafDynamicManifestResultList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayWafDynamicManifestResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationSecurityGroupListResult = {
    type: {
        name: "Composite",
        className: "ApplicationSecurityGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableDelegationsResult = {
    type: {
        name: "Composite",
        className: "AvailableDelegationsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableDelegation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableDelegation = {
    type: {
        name: "Composite",
        className: "AvailableDelegation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            serviceName: {
                serializedName: "serviceName",
                type: {
                    name: "String"
                }
            },
            actions: {
                serializedName: "actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AvailableServiceAliasesResult = {
    type: {
        name: "Composite",
        className: "AvailableServiceAliasesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableServiceAlias"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableServiceAlias = {
    type: {
        name: "Composite",
        className: "AvailableServiceAlias",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallRCAction = {
    type: {
        name: "Composite",
        className: "AzureFirewallRCAction",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallApplicationRule = {
    type: {
        name: "Composite",
        className: "AzureFirewallApplicationRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            protocols: {
                serializedName: "protocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallApplicationRuleProtocol"
                        }
                    }
                }
            },
            targetFqdns: {
                serializedName: "targetFqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            fqdnTags: {
                serializedName: "fqdnTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AzureFirewallApplicationRuleProtocol = {
    type: {
        name: "Composite",
        className: "AzureFirewallApplicationRuleProtocol",
        modelProperties: {
            protocolType: {
                serializedName: "protocolType",
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AzureFirewallNatRCAction = {
    type: {
        name: "Composite",
        className: "AzureFirewallNatRCAction",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallNatRule = {
    type: {
        name: "Composite",
        className: "AzureFirewallNatRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            protocols: {
                serializedName: "protocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            translatedAddress: {
                serializedName: "translatedAddress",
                type: {
                    name: "String"
                }
            },
            translatedPort: {
                serializedName: "translatedPort",
                type: {
                    name: "String"
                }
            },
            translatedFqdn: {
                serializedName: "translatedFqdn",
                type: {
                    name: "String"
                }
            },
            sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AzureFirewallNetworkRule = {
    type: {
        name: "Composite",
        className: "AzureFirewallNetworkRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            protocols: {
                serializedName: "protocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationFqdns: {
                serializedName: "destinationFqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationIpGroups: {
                serializedName: "destinationIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const HubIPAddresses = {
    type: {
        name: "Composite",
        className: "HubIPAddresses",
        modelProperties: {
            publicIPs: {
                serializedName: "publicIPs",
                type: {
                    name: "Composite",
                    className: "HubPublicIPAddresses"
                }
            },
            privateIPAddress: {
                serializedName: "privateIPAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HubPublicIPAddresses = {
    type: {
        name: "Composite",
        className: "HubPublicIPAddresses",
        modelProperties: {
            addresses: {
                serializedName: "addresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallPublicIPAddress"
                        }
                    }
                }
            },
            count: {
                serializedName: "count",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AzureFirewallPublicIPAddress = {
    type: {
        name: "Composite",
        className: "AzureFirewallPublicIPAddress",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallIpGroups = {
    type: {
        name: "Composite",
        className: "AzureFirewallIpGroups",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            changeNumber: {
                serializedName: "changeNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallSku = {
    type: {
        name: "Composite",
        className: "AzureFirewallSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureFirewallListResult = {
    type: {
        name: "Composite",
        className: "AzureFirewallListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewall"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IPPrefixesList = {
    type: {
        name: "Composite",
        className: "IPPrefixesList",
        modelProperties: {
            ipPrefixes: {
                serializedName: "ipPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const AzureFirewallFqdnTagListResult = {
    type: {
        name: "Composite",
        className: "AzureFirewallFqdnTagListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallFqdnTag"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureWebCategory = {
    type: {
        name: "Composite",
        className: "AzureWebCategory",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            group: {
                serializedName: "properties.group",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureWebCategoryListResult = {
    type: {
        name: "Composite",
        className: "AzureWebCategoryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureWebCategory"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Sku = {
    type: {
        name: "Composite",
        className: "Sku",
        modelProperties: {
            name: {
                defaultValue: "Standard",
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionHostListResult = {
    type: {
        name: "Composite",
        className: "BastionHostListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionHost"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionShareableLinkListRequest = {
    type: {
        name: "Composite",
        className: "BastionShareableLinkListRequest",
        modelProperties: {
            vms: {
                serializedName: "vms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionShareableLink"
                        }
                    }
                }
            }
        }
    }
};
const BastionShareableLink = {
    type: {
        name: "Composite",
        className: "BastionShareableLink",
        modelProperties: {
            vm: {
                serializedName: "vm",
                type: {
                    name: "Composite",
                    className: "Vm"
                }
            },
            bsl: {
                serializedName: "bsl",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionShareableLinkListResult = {
    type: {
        name: "Composite",
        className: "BastionShareableLinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionShareableLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionActiveSessionListResult = {
    type: {
        name: "Composite",
        className: "BastionActiveSessionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionActiveSession"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionActiveSession = {
    type: {
        name: "Composite",
        className: "BastionActiveSession",
        modelProperties: {
            sessionId: {
                serializedName: "sessionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            },
            targetSubscriptionId: {
                serializedName: "targetSubscriptionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetHostName: {
                serializedName: "targetHostName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetResourceGroup: {
                serializedName: "targetResourceGroup",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            userName: {
                serializedName: "userName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetIpAddress: {
                serializedName: "targetIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetResourceId: {
                serializedName: "targetResourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sessionDurationInMins: {
                serializedName: "sessionDurationInMins",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const SessionIds = {
    type: {
        name: "Composite",
        className: "SessionIds",
        modelProperties: {
            sessionIds: {
                serializedName: "sessionIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const BastionSessionDeleteResult = {
    type: {
        name: "Composite",
        className: "BastionSessionDeleteResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionSessionState"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BastionSessionState = {
    type: {
        name: "Composite",
        className: "BastionSessionState",
        modelProperties: {
            sessionId: {
                serializedName: "sessionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DnsNameAvailabilityResult = {
    type: {
        name: "Composite",
        className: "DnsNameAvailabilityResult",
        modelProperties: {
            available: {
                serializedName: "available",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const NetworkInterfaceListResult = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPAddressListResult = {
    type: {
        name: "Composite",
        className: "PublicIPAddressListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PublicIPAddress"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SwapResource = {
    type: {
        name: "Composite",
        className: "SwapResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SwapResourceProperties"
                }
            }
        }
    }
};
const SwapResourceProperties = {
    type: {
        name: "Composite",
        className: "SwapResourceProperties",
        modelProperties: {
            slotType: {
                serializedName: "slotType",
                type: {
                    name: "Enum",
                    allowedValues: ["Production", "Staging"]
                }
            }
        }
    }
};
const SwapResourceListResult = {
    type: {
        name: "Composite",
        className: "SwapResourceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SwapResource"
                        }
                    }
                }
            }
        }
    }
};
const CustomIpPrefixListResult = {
    type: {
        name: "Composite",
        className: "CustomIpPrefixListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomIpPrefix"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DdosProtectionPlan = {
    type: {
        name: "Composite",
        className: "DdosProtectionPlan",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            virtualNetworks: {
                serializedName: "properties.virtualNetworks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            },
            publicIpAddresses: {
                serializedName: "properties.publicIpAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }
        }
    }
};
const DdosProtectionPlanListResult = {
    type: {
        name: "Composite",
        className: "DdosProtectionPlanListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DdosProtectionPlan"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QosIpRange = {
    type: {
        name: "Composite",
        className: "QosIpRange",
        modelProperties: {
            startIP: {
                serializedName: "startIP",
                type: {
                    name: "String"
                }
            },
            endIP: {
                serializedName: "endIP",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QosPortRange = {
    type: {
        name: "Composite",
        className: "QosPortRange",
        modelProperties: {
            start: {
                serializedName: "start",
                type: {
                    name: "Number"
                }
            },
            end: {
                serializedName: "end",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const QosDefinition = {
    type: {
        name: "Composite",
        className: "QosDefinition",
        modelProperties: {
            markings: {
                serializedName: "markings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            sourceIpRanges: {
                serializedName: "sourceIpRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosIpRange"
                        }
                    }
                }
            },
            destinationIpRanges: {
                serializedName: "destinationIpRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosIpRange"
                        }
                    }
                }
            },
            sourcePortRanges: {
                serializedName: "sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosPortRange"
                        }
                    }
                }
            },
            destinationPortRanges: {
                serializedName: "destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosPortRange"
                        }
                    }
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DscpConfigurationListResult = {
    type: {
        name: "Composite",
        className: "DscpConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "DscpConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EndpointServicesListResult = {
    type: {
        name: "Composite",
        className: "EndpointServicesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EndpointServiceResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AuthorizationListResult = {
    type: {
        name: "Composite",
        className: "AuthorizationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitAuthorization"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitPeeringConfig = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitPeeringConfig",
        modelProperties: {
            advertisedPublicPrefixes: {
                serializedName: "advertisedPublicPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            advertisedCommunities: {
                serializedName: "advertisedCommunities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            advertisedPublicPrefixesState: {
                serializedName: "advertisedPublicPrefixesState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            legacyMode: {
                serializedName: "legacyMode",
                type: {
                    name: "Number"
                }
            },
            customerASN: {
                serializedName: "customerASN",
                type: {
                    name: "Number"
                }
            },
            routingRegistryName: {
                serializedName: "routingRegistryName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitStats = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitStats",
        modelProperties: {
            primarybytesIn: {
                serializedName: "primarybytesIn",
                type: {
                    name: "Number"
                }
            },
            primarybytesOut: {
                serializedName: "primarybytesOut",
                type: {
                    name: "Number"
                }
            },
            secondarybytesIn: {
                serializedName: "secondarybytesIn",
                type: {
                    name: "Number"
                }
            },
            secondarybytesOut: {
                serializedName: "secondarybytesOut",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Ipv6ExpressRouteCircuitPeeringConfig = {
    type: {
        name: "Composite",
        className: "Ipv6ExpressRouteCircuitPeeringConfig",
        modelProperties: {
            primaryPeerAddressPrefix: {
                serializedName: "primaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            },
            secondaryPeerAddressPrefix: {
                serializedName: "secondaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            },
            microsoftPeeringConfig: {
                serializedName: "microsoftPeeringConfig",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitPeeringConfig"
                }
            },
            routeFilter: {
                serializedName: "routeFilter",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteConnectionId = {
    type: {
        name: "Composite",
        className: "ExpressRouteConnectionId",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Ipv6CircuitConnectionConfig = {
    type: {
        name: "Composite",
        className: "Ipv6CircuitConnectionConfig",
        modelProperties: {
            addressPrefix: {
                serializedName: "addressPrefix",
                type: {
                    name: "String"
                }
            },
            circuitConnectionStatus: {
                serializedName: "circuitConnectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitPeeringListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitPeeringListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitConnectionListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeerExpressRouteCircuitConnectionListResult = {
    type: {
        name: "Composite",
        className: "PeerExpressRouteCircuitConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeerExpressRouteCircuitConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitSku = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            family: {
                serializedName: "family",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitServiceProviderProperties = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitServiceProviderProperties",
        modelProperties: {
            serviceProviderName: {
                serializedName: "serviceProviderName",
                type: {
                    name: "String"
                }
            },
            peeringLocation: {
                serializedName: "peeringLocation",
                type: {
                    name: "String"
                }
            },
            bandwidthInMbps: {
                serializedName: "bandwidthInMbps",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExpressRouteCircuitsArpTableListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitsArpTableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitArpTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitArpTable = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitArpTable",
        modelProperties: {
            age: {
                serializedName: "age",
                type: {
                    name: "Number"
                }
            },
            interface: {
                serializedName: "interface",
                type: {
                    name: "String"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            },
            macAddress: {
                serializedName: "macAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitsRoutesTableListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitsRoutesTableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitRoutesTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitRoutesTable = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitRoutesTable",
        modelProperties: {
            network: {
                serializedName: "network",
                type: {
                    name: "String"
                }
            },
            nextHop: {
                serializedName: "nextHop",
                type: {
                    name: "String"
                }
            },
            locPrf: {
                serializedName: "locPrf",
                type: {
                    name: "String"
                }
            },
            weight: {
                serializedName: "weight",
                type: {
                    name: "Number"
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitsRoutesTableSummaryListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitsRoutesTableSummaryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitRoutesTableSummary"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitRoutesTableSummary = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitRoutesTableSummary",
        modelProperties: {
            neighbor: {
                serializedName: "neighbor",
                type: {
                    name: "String"
                }
            },
            v: {
                serializedName: "v",
                type: {
                    name: "Number"
                }
            },
            as: {
                serializedName: "as",
                type: {
                    name: "Number"
                }
            },
            upDown: {
                serializedName: "upDown",
                type: {
                    name: "String"
                }
            },
            statePfxRcd: {
                serializedName: "statePfxRcd",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuit"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteServiceProviderListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteServiceProviderListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteServiceProvider"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteServiceProviderBandwidthsOffered = {
    type: {
        name: "Composite",
        className: "ExpressRouteServiceProviderBandwidthsOffered",
        modelProperties: {
            offerName: {
                serializedName: "offerName",
                type: {
                    name: "String"
                }
            },
            valueInMbps: {
                serializedName: "valueInMbps",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExpressRouteCrossConnectionListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCrossConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCircuitReference = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitReference",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCrossConnectionPeeringList = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionPeeringList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCrossConnectionPeering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCrossConnectionsRoutesTableSummaryListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionsRoutesTableSummaryListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCrossConnectionRoutesTableSummary"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteCrossConnectionRoutesTableSummary = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionRoutesTableSummary",
        modelProperties: {
            neighbor: {
                serializedName: "neighbor",
                type: {
                    name: "String"
                }
            },
            asn: {
                serializedName: "asn",
                type: {
                    name: "Number"
                }
            },
            upDown: {
                serializedName: "upDown",
                type: {
                    name: "String"
                }
            },
            stateOrPrefixesReceived: {
                serializedName: "stateOrPrefixesReceived",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRoutePortsLocationListResult = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortsLocationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRoutePortsLocation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRoutePortsLocationBandwidths = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortsLocationBandwidths",
        modelProperties: {
            offerName: {
                serializedName: "offerName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            valueInGbps: {
                serializedName: "valueInGbps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExpressRouteLinkMacSecConfig = {
    type: {
        name: "Composite",
        className: "ExpressRouteLinkMacSecConfig",
        modelProperties: {
            cknSecretIdentifier: {
                serializedName: "cknSecretIdentifier",
                type: {
                    name: "String"
                }
            },
            cakSecretIdentifier: {
                serializedName: "cakSecretIdentifier",
                type: {
                    name: "String"
                }
            },
            cipher: {
                serializedName: "cipher",
                type: {
                    name: "String"
                }
            },
            sciState: {
                serializedName: "sciState",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRoutePortListResult = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRoutePort"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteLinkListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteLinkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateExpressRoutePortsLOARequest = {
    type: {
        name: "Composite",
        className: "GenerateExpressRoutePortsLOARequest",
        modelProperties: {
            customerName: {
                serializedName: "customerName",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GenerateExpressRoutePortsLOAResult = {
    type: {
        name: "Composite",
        className: "GenerateExpressRoutePortsLOAResult",
        modelProperties: {
            encodedContent: {
                serializedName: "encodedContent",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRoutePortAuthorizationListResult = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortAuthorizationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRoutePortAuthorization"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteProviderPortListResult = {
    type: {
        name: "Composite",
        className: "ExpressRouteProviderPortListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteProviderPort"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyThreatIntelWhitelist = {
    type: {
        name: "Composite",
        className: "FirewallPolicyThreatIntelWhitelist",
        modelProperties: {
            ipAddresses: {
                serializedName: "ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            fqdns: {
                serializedName: "fqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const FirewallPolicyInsights = {
    type: {
        name: "Composite",
        className: "FirewallPolicyInsights",
        modelProperties: {
            isEnabled: {
                serializedName: "isEnabled",
                type: {
                    name: "Boolean"
                }
            },
            retentionDays: {
                serializedName: "retentionDays",
                type: {
                    name: "Number"
                }
            },
            logAnalyticsResources: {
                serializedName: "logAnalyticsResources",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyLogAnalyticsResources"
                }
            }
        }
    }
};
const FirewallPolicyLogAnalyticsResources = {
    type: {
        name: "Composite",
        className: "FirewallPolicyLogAnalyticsResources",
        modelProperties: {
            workspaces: {
                serializedName: "workspaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyLogAnalyticsWorkspace"
                        }
                    }
                }
            },
            defaultWorkspaceId: {
                serializedName: "defaultWorkspaceId",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const FirewallPolicyLogAnalyticsWorkspace = {
    type: {
        name: "Composite",
        className: "FirewallPolicyLogAnalyticsWorkspace",
        modelProperties: {
            region: {
                serializedName: "region",
                type: {
                    name: "String"
                }
            },
            workspaceId: {
                serializedName: "workspaceId",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const FirewallPolicySnat = {
    type: {
        name: "Composite",
        className: "FirewallPolicySnat",
        modelProperties: {
            privateRanges: {
                serializedName: "privateRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            autoLearnPrivateRanges: {
                serializedName: "autoLearnPrivateRanges",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicySQL = {
    type: {
        name: "Composite",
        className: "FirewallPolicySQL",
        modelProperties: {
            allowSqlRedirect: {
                serializedName: "allowSqlRedirect",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const DnsSettings = {
    type: {
        name: "Composite",
        className: "DnsSettings",
        modelProperties: {
            servers: {
                serializedName: "servers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            enableProxy: {
                serializedName: "enableProxy",
                type: {
                    name: "Boolean"
                }
            },
            requireProxyForNetworkRules: {
                serializedName: "requireProxyForNetworkRules",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ExplicitProxy = {
    type: {
        name: "Composite",
        className: "ExplicitProxy",
        modelProperties: {
            enableExplicitProxy: {
                serializedName: "enableExplicitProxy",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            httpPort: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "httpPort",
                type: {
                    name: "Number"
                }
            },
            httpsPort: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "httpsPort",
                type: {
                    name: "Number"
                }
            },
            enablePacFile: {
                serializedName: "enablePacFile",
                nullable: true,
                type: {
                    name: "Boolean"
                }
            },
            pacFilePort: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "pacFilePort",
                type: {
                    name: "Number"
                }
            },
            pacFile: {
                serializedName: "pacFile",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyIntrusionDetection = {
    type: {
        name: "Composite",
        className: "FirewallPolicyIntrusionDetection",
        modelProperties: {
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            },
            configuration: {
                serializedName: "configuration",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyIntrusionDetectionConfiguration"
                }
            }
        }
    }
};
const FirewallPolicyIntrusionDetectionConfiguration = {
    type: {
        name: "Composite",
        className: "FirewallPolicyIntrusionDetectionConfiguration",
        modelProperties: {
            signatureOverrides: {
                serializedName: "signatureOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyIntrusionDetectionSignatureSpecification"
                        }
                    }
                }
            },
            bypassTrafficSettings: {
                serializedName: "bypassTrafficSettings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyIntrusionDetectionBypassTrafficSpecifications"
                        }
                    }
                }
            },
            privateRanges: {
                serializedName: "privateRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const FirewallPolicyIntrusionDetectionSignatureSpecification = {
    type: {
        name: "Composite",
        className: "FirewallPolicyIntrusionDetectionSignatureSpecification",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyIntrusionDetectionBypassTrafficSpecifications = {
    type: {
        name: "Composite",
        className: "FirewallPolicyIntrusionDetectionBypassTrafficSpecifications",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationIpGroups: {
                serializedName: "destinationIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const FirewallPolicyTransportSecurity = {
    type: {
        name: "Composite",
        className: "FirewallPolicyTransportSecurity",
        modelProperties: {
            certificateAuthority: {
                serializedName: "certificateAuthority",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyCertificateAuthority"
                }
            }
        }
    }
};
const FirewallPolicyCertificateAuthority = {
    type: {
        name: "Composite",
        className: "FirewallPolicyCertificateAuthority",
        modelProperties: {
            keyVaultSecretId: {
                serializedName: "keyVaultSecretId",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicySku = {
    type: {
        name: "Composite",
        className: "FirewallPolicySku",
        modelProperties: {
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyListResult = {
    type: {
        name: "Composite",
        className: "FirewallPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyRuleCollection = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRuleCollection",
        uberParent: "FirewallPolicyRuleCollection",
        polymorphicDiscriminator: {
            serializedName: "ruleCollectionType",
            clientName: "ruleCollectionType"
        },
        modelProperties: {
            ruleCollectionType: {
                serializedName: "ruleCollectionType",
                required: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const FirewallPolicyRuleCollectionGroupListResult = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRuleCollectionGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRuleCollectionGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IdpsQueryObject = {
    type: {
        name: "Composite",
        className: "IdpsQueryObject",
        modelProperties: {
            filters: {
                serializedName: "filters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FilterItems"
                        }
                    }
                }
            },
            search: {
                serializedName: "search",
                type: {
                    name: "String"
                }
            },
            orderBy: {
                serializedName: "orderBy",
                type: {
                    name: "Composite",
                    className: "OrderBy"
                }
            },
            resultsPerPage: {
                constraints: {
                    InclusiveMaximum: 1000,
                    InclusiveMinimum: 1
                },
                serializedName: "resultsPerPage",
                type: {
                    name: "Number"
                }
            },
            skip: {
                serializedName: "skip",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const FilterItems = {
    type: {
        name: "Composite",
        className: "FilterItems",
        modelProperties: {
            field: {
                serializedName: "field",
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const OrderBy = {
    type: {
        name: "Composite",
        className: "OrderBy",
        modelProperties: {
            field: {
                serializedName: "field",
                type: {
                    name: "String"
                }
            },
            order: {
                serializedName: "order",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QueryResults = {
    type: {
        name: "Composite",
        className: "QueryResults",
        modelProperties: {
            matchingRecordsCount: {
                serializedName: "matchingRecordsCount",
                type: {
                    name: "Number"
                }
            },
            signatures: {
                serializedName: "signatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SingleQueryResult"
                        }
                    }
                }
            }
        }
    }
};
const SingleQueryResult = {
    type: {
        name: "Composite",
        className: "SingleQueryResult",
        modelProperties: {
            signatureId: {
                serializedName: "signatureId",
                type: {
                    name: "Number"
                }
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "Enum",
                    allowedValues: [0, 1, 2]
                }
            },
            severity: {
                serializedName: "severity",
                type: {
                    name: "Enum",
                    allowedValues: [1, 2, 3]
                }
            },
            direction: {
                serializedName: "direction",
                type: {
                    name: "Enum",
                    allowedValues: [0, 1, 2]
                }
            },
            group: {
                serializedName: "group",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            sourcePorts: {
                serializedName: "sourcePorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            lastUpdated: {
                serializedName: "lastUpdated",
                type: {
                    name: "String"
                }
            },
            inheritedFromParentPolicy: {
                serializedName: "inheritedFromParentPolicy",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const SignaturesOverrides = {
    type: {
        name: "Composite",
        className: "SignaturesOverrides",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "SignaturesOverridesProperties"
                }
            }
        }
    }
};
const SignaturesOverridesProperties = {
    type: {
        name: "Composite",
        className: "SignaturesOverridesProperties",
        modelProperties: {
            signatures: {
                serializedName: "signatures",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const SignatureOverridesFilterValuesQuery = {
    type: {
        name: "Composite",
        className: "SignatureOverridesFilterValuesQuery",
        modelProperties: {
            filterName: {
                serializedName: "filterName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SignatureOverridesFilterValuesResponse = {
    type: {
        name: "Composite",
        className: "SignatureOverridesFilterValuesResponse",
        modelProperties: {
            filterValues: {
                serializedName: "filterValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SignaturesOverridesList = {
    type: {
        name: "Composite",
        className: "SignaturesOverridesList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SignaturesOverrides"
                        }
                    }
                }
            }
        }
    }
};
const IpAllocationListResult = {
    type: {
        name: "Composite",
        className: "IpAllocationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpAllocation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IpGroupListResult = {
    type: {
        name: "Composite",
        className: "IpGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerSku = {
    type: {
        name: "Composite",
        className: "LoadBalancerSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancer"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerBackendAddressPoolListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerBackendAddressPoolListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendAddressPool"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerFrontendIPConfigurationListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerFrontendIPConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendIPConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const InboundNatRuleListResult = {
    type: {
        name: "Composite",
        className: "InboundNatRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerLoadBalancingRuleListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerLoadBalancingRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancingRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerOutboundRuleListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerOutboundRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerProbeListResult = {
    type: {
        name: "Composite",
        className: "LoadBalancerProbeListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Probe"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LoadBalancerVipSwapRequest = {
    type: {
        name: "Composite",
        className: "LoadBalancerVipSwapRequest",
        modelProperties: {
            frontendIPConfigurations: {
                serializedName: "frontendIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancerVipSwapRequestFrontendIPConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const LoadBalancerVipSwapRequestFrontendIPConfiguration = {
    type: {
        name: "Composite",
        className: "LoadBalancerVipSwapRequestFrontendIPConfiguration",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const QueryInboundNatRulePortMappingRequest = {
    type: {
        name: "Composite",
        className: "QueryInboundNatRulePortMappingRequest",
        modelProperties: {
            ipConfiguration: {
                serializedName: "ipConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            ipAddress: {
                serializedName: "ipAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BackendAddressInboundNatRulePortMappings = {
    type: {
        name: "Composite",
        className: "BackendAddressInboundNatRulePortMappings",
        modelProperties: {
            inboundNatRulePortMappings: {
                serializedName: "inboundNatRulePortMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatRulePortMapping"
                        }
                    }
                }
            }
        }
    }
};
const InboundNatRulePortMapping = {
    type: {
        name: "Composite",
        className: "InboundNatRulePortMapping",
        modelProperties: {
            inboundNatRuleName: {
                serializedName: "inboundNatRuleName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            frontendPort: {
                serializedName: "frontendPort",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            backendPort: {
                serializedName: "backendPort",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const NatGatewayListResult = {
    type: {
        name: "Composite",
        className: "NatGatewayListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NatGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveRouteListResult = {
    type: {
        name: "Composite",
        className: "EffectiveRouteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveRoute"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveRoute = {
    type: {
        name: "Composite",
        className: "EffectiveRoute",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            disableBgpRoutePropagation: {
                serializedName: "disableBgpRoutePropagation",
                type: {
                    name: "Boolean"
                }
            },
            source: {
                serializedName: "source",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            addressPrefix: {
                serializedName: "addressPrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopIpAddress: {
                serializedName: "nextHopIpAddress",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopType: {
                serializedName: "nextHopType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveNetworkSecurityGroupListResult = {
    type: {
        name: "Composite",
        className: "EffectiveNetworkSecurityGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveNetworkSecurityGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveNetworkSecurityGroup = {
    type: {
        name: "Composite",
        className: "EffectiveNetworkSecurityGroup",
        modelProperties: {
            networkSecurityGroup: {
                serializedName: "networkSecurityGroup",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            association: {
                serializedName: "association",
                type: {
                    name: "Composite",
                    className: "EffectiveNetworkSecurityGroupAssociation"
                }
            },
            effectiveSecurityRules: {
                serializedName: "effectiveSecurityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveNetworkSecurityRule"
                        }
                    }
                }
            },
            tagMap: {
                serializedName: "tagMap",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveNetworkSecurityGroupAssociation = {
    type: {
        name: "Composite",
        className: "EffectiveNetworkSecurityGroupAssociation",
        modelProperties: {
            networkManager: {
                serializedName: "networkManager",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            subnet: {
                serializedName: "subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            networkInterface: {
                serializedName: "networkInterface",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const EffectiveNetworkSecurityRule = {
    type: {
        name: "Composite",
        className: "EffectiveNetworkSecurityRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            sourcePortRange: {
                serializedName: "sourcePortRange",
                type: {
                    name: "String"
                }
            },
            destinationPortRange: {
                serializedName: "destinationPortRange",
                type: {
                    name: "String"
                }
            },
            sourcePortRanges: {
                serializedName: "sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationPortRanges: {
                serializedName: "destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sourceAddressPrefix: {
                serializedName: "sourceAddressPrefix",
                type: {
                    name: "String"
                }
            },
            destinationAddressPrefix: {
                serializedName: "destinationAddressPrefix",
                type: {
                    name: "String"
                }
            },
            sourceAddressPrefixes: {
                serializedName: "sourceAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinationAddressPrefixes: {
                serializedName: "destinationAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            expandedSourceAddressPrefix: {
                serializedName: "expandedSourceAddressPrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            expandedDestinationAddressPrefix: {
                serializedName: "expandedDestinationAddressPrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            access: {
                serializedName: "access",
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                type: {
                    name: "Number"
                }
            },
            direction: {
                serializedName: "direction",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkInterfaceIPConfigurationListResult = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceIPConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceIPConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkInterfaceLoadBalancerListResult = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceLoadBalancerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancer"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkInterfaceTapConfigurationListResult = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceTapConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceTapConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerPropertiesNetworkManagerScopes = {
    type: {
        name: "Composite",
        className: "NetworkManagerPropertiesNetworkManagerScopes",
        modelProperties: {
            managementGroups: {
                serializedName: "managementGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            subscriptions: {
                serializedName: "subscriptions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            crossTenantScopes: {
                serializedName: "crossTenantScopes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CrossTenantScopes"
                        }
                    }
                }
            }
        }
    }
};
const CrossTenantScopes = {
    type: {
        name: "Composite",
        className: "CrossTenantScopes",
        modelProperties: {
            tenantId: {
                serializedName: "tenantId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            managementGroups: {
                serializedName: "managementGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            subscriptions: {
                serializedName: "subscriptions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const SystemData = {
    type: {
        name: "Composite",
        className: "SystemData",
        modelProperties: {
            createdBy: {
                serializedName: "createdBy",
                type: {
                    name: "String"
                }
            },
            createdByType: {
                serializedName: "createdByType",
                type: {
                    name: "String"
                }
            },
            createdAt: {
                serializedName: "createdAt",
                type: {
                    name: "DateTime"
                }
            },
            lastModifiedBy: {
                serializedName: "lastModifiedBy",
                type: {
                    name: "String"
                }
            },
            lastModifiedByType: {
                serializedName: "lastModifiedByType",
                type: {
                    name: "String"
                }
            },
            lastModifiedAt: {
                serializedName: "lastModifiedAt",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const PatchObject = {
    type: {
        name: "Composite",
        className: "PatchObject",
        modelProperties: {
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }
        }
    }
};
const NetworkManagerCommit = {
    type: {
        name: "Composite",
        className: "NetworkManagerCommit",
        modelProperties: {
            commitId: {
                serializedName: "commitId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            targetLocations: {
                serializedName: "targetLocations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            configurationIds: {
                serializedName: "configurationIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            commitType: {
                serializedName: "commitType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerDeploymentStatusParameter = {
    type: {
        name: "Composite",
        className: "NetworkManagerDeploymentStatusParameter",
        modelProperties: {
            regions: {
                serializedName: "regions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            deploymentTypes: {
                serializedName: "deploymentTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerDeploymentStatusListResult = {
    type: {
        name: "Composite",
        className: "NetworkManagerDeploymentStatusListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkManagerDeploymentStatus"
                        }
                    }
                }
            },
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerDeploymentStatus = {
    type: {
        name: "Composite",
        className: "NetworkManagerDeploymentStatus",
        modelProperties: {
            commitTime: {
                serializedName: "commitTime",
                type: {
                    name: "DateTime"
                }
            },
            region: {
                serializedName: "region",
                type: {
                    name: "String"
                }
            },
            deploymentStatus: {
                serializedName: "deploymentStatus",
                type: {
                    name: "String"
                }
            },
            configurationIds: {
                serializedName: "configurationIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            deploymentType: {
                serializedName: "deploymentType",
                type: {
                    name: "String"
                }
            },
            errorMessage: {
                serializedName: "errorMessage",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerListResult = {
    type: {
        name: "Composite",
        className: "NetworkManagerListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkManager"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ActiveConfigurationParameter = {
    type: {
        name: "Composite",
        className: "ActiveConfigurationParameter",
        modelProperties: {
            regions: {
                serializedName: "regions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ActiveConnectivityConfigurationsListResult = {
    type: {
        name: "Composite",
        className: "ActiveConnectivityConfigurationsListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ActiveConnectivityConfiguration"
                        }
                    }
                }
            },
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveConnectivityConfiguration = {
    type: {
        name: "Composite",
        className: "EffectiveConnectivityConfiguration",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            configurationGroups: {
                serializedName: "configurationGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConfigurationGroup"
                        }
                    }
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            connectivityTopology: {
                serializedName: "properties.connectivityTopology",
                type: {
                    name: "String"
                }
            },
            hubs: {
                serializedName: "properties.hubs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Hub"
                        }
                    }
                }
            },
            isGlobal: {
                serializedName: "properties.isGlobal",
                type: {
                    name: "String"
                }
            },
            appliesToGroups: {
                serializedName: "properties.appliesToGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityGroupItem"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            deleteExistingPeering: {
                serializedName: "properties.deleteExistingPeering",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Hub = {
    type: {
        name: "Composite",
        className: "Hub",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            resourceType: {
                serializedName: "resourceType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivityGroupItem = {
    type: {
        name: "Composite",
        className: "ConnectivityGroupItem",
        modelProperties: {
            networkGroupId: {
                serializedName: "networkGroupId",
                required: true,
                type: {
                    name: "String"
                }
            },
            useHubGateway: {
                serializedName: "useHubGateway",
                type: {
                    name: "String"
                }
            },
            isGlobal: {
                serializedName: "isGlobal",
                type: {
                    name: "String"
                }
            },
            groupConnectivity: {
                serializedName: "groupConnectivity",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConfigurationGroup = {
    type: {
        name: "Composite",
        className: "ConfigurationGroup",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ActiveSecurityAdminRulesListResult = {
    type: {
        name: "Composite",
        className: "ActiveSecurityAdminRulesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ActiveBaseSecurityAdminRule"
                        }
                    }
                }
            },
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ActiveBaseSecurityAdminRule = {
    type: {
        name: "Composite",
        className: "ActiveBaseSecurityAdminRule",
        uberParent: "ActiveBaseSecurityAdminRule",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            commitTime: {
                serializedName: "commitTime",
                type: {
                    name: "DateTime"
                }
            },
            region: {
                serializedName: "region",
                type: {
                    name: "String"
                }
            },
            configurationDescription: {
                serializedName: "configurationDescription",
                type: {
                    name: "String"
                }
            },
            ruleCollectionDescription: {
                serializedName: "ruleCollectionDescription",
                type: {
                    name: "String"
                }
            },
            ruleCollectionAppliesToGroups: {
                serializedName: "ruleCollectionAppliesToGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkManagerSecurityGroupItem"
                        }
                    }
                }
            },
            ruleGroups: {
                serializedName: "ruleGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConfigurationGroup"
                        }
                    }
                }
            },
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerSecurityGroupItem = {
    type: {
        name: "Composite",
        className: "NetworkManagerSecurityGroupItem",
        modelProperties: {
            networkGroupId: {
                serializedName: "networkGroupId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChildResource = {
    type: {
        name: "Composite",
        className: "ChildResource",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerConnectionListResult = {
    type: {
        name: "Composite",
        className: "NetworkManagerConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkManagerConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivityConfigurationListResult = {
    type: {
        name: "Composite",
        className: "ConnectivityConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QueryRequestOptions = {
    type: {
        name: "Composite",
        className: "QueryRequestOptions",
        modelProperties: {
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerEffectiveConnectivityConfigurationListResult = {
    type: {
        name: "Composite",
        className: "NetworkManagerEffectiveConnectivityConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveConnectivityConfiguration"
                        }
                    }
                }
            },
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerEffectiveSecurityAdminRulesListResult = {
    type: {
        name: "Composite",
        className: "NetworkManagerEffectiveSecurityAdminRulesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveBaseSecurityAdminRule"
                        }
                    }
                }
            },
            skipToken: {
                serializedName: "skipToken",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveBaseSecurityAdminRule = {
    type: {
        name: "Composite",
        className: "EffectiveBaseSecurityAdminRule",
        uberParent: "EffectiveBaseSecurityAdminRule",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            configurationDescription: {
                serializedName: "configurationDescription",
                type: {
                    name: "String"
                }
            },
            ruleCollectionDescription: {
                serializedName: "ruleCollectionDescription",
                type: {
                    name: "String"
                }
            },
            ruleCollectionAppliesToGroups: {
                serializedName: "ruleCollectionAppliesToGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkManagerSecurityGroupItem"
                        }
                    }
                }
            },
            ruleGroups: {
                serializedName: "ruleGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConfigurationGroup"
                        }
                    }
                }
            },
            kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkGroupListResult = {
    type: {
        name: "Composite",
        className: "NetworkGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticMemberListResult = {
    type: {
        name: "Composite",
        className: "StaticMemberListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticMember"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ScopeConnectionListResult = {
    type: {
        name: "Composite",
        className: "ScopeConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ScopeConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityAdminConfigurationListResult = {
    type: {
        name: "Composite",
        className: "SecurityAdminConfigurationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityAdminConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdminRuleCollectionListResult = {
    type: {
        name: "Composite",
        className: "AdminRuleCollectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AdminRuleCollection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdminRuleListResult = {
    type: {
        name: "Composite",
        className: "AdminRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BaseAdminRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerNetworkInterfaceIpConfiguration = {
    type: {
        name: "Composite",
        className: "ContainerNetworkInterfaceIpConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkProfileListResult = {
    type: {
        name: "Composite",
        className: "NetworkProfileListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkProfile"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkSecurityGroupListResult = {
    type: {
        name: "Composite",
        className: "NetworkSecurityGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkSecurityGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityRuleListResult = {
    type: {
        name: "Composite",
        className: "SecurityRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualApplianceSkuProperties = {
    type: {
        name: "Composite",
        className: "VirtualApplianceSkuProperties",
        modelProperties: {
            vendor: {
                serializedName: "vendor",
                type: {
                    name: "String"
                }
            },
            bundledScaleUnit: {
                serializedName: "bundledScaleUnit",
                type: {
                    name: "String"
                }
            },
            marketPlaceVersion: {
                serializedName: "marketPlaceVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualApplianceNicProperties = {
    type: {
        name: "Composite",
        className: "VirtualApplianceNicProperties",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DelegationProperties = {
    type: {
        name: "Composite",
        className: "DelegationProperties",
        modelProperties: {
            serviceName: {
                serializedName: "serviceName",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PartnerManagedResourceProperties = {
    type: {
        name: "Composite",
        className: "PartnerManagedResourceProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            internalLoadBalancerId: {
                serializedName: "internalLoadBalancerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            standardLoadBalancerId: {
                serializedName: "standardLoadBalancerId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkVirtualApplianceListResult = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkVirtualAppliance"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Office365PolicyProperties = {
    type: {
        name: "Composite",
        className: "Office365PolicyProperties",
        modelProperties: {
            breakOutCategories: {
                serializedName: "breakOutCategories",
                type: {
                    name: "Composite",
                    className: "BreakOutCategoryPolicies"
                }
            }
        }
    }
};
const BreakOutCategoryPolicies = {
    type: {
        name: "Composite",
        className: "BreakOutCategoryPolicies",
        modelProperties: {
            allow: {
                serializedName: "allow",
                type: {
                    name: "Boolean"
                }
            },
            optimize: {
                serializedName: "optimize",
                type: {
                    name: "Boolean"
                }
            },
            default: {
                serializedName: "default",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const NetworkVirtualApplianceSiteListResult = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceSiteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualApplianceSite"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkVirtualApplianceSkuListResult = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceSkuListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkVirtualApplianceSku"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkVirtualApplianceSkuInstances = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceSkuInstances",
        modelProperties: {
            scaleUnit: {
                serializedName: "scaleUnit",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            instanceCount: {
                serializedName: "instanceCount",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const InboundSecurityRules = {
    type: {
        name: "Composite",
        className: "InboundSecurityRules",
        modelProperties: {
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            sourceAddressPrefix: {
                serializedName: "sourceAddressPrefix",
                type: {
                    name: "String"
                }
            },
            destinationPortRange: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "destinationPortRange",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorDetails"
                }
            }
        }
    }
};
const NetworkWatcherListResult = {
    type: {
        name: "Composite",
        className: "NetworkWatcherListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkWatcher"
                        }
                    }
                }
            }
        }
    }
};
const TopologyParameters = {
    type: {
        name: "Composite",
        className: "TopologyParameters",
        modelProperties: {
            targetResourceGroupName: {
                serializedName: "targetResourceGroupName",
                type: {
                    name: "String"
                }
            },
            targetVirtualNetwork: {
                serializedName: "targetVirtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            targetSubnet: {
                serializedName: "targetSubnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const Topology = {
    type: {
        name: "Composite",
        className: "Topology",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdDateTime: {
                serializedName: "createdDateTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastModified: {
                serializedName: "lastModified",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            resources: {
                serializedName: "resources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopologyResource"
                        }
                    }
                }
            }
        }
    }
};
const TopologyResource = {
    type: {
        name: "Composite",
        className: "TopologyResource",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            associations: {
                serializedName: "associations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TopologyAssociation"
                        }
                    }
                }
            }
        }
    }
};
const TopologyAssociation = {
    type: {
        name: "Composite",
        className: "TopologyAssociation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            associationType: {
                serializedName: "associationType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VerificationIPFlowParameters = {
    type: {
        name: "Composite",
        className: "VerificationIPFlowParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            direction: {
                serializedName: "direction",
                required: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                required: true,
                type: {
                    name: "String"
                }
            },
            localPort: {
                serializedName: "localPort",
                required: true,
                type: {
                    name: "String"
                }
            },
            remotePort: {
                serializedName: "remotePort",
                required: true,
                type: {
                    name: "String"
                }
            },
            localIPAddress: {
                serializedName: "localIPAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            remoteIPAddress: {
                serializedName: "remoteIPAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetNicResourceId: {
                serializedName: "targetNicResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VerificationIPFlowResult = {
    type: {
        name: "Composite",
        className: "VerificationIPFlowResult",
        modelProperties: {
            access: {
                serializedName: "access",
                type: {
                    name: "String"
                }
            },
            ruleName: {
                serializedName: "ruleName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NextHopParameters = {
    type: {
        name: "Composite",
        className: "NextHopParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            sourceIPAddress: {
                serializedName: "sourceIPAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinationIPAddress: {
                serializedName: "destinationIPAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            targetNicResourceId: {
                serializedName: "targetNicResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NextHopResult = {
    type: {
        name: "Composite",
        className: "NextHopResult",
        modelProperties: {
            nextHopType: {
                serializedName: "nextHopType",
                type: {
                    name: "String"
                }
            },
            nextHopIpAddress: {
                serializedName: "nextHopIpAddress",
                type: {
                    name: "String"
                }
            },
            routeTableId: {
                serializedName: "routeTableId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityGroupViewParameters = {
    type: {
        name: "Composite",
        className: "SecurityGroupViewParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityGroupViewResult = {
    type: {
        name: "Composite",
        className: "SecurityGroupViewResult",
        modelProperties: {
            networkInterfaces: {
                serializedName: "networkInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityGroupNetworkInterface"
                        }
                    }
                }
            }
        }
    }
};
const SecurityGroupNetworkInterface = {
    type: {
        name: "Composite",
        className: "SecurityGroupNetworkInterface",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            securityRuleAssociations: {
                serializedName: "securityRuleAssociations",
                type: {
                    name: "Composite",
                    className: "SecurityRuleAssociations"
                }
            }
        }
    }
};
const SecurityRuleAssociations = {
    type: {
        name: "Composite",
        className: "SecurityRuleAssociations",
        modelProperties: {
            networkInterfaceAssociation: {
                serializedName: "networkInterfaceAssociation",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceAssociation"
                }
            },
            subnetAssociation: {
                serializedName: "subnetAssociation",
                type: {
                    name: "Composite",
                    className: "SubnetAssociation"
                }
            },
            defaultSecurityRules: {
                serializedName: "defaultSecurityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            },
            effectiveSecurityRules: {
                serializedName: "effectiveSecurityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EffectiveNetworkSecurityRule"
                        }
                    }
                }
            }
        }
    }
};
const NetworkInterfaceAssociation = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceAssociation",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            securityRules: {
                serializedName: "securityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            }
        }
    }
};
const SubnetAssociation = {
    type: {
        name: "Composite",
        className: "SubnetAssociation",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            securityRules: {
                serializedName: "securityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            }
        }
    }
};
const PacketCapture = {
    type: {
        name: "Composite",
        className: "PacketCapture",
        modelProperties: {
            target: {
                serializedName: "properties.target",
                required: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "Composite",
                    className: "PacketCaptureMachineScope"
                }
            },
            targetType: {
                serializedName: "properties.targetType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureVM", "AzureVMSS"]
                }
            },
            bytesToCapturePerPacket: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.bytesToCapturePerPacket",
                type: {
                    name: "Number"
                }
            },
            totalBytesPerSession: {
                defaultValue: 1073741824,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.totalBytesPerSession",
                type: {
                    name: "Number"
                }
            },
            timeLimitInSeconds: {
                defaultValue: 18000,
                constraints: {
                    InclusiveMaximum: 18000,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.timeLimitInSeconds",
                type: {
                    name: "Number"
                }
            },
            storageLocation: {
                serializedName: "properties.storageLocation",
                type: {
                    name: "Composite",
                    className: "PacketCaptureStorageLocation"
                }
            },
            filters: {
                serializedName: "properties.filters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCaptureFilter"
                        }
                    }
                }
            }
        }
    }
};
const PacketCaptureParameters = {
    type: {
        name: "Composite",
        className: "PacketCaptureParameters",
        modelProperties: {
            target: {
                serializedName: "target",
                required: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "scope",
                type: {
                    name: "Composite",
                    className: "PacketCaptureMachineScope"
                }
            },
            targetType: {
                serializedName: "targetType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureVM", "AzureVMSS"]
                }
            },
            bytesToCapturePerPacket: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "bytesToCapturePerPacket",
                type: {
                    name: "Number"
                }
            },
            totalBytesPerSession: {
                defaultValue: 1073741824,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "totalBytesPerSession",
                type: {
                    name: "Number"
                }
            },
            timeLimitInSeconds: {
                defaultValue: 18000,
                constraints: {
                    InclusiveMaximum: 18000,
                    InclusiveMinimum: 0
                },
                serializedName: "timeLimitInSeconds",
                type: {
                    name: "Number"
                }
            },
            storageLocation: {
                serializedName: "storageLocation",
                type: {
                    name: "Composite",
                    className: "PacketCaptureStorageLocation"
                }
            },
            filters: {
                serializedName: "filters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCaptureFilter"
                        }
                    }
                }
            }
        }
    }
};
const PacketCaptureMachineScope = {
    type: {
        name: "Composite",
        className: "PacketCaptureMachineScope",
        modelProperties: {
            include: {
                serializedName: "include",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            exclude: {
                serializedName: "exclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PacketCaptureStorageLocation = {
    type: {
        name: "Composite",
        className: "PacketCaptureStorageLocation",
        modelProperties: {
            storageId: {
                serializedName: "storageId",
                type: {
                    name: "String"
                }
            },
            storagePath: {
                serializedName: "storagePath",
                type: {
                    name: "String"
                }
            },
            filePath: {
                serializedName: "filePath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PacketCaptureFilter = {
    type: {
        name: "Composite",
        className: "PacketCaptureFilter",
        modelProperties: {
            protocol: {
                defaultValue: "Any",
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            localIPAddress: {
                serializedName: "localIPAddress",
                type: {
                    name: "String"
                }
            },
            remoteIPAddress: {
                serializedName: "remoteIPAddress",
                type: {
                    name: "String"
                }
            },
            localPort: {
                serializedName: "localPort",
                type: {
                    name: "String"
                }
            },
            remotePort: {
                serializedName: "remotePort",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PacketCaptureResult = {
    type: {
        name: "Composite",
        className: "PacketCaptureResult",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "properties.target",
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "properties.scope",
                type: {
                    name: "Composite",
                    className: "PacketCaptureMachineScope"
                }
            },
            targetType: {
                serializedName: "properties.targetType",
                type: {
                    name: "Enum",
                    allowedValues: ["AzureVM", "AzureVMSS"]
                }
            },
            bytesToCapturePerPacket: {
                defaultValue: 0,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.bytesToCapturePerPacket",
                type: {
                    name: "Number"
                }
            },
            totalBytesPerSession: {
                defaultValue: 1073741824,
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.totalBytesPerSession",
                type: {
                    name: "Number"
                }
            },
            timeLimitInSeconds: {
                defaultValue: 18000,
                constraints: {
                    InclusiveMaximum: 18000,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.timeLimitInSeconds",
                type: {
                    name: "Number"
                }
            },
            storageLocation: {
                serializedName: "properties.storageLocation",
                type: {
                    name: "Composite",
                    className: "PacketCaptureStorageLocation"
                }
            },
            filters: {
                serializedName: "properties.filters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCaptureFilter"
                        }
                    }
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PacketCaptureQueryStatusResult = {
    type: {
        name: "Composite",
        className: "PacketCaptureQueryStatusResult",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            captureStartTime: {
                serializedName: "captureStartTime",
                type: {
                    name: "DateTime"
                }
            },
            packetCaptureStatus: {
                serializedName: "packetCaptureStatus",
                type: {
                    name: "String"
                }
            },
            stopReason: {
                serializedName: "stopReason",
                type: {
                    name: "String"
                }
            },
            packetCaptureError: {
                serializedName: "packetCaptureError",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PacketCaptureListResult = {
    type: {
        name: "Composite",
        className: "PacketCaptureListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PacketCaptureResult"
                        }
                    }
                }
            }
        }
    }
};
const TroubleshootingParameters = {
    type: {
        name: "Composite",
        className: "TroubleshootingParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            storageId: {
                serializedName: "properties.storageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            storagePath: {
                serializedName: "properties.storagePath",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TroubleshootingResult = {
    type: {
        name: "Composite",
        className: "TroubleshootingResult",
        modelProperties: {
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            results: {
                serializedName: "results",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TroubleshootingDetails"
                        }
                    }
                }
            }
        }
    }
};
const TroubleshootingDetails = {
    type: {
        name: "Composite",
        className: "TroubleshootingDetails",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            reasonType: {
                serializedName: "reasonType",
                type: {
                    name: "String"
                }
            },
            summary: {
                serializedName: "summary",
                type: {
                    name: "String"
                }
            },
            detail: {
                serializedName: "detail",
                type: {
                    name: "String"
                }
            },
            recommendedActions: {
                serializedName: "recommendedActions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TroubleshootingRecommendedActions"
                        }
                    }
                }
            }
        }
    }
};
const TroubleshootingRecommendedActions = {
    type: {
        name: "Composite",
        className: "TroubleshootingRecommendedActions",
        modelProperties: {
            actionId: {
                serializedName: "actionId",
                type: {
                    name: "String"
                }
            },
            actionText: {
                serializedName: "actionText",
                type: {
                    name: "String"
                }
            },
            actionUri: {
                serializedName: "actionUri",
                type: {
                    name: "String"
                }
            },
            actionUriText: {
                serializedName: "actionUriText",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const QueryTroubleshootingParameters = {
    type: {
        name: "Composite",
        className: "QueryTroubleshootingParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FlowLogInformation = {
    type: {
        name: "Composite",
        className: "FlowLogInformation",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            flowAnalyticsConfiguration: {
                serializedName: "flowAnalyticsConfiguration",
                type: {
                    name: "Composite",
                    className: "TrafficAnalyticsProperties"
                }
            },
            storageId: {
                serializedName: "properties.storageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            enabled: {
                serializedName: "properties.enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            retentionPolicy: {
                serializedName: "properties.retentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicyParameters"
                }
            },
            format: {
                serializedName: "properties.format",
                type: {
                    name: "Composite",
                    className: "FlowLogFormatParameters"
                }
            }
        }
    }
};
const FlowLogStatusParameters = {
    type: {
        name: "Composite",
        className: "FlowLogStatusParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivityParameters = {
    type: {
        name: "Composite",
        className: "ConnectivityParameters",
        modelProperties: {
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "ConnectivitySource"
                }
            },
            destination: {
                serializedName: "destination",
                type: {
                    name: "Composite",
                    className: "ConnectivityDestination"
                }
            },
            protocol: {
                serializedName: "protocol",
                type: {
                    name: "String"
                }
            },
            protocolConfiguration: {
                serializedName: "protocolConfiguration",
                type: {
                    name: "Composite",
                    className: "ProtocolConfiguration"
                }
            },
            preferredIPVersion: {
                serializedName: "preferredIPVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivitySource = {
    type: {
        name: "Composite",
        className: "ConnectivitySource",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectivityDestination = {
    type: {
        name: "Composite",
        className: "ConnectivityDestination",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ProtocolConfiguration = {
    type: {
        name: "Composite",
        className: "ProtocolConfiguration",
        modelProperties: {
            httpConfiguration: {
                serializedName: "HTTPConfiguration",
                type: {
                    name: "Composite",
                    className: "HttpConfiguration"
                }
            }
        }
    }
};
const HttpConfiguration = {
    type: {
        name: "Composite",
        className: "HttpConfiguration",
        modelProperties: {
            method: {
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            headers: {
                serializedName: "headers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HttpHeader"
                        }
                    }
                }
            },
            validStatusCodes: {
                serializedName: "validStatusCodes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const HttpHeader = {
    type: {
        name: "Composite",
        className: "HttpHeader",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivityInformation = {
    type: {
        name: "Composite",
        className: "ConnectivityInformation",
        modelProperties: {
            hops: {
                serializedName: "hops",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityHop"
                        }
                    }
                }
            },
            connectionStatus: {
                serializedName: "connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            avgLatencyInMs: {
                serializedName: "avgLatencyInMs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            minLatencyInMs: {
                serializedName: "minLatencyInMs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxLatencyInMs: {
                serializedName: "maxLatencyInMs",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            probesSent: {
                serializedName: "probesSent",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            probesFailed: {
                serializedName: "probesFailed",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectivityHop = {
    type: {
        name: "Composite",
        className: "ConnectivityHop",
        modelProperties: {
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextHopIds: {
                serializedName: "nextHopIds",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            previousHopIds: {
                serializedName: "previousHopIds",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            links: {
                serializedName: "links",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HopLink"
                        }
                    }
                }
            },
            previousLinks: {
                serializedName: "previousLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HopLink"
                        }
                    }
                }
            },
            issues: {
                serializedName: "issues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityIssue"
                        }
                    }
                }
            }
        }
    }
};
const HopLink = {
    type: {
        name: "Composite",
        className: "HopLink",
        modelProperties: {
            nextHopId: {
                serializedName: "nextHopId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            linkType: {
                serializedName: "linkType",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            issues: {
                serializedName: "issues",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityIssue"
                        }
                    }
                }
            },
            context: {
                serializedName: "context",
                readOnly: true,
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            resourceId: {
                serializedName: "resourceId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            roundTripTimeMin: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.roundTripTimeMin",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            roundTripTimeAvg: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.roundTripTimeAvg",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            roundTripTimeMax: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.roundTripTimeMax",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectivityIssue = {
    type: {
        name: "Composite",
        className: "ConnectivityIssue",
        modelProperties: {
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            severity: {
                serializedName: "severity",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            context: {
                serializedName: "context",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Dictionary",
                            value: { type: { name: "String" } }
                        }
                    }
                }
            }
        }
    }
};
const AzureReachabilityReportParameters = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReportParameters",
        modelProperties: {
            providerLocation: {
                serializedName: "providerLocation",
                type: {
                    name: "Composite",
                    className: "AzureReachabilityReportLocation"
                }
            },
            providers: {
                serializedName: "providers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            azureLocations: {
                serializedName: "azureLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            startTime: {
                serializedName: "startTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const AzureReachabilityReportLocation = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReportLocation",
        modelProperties: {
            country: {
                serializedName: "country",
                required: true,
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AzureReachabilityReport = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReport",
        modelProperties: {
            aggregationLevel: {
                serializedName: "aggregationLevel",
                required: true,
                type: {
                    name: "String"
                }
            },
            providerLocation: {
                serializedName: "providerLocation",
                type: {
                    name: "Composite",
                    className: "AzureReachabilityReportLocation"
                }
            },
            reachabilityReport: {
                serializedName: "reachabilityReport",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureReachabilityReportItem"
                        }
                    }
                }
            }
        }
    }
};
const AzureReachabilityReportItem = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReportItem",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            azureLocation: {
                serializedName: "azureLocation",
                type: {
                    name: "String"
                }
            },
            latencies: {
                serializedName: "latencies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureReachabilityReportLatencyInfo"
                        }
                    }
                }
            }
        }
    }
};
const AzureReachabilityReportLatencyInfo = {
    type: {
        name: "Composite",
        className: "AzureReachabilityReportLatencyInfo",
        modelProperties: {
            timeStamp: {
                serializedName: "timeStamp",
                type: {
                    name: "DateTime"
                }
            },
            score: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 1
                },
                serializedName: "score",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AvailableProvidersListParameters = {
    type: {
        name: "Composite",
        className: "AvailableProvidersListParameters",
        modelProperties: {
            azureLocations: {
                serializedName: "azureLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            country: {
                serializedName: "country",
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            city: {
                serializedName: "city",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailableProvidersList = {
    type: {
        name: "Composite",
        className: "AvailableProvidersList",
        modelProperties: {
            countries: {
                serializedName: "countries",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableProvidersListCountry"
                        }
                    }
                }
            }
        }
    }
};
const AvailableProvidersListCountry = {
    type: {
        name: "Composite",
        className: "AvailableProvidersListCountry",
        modelProperties: {
            countryName: {
                serializedName: "countryName",
                type: {
                    name: "String"
                }
            },
            providers: {
                serializedName: "providers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            states: {
                serializedName: "states",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableProvidersListState"
                        }
                    }
                }
            }
        }
    }
};
const AvailableProvidersListState = {
    type: {
        name: "Composite",
        className: "AvailableProvidersListState",
        modelProperties: {
            stateName: {
                serializedName: "stateName",
                type: {
                    name: "String"
                }
            },
            providers: {
                serializedName: "providers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            cities: {
                serializedName: "cities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailableProvidersListCity"
                        }
                    }
                }
            }
        }
    }
};
const AvailableProvidersListCity = {
    type: {
        name: "Composite",
        className: "AvailableProvidersListCity",
        modelProperties: {
            cityName: {
                serializedName: "cityName",
                type: {
                    name: "String"
                }
            },
            providers: {
                serializedName: "providers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const NetworkConfigurationDiagnosticParameters = {
    type: {
        name: "Composite",
        className: "NetworkConfigurationDiagnosticParameters",
        modelProperties: {
            targetResourceId: {
                serializedName: "targetResourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            verbosityLevel: {
                serializedName: "verbosityLevel",
                type: {
                    name: "String"
                }
            },
            profiles: {
                serializedName: "profiles",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkConfigurationDiagnosticProfile"
                        }
                    }
                }
            }
        }
    }
};
const NetworkConfigurationDiagnosticProfile = {
    type: {
        name: "Composite",
        className: "NetworkConfigurationDiagnosticProfile",
        modelProperties: {
            direction: {
                serializedName: "direction",
                required: true,
                type: {
                    name: "String"
                }
            },
            protocol: {
                serializedName: "protocol",
                required: true,
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "source",
                required: true,
                type: {
                    name: "String"
                }
            },
            destination: {
                serializedName: "destination",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinationPort: {
                serializedName: "destinationPort",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkConfigurationDiagnosticResponse = {
    type: {
        name: "Composite",
        className: "NetworkConfigurationDiagnosticResponse",
        modelProperties: {
            results: {
                serializedName: "results",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkConfigurationDiagnosticResult"
                        }
                    }
                }
            }
        }
    }
};
const NetworkConfigurationDiagnosticResult = {
    type: {
        name: "Composite",
        className: "NetworkConfigurationDiagnosticResult",
        modelProperties: {
            profile: {
                serializedName: "profile",
                type: {
                    name: "Composite",
                    className: "NetworkConfigurationDiagnosticProfile"
                }
            },
            networkSecurityGroupResult: {
                serializedName: "networkSecurityGroupResult",
                type: {
                    name: "Composite",
                    className: "NetworkSecurityGroupResult"
                }
            }
        }
    }
};
const NetworkSecurityGroupResult = {
    type: {
        name: "Composite",
        className: "NetworkSecurityGroupResult",
        modelProperties: {
            securityRuleAccessResult: {
                serializedName: "securityRuleAccessResult",
                type: {
                    name: "String"
                }
            },
            evaluatedNetworkSecurityGroups: {
                serializedName: "evaluatedNetworkSecurityGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "EvaluatedNetworkSecurityGroup"
                        }
                    }
                }
            }
        }
    }
};
const EvaluatedNetworkSecurityGroup = {
    type: {
        name: "Composite",
        className: "EvaluatedNetworkSecurityGroup",
        modelProperties: {
            networkSecurityGroupId: {
                serializedName: "networkSecurityGroupId",
                type: {
                    name: "String"
                }
            },
            appliedTo: {
                serializedName: "appliedTo",
                type: {
                    name: "String"
                }
            },
            matchedRule: {
                serializedName: "matchedRule",
                type: {
                    name: "Composite",
                    className: "MatchedRule"
                }
            },
            rulesEvaluationResult: {
                serializedName: "rulesEvaluationResult",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkSecurityRulesEvaluationResult"
                        }
                    }
                }
            }
        }
    }
};
const MatchedRule = {
    type: {
        name: "Composite",
        className: "MatchedRule",
        modelProperties: {
            ruleName: {
                serializedName: "ruleName",
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkSecurityRulesEvaluationResult = {
    type: {
        name: "Composite",
        className: "NetworkSecurityRulesEvaluationResult",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            protocolMatched: {
                serializedName: "protocolMatched",
                type: {
                    name: "Boolean"
                }
            },
            sourceMatched: {
                serializedName: "sourceMatched",
                type: {
                    name: "Boolean"
                }
            },
            sourcePortMatched: {
                serializedName: "sourcePortMatched",
                type: {
                    name: "Boolean"
                }
            },
            destinationMatched: {
                serializedName: "destinationMatched",
                type: {
                    name: "Boolean"
                }
            },
            destinationPortMatched: {
                serializedName: "destinationPortMatched",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ConnectionMonitor = {
    type: {
        name: "Composite",
        className: "ConnectionMonitor",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            source: {
                serializedName: "properties.source",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorSource"
                }
            },
            destination: {
                serializedName: "properties.destination",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorDestination"
                }
            },
            autoStart: {
                defaultValue: true,
                serializedName: "properties.autoStart",
                type: {
                    name: "Boolean"
                }
            },
            monitoringIntervalInSeconds: {
                defaultValue: 60,
                constraints: {
                    InclusiveMaximum: 1800,
                    InclusiveMinimum: 30
                },
                serializedName: "properties.monitoringIntervalInSeconds",
                type: {
                    name: "Number"
                }
            },
            endpoints: {
                serializedName: "properties.endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpoint"
                        }
                    }
                }
            },
            testConfigurations: {
                serializedName: "properties.testConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestConfiguration"
                        }
                    }
                }
            },
            testGroups: {
                serializedName: "properties.testGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestGroup"
                        }
                    }
                }
            },
            outputs: {
                serializedName: "properties.outputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorOutput"
                        }
                    }
                }
            },
            notes: {
                serializedName: "properties.notes",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorParameters = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorParameters",
        modelProperties: {
            source: {
                serializedName: "source",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorSource"
                }
            },
            destination: {
                serializedName: "destination",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorDestination"
                }
            },
            autoStart: {
                defaultValue: true,
                serializedName: "autoStart",
                type: {
                    name: "Boolean"
                }
            },
            monitoringIntervalInSeconds: {
                defaultValue: 60,
                constraints: {
                    InclusiveMaximum: 1800,
                    InclusiveMinimum: 30
                },
                serializedName: "monitoringIntervalInSeconds",
                type: {
                    name: "Number"
                }
            },
            endpoints: {
                serializedName: "endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpoint"
                        }
                    }
                }
            },
            testConfigurations: {
                serializedName: "testConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestConfiguration"
                        }
                    }
                }
            },
            testGroups: {
                serializedName: "testGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestGroup"
                        }
                    }
                }
            },
            outputs: {
                serializedName: "outputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorOutput"
                        }
                    }
                }
            },
            notes: {
                serializedName: "notes",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorSource = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorSource",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectionMonitorDestination = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorDestination",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectionMonitorEndpoint = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpoint",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            },
            filter: {
                serializedName: "filter",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorEndpointFilter"
                }
            },
            scope: {
                serializedName: "scope",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorEndpointScope"
                }
            },
            coverageLevel: {
                serializedName: "coverageLevel",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorEndpointFilter = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpointFilter",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            items: {
                serializedName: "items",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpointFilterItem"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionMonitorEndpointFilterItem = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpointFilterItem",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorEndpointScope = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpointScope",
        modelProperties: {
            include: {
                serializedName: "include",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpointScopeItem"
                        }
                    }
                }
            },
            exclude: {
                serializedName: "exclude",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpointScopeItem"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionMonitorEndpointScopeItem = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorEndpointScopeItem",
        modelProperties: {
            address: {
                serializedName: "address",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorTestConfiguration = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorTestConfiguration",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            testFrequencySec: {
                serializedName: "testFrequencySec",
                type: {
                    name: "Number"
                }
            },
            protocol: {
                serializedName: "protocol",
                required: true,
                type: {
                    name: "String"
                }
            },
            preferredIPVersion: {
                serializedName: "preferredIPVersion",
                type: {
                    name: "String"
                }
            },
            httpConfiguration: {
                serializedName: "httpConfiguration",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorHttpConfiguration"
                }
            },
            tcpConfiguration: {
                serializedName: "tcpConfiguration",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorTcpConfiguration"
                }
            },
            icmpConfiguration: {
                serializedName: "icmpConfiguration",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorIcmpConfiguration"
                }
            },
            successThreshold: {
                serializedName: "successThreshold",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorSuccessThreshold"
                }
            }
        }
    }
};
const ConnectionMonitorHttpConfiguration = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorHttpConfiguration",
        modelProperties: {
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            },
            method: {
                serializedName: "method",
                type: {
                    name: "String"
                }
            },
            path: {
                serializedName: "path",
                type: {
                    name: "String"
                }
            },
            requestHeaders: {
                serializedName: "requestHeaders",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HttpHeader"
                        }
                    }
                }
            },
            validStatusCodeRanges: {
                serializedName: "validStatusCodeRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            preferHttps: {
                serializedName: "preferHTTPS",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ConnectionMonitorTcpConfiguration = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorTcpConfiguration",
        modelProperties: {
            port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            },
            disableTraceRoute: {
                serializedName: "disableTraceRoute",
                type: {
                    name: "Boolean"
                }
            },
            destinationPortBehavior: {
                serializedName: "destinationPortBehavior",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorIcmpConfiguration = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorIcmpConfiguration",
        modelProperties: {
            disableTraceRoute: {
                serializedName: "disableTraceRoute",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ConnectionMonitorSuccessThreshold = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorSuccessThreshold",
        modelProperties: {
            checksFailedPercent: {
                serializedName: "checksFailedPercent",
                type: {
                    name: "Number"
                }
            },
            roundTripTimeMs: {
                serializedName: "roundTripTimeMs",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ConnectionMonitorTestGroup = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorTestGroup",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            disable: {
                serializedName: "disable",
                type: {
                    name: "Boolean"
                }
            },
            testConfigurations: {
                serializedName: "testConfigurations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            sources: {
                serializedName: "sources",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            destinations: {
                serializedName: "destinations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionMonitorOutput = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorOutput",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            workspaceSettings: {
                serializedName: "workspaceSettings",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorWorkspaceSettings"
                }
            }
        }
    }
};
const ConnectionMonitorWorkspaceSettings = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorWorkspaceSettings",
        modelProperties: {
            workspaceResourceId: {
                serializedName: "workspaceResourceId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorResult = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorResult",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            },
            source: {
                serializedName: "properties.source",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorSource"
                }
            },
            destination: {
                serializedName: "properties.destination",
                type: {
                    name: "Composite",
                    className: "ConnectionMonitorDestination"
                }
            },
            autoStart: {
                defaultValue: true,
                serializedName: "properties.autoStart",
                type: {
                    name: "Boolean"
                }
            },
            monitoringIntervalInSeconds: {
                defaultValue: 60,
                constraints: {
                    InclusiveMaximum: 1800,
                    InclusiveMinimum: 30
                },
                serializedName: "properties.monitoringIntervalInSeconds",
                type: {
                    name: "Number"
                }
            },
            endpoints: {
                serializedName: "properties.endpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorEndpoint"
                        }
                    }
                }
            },
            testConfigurations: {
                serializedName: "properties.testConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestConfiguration"
                        }
                    }
                }
            },
            testGroups: {
                serializedName: "properties.testGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorTestGroup"
                        }
                    }
                }
            },
            outputs: {
                serializedName: "properties.outputs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorOutput"
                        }
                    }
                }
            },
            notes: {
                serializedName: "properties.notes",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "properties.startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            monitoringStatus: {
                serializedName: "properties.monitoringStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            connectionMonitorType: {
                serializedName: "properties.connectionMonitorType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionMonitorQueryResult = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorQueryResult",
        modelProperties: {
            sourceStatus: {
                serializedName: "sourceStatus",
                type: {
                    name: "String"
                }
            },
            states: {
                serializedName: "states",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionStateSnapshot"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionStateSnapshot = {
    type: {
        name: "Composite",
        className: "ConnectionStateSnapshot",
        modelProperties: {
            connectionState: {
                serializedName: "connectionState",
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            },
            evaluationState: {
                serializedName: "evaluationState",
                type: {
                    name: "String"
                }
            },
            avgLatencyInMs: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "avgLatencyInMs",
                type: {
                    name: "Number"
                }
            },
            minLatencyInMs: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "minLatencyInMs",
                type: {
                    name: "Number"
                }
            },
            maxLatencyInMs: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "maxLatencyInMs",
                type: {
                    name: "Number"
                }
            },
            probesSent: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "probesSent",
                type: {
                    name: "Number"
                }
            },
            probesFailed: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "probesFailed",
                type: {
                    name: "Number"
                }
            },
            hops: {
                serializedName: "hops",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityHop"
                        }
                    }
                }
            }
        }
    }
};
const ConnectionMonitorListResult = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectionMonitorResult"
                        }
                    }
                }
            }
        }
    }
};
const FlowLogListResult = {
    type: {
        name: "Composite",
        className: "FlowLogListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FlowLog"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationListResult = {
    type: {
        name: "Composite",
        className: "OperationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Operation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Operation = {
    type: {
        name: "Composite",
        className: "Operation",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            display: {
                serializedName: "display",
                type: {
                    name: "Composite",
                    className: "OperationDisplay"
                }
            },
            origin: {
                serializedName: "origin",
                type: {
                    name: "String"
                }
            },
            serviceSpecification: {
                serializedName: "properties.serviceSpecification",
                type: {
                    name: "Composite",
                    className: "OperationPropertiesFormatServiceSpecification"
                }
            }
        }
    }
};
const OperationDisplay = {
    type: {
        name: "Composite",
        className: "OperationDisplay",
        modelProperties: {
            provider: {
                serializedName: "provider",
                type: {
                    name: "String"
                }
            },
            resource: {
                serializedName: "resource",
                type: {
                    name: "String"
                }
            },
            operation: {
                serializedName: "operation",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const OperationPropertiesFormatServiceSpecification = {
    type: {
        name: "Composite",
        className: "OperationPropertiesFormatServiceSpecification",
        modelProperties: {
            metricSpecifications: {
                serializedName: "metricSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MetricSpecification"
                        }
                    }
                }
            },
            logSpecifications: {
                serializedName: "logSpecifications",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LogSpecification"
                        }
                    }
                }
            }
        }
    }
};
const MetricSpecification = {
    type: {
        name: "Composite",
        className: "MetricSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            displayDescription: {
                serializedName: "displayDescription",
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                type: {
                    name: "String"
                }
            },
            aggregationType: {
                serializedName: "aggregationType",
                type: {
                    name: "String"
                }
            },
            availabilities: {
                serializedName: "availabilities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Availability"
                        }
                    }
                }
            },
            enableRegionalMdmAccount: {
                serializedName: "enableRegionalMdmAccount",
                type: {
                    name: "Boolean"
                }
            },
            fillGapWithZero: {
                serializedName: "fillGapWithZero",
                type: {
                    name: "Boolean"
                }
            },
            metricFilterPattern: {
                serializedName: "metricFilterPattern",
                type: {
                    name: "String"
                }
            },
            dimensions: {
                serializedName: "dimensions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Dimension"
                        }
                    }
                }
            },
            isInternal: {
                serializedName: "isInternal",
                type: {
                    name: "Boolean"
                }
            },
            sourceMdmAccount: {
                serializedName: "sourceMdmAccount",
                type: {
                    name: "String"
                }
            },
            sourceMdmNamespace: {
                serializedName: "sourceMdmNamespace",
                type: {
                    name: "String"
                }
            },
            resourceIdDimensionNameOverride: {
                serializedName: "resourceIdDimensionNameOverride",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Availability = {
    type: {
        name: "Composite",
        className: "Availability",
        modelProperties: {
            timeGrain: {
                serializedName: "timeGrain",
                type: {
                    name: "String"
                }
            },
            retention: {
                serializedName: "retention",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Dimension = {
    type: {
        name: "Composite",
        className: "Dimension",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            internalName: {
                serializedName: "internalName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LogSpecification = {
    type: {
        name: "Composite",
        className: "LogSpecification",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            blobDuration: {
                serializedName: "blobDuration",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpoint"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailablePrivateEndpointTypesResult = {
    type: {
        name: "Composite",
        className: "AvailablePrivateEndpointTypesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AvailablePrivateEndpointType"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AvailablePrivateEndpointType = {
    type: {
        name: "Composite",
        className: "AvailablePrivateEndpointType",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            resourceName: {
                serializedName: "resourceName",
                type: {
                    name: "String"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateDnsZoneConfig = {
    type: {
        name: "Composite",
        className: "PrivateDnsZoneConfig",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            privateDnsZoneId: {
                serializedName: "properties.privateDnsZoneId",
                type: {
                    name: "String"
                }
            },
            recordSets: {
                serializedName: "properties.recordSets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RecordSet"
                        }
                    }
                }
            }
        }
    }
};
const RecordSet = {
    type: {
        name: "Composite",
        className: "RecordSet",
        modelProperties: {
            recordType: {
                serializedName: "recordType",
                type: {
                    name: "String"
                }
            },
            recordSetName: {
                serializedName: "recordSetName",
                type: {
                    name: "String"
                }
            },
            fqdn: {
                serializedName: "fqdn",
                type: {
                    name: "String"
                }
            },
            provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ttl: {
                serializedName: "ttl",
                type: {
                    name: "Number"
                }
            },
            ipAddresses: {
                serializedName: "ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const PrivateDnsZoneGroupListResult = {
    type: {
        name: "Composite",
        className: "PrivateDnsZoneGroupListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateDnsZoneGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceListResult = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkService"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateEndpointConnectionListResult = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckPrivateLinkServiceVisibilityRequest = {
    type: {
        name: "Composite",
        className: "CheckPrivateLinkServiceVisibilityRequest",
        modelProperties: {
            privateLinkServiceAlias: {
                serializedName: "privateLinkServiceAlias",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrivateLinkServiceVisibility = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceVisibility",
        modelProperties: {
            visible: {
                serializedName: "visible",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AutoApprovedPrivateLinkServicesResult = {
    type: {
        name: "Composite",
        className: "AutoApprovedPrivateLinkServicesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AutoApprovedPrivateLinkService"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AutoApprovedPrivateLinkService = {
    type: {
        name: "Composite",
        className: "AutoApprovedPrivateLinkService",
        modelProperties: {
            privateLinkService: {
                serializedName: "privateLinkService",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIpDdosProtectionStatusResult = {
    type: {
        name: "Composite",
        className: "PublicIpDdosProtectionStatusResult",
        modelProperties: {
            publicIpAddressId: {
                serializedName: "publicIpAddressId",
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                type: {
                    name: "String"
                }
            },
            isWorkloadProtected: {
                serializedName: "isWorkloadProtected",
                type: {
                    name: "String"
                }
            },
            ddosProtectionPlanId: {
                serializedName: "ddosProtectionPlanId",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPPrefixSku = {
    type: {
        name: "Composite",
        className: "PublicIPPrefixSku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ReferencedPublicIpAddress = {
    type: {
        name: "Composite",
        className: "ReferencedPublicIpAddress",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPPrefixListResult = {
    type: {
        name: "Composite",
        className: "PublicIPPrefixListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PublicIPPrefix"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteFilterListResult = {
    type: {
        name: "Composite",
        className: "RouteFilterListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteFilter"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteFilterRuleListResult = {
    type: {
        name: "Composite",
        className: "RouteFilterRuleListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteFilterRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteTableListResult = {
    type: {
        name: "Composite",
        className: "RouteTableListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteListResult = {
    type: {
        name: "Composite",
        className: "RouteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Route"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityPartnerProviderListResult = {
    type: {
        name: "Composite",
        className: "SecurityPartnerProviderListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityPartnerProvider"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BgpServiceCommunityListResult = {
    type: {
        name: "Composite",
        className: "BgpServiceCommunityListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BgpServiceCommunity"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BGPCommunity = {
    type: {
        name: "Composite",
        className: "BGPCommunity",
        modelProperties: {
            serviceSupportedRegion: {
                serializedName: "serviceSupportedRegion",
                type: {
                    name: "String"
                }
            },
            communityName: {
                serializedName: "communityName",
                type: {
                    name: "String"
                }
            },
            communityValue: {
                serializedName: "communityValue",
                type: {
                    name: "String"
                }
            },
            communityPrefixes: {
                serializedName: "communityPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isAuthorizedToUse: {
                serializedName: "isAuthorizedToUse",
                type: {
                    name: "Boolean"
                }
            },
            serviceGroup: {
                serializedName: "serviceGroup",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceEndpointPolicyListResult = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceEndpointPolicyDefinitionListResult = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPolicyDefinitionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPolicyDefinition"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceTagsListResult = {
    type: {
        name: "Composite",
        className: "ServiceTagsListResult",
        modelProperties: {
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            changeNumber: {
                serializedName: "changeNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            cloud: {
                serializedName: "cloud",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            values: {
                serializedName: "values",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceTagInformation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceTagInformation = {
    type: {
        name: "Composite",
        className: "ServiceTagInformation",
        modelProperties: {
            properties: {
                serializedName: "properties",
                type: {
                    name: "Composite",
                    className: "ServiceTagInformationPropertiesFormat"
                }
            },
            name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            serviceTagChangeNumber: {
                serializedName: "serviceTagChangeNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceTagInformationPropertiesFormat = {
    type: {
        name: "Composite",
        className: "ServiceTagInformationPropertiesFormat",
        modelProperties: {
            changeNumber: {
                serializedName: "changeNumber",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            region: {
                serializedName: "region",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            systemService: {
                serializedName: "systemService",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            addressPrefixes: {
                serializedName: "addressPrefixes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceTagInformationListResult = {
    type: {
        name: "Composite",
        className: "ServiceTagInformationListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceTagInformation"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const UsagesListResult = {
    type: {
        name: "Composite",
        className: "UsagesListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Usage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Usage = {
    type: {
        name: "Composite",
        className: "Usage",
        modelProperties: {
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            unit: {
                serializedName: "unit",
                required: true,
                type: {
                    name: "String"
                }
            },
            currentValue: {
                serializedName: "currentValue",
                required: true,
                type: {
                    name: "Number"
                }
            },
            limit: {
                serializedName: "limit",
                required: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "UsageName"
                }
            }
        }
    }
};
const UsageName = {
    type: {
        name: "Composite",
        className: "UsageName",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            localizedValue: {
                serializedName: "localizedValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddressSpace = {
    type: {
        name: "Composite",
        className: "AddressSpace",
        modelProperties: {
            addressPrefixes: {
                serializedName: "addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const DhcpOptions = {
    type: {
        name: "Composite",
        className: "DhcpOptions",
        modelProperties: {
            dnsServers: {
                serializedName: "dnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualNetworkBgpCommunities = {
    type: {
        name: "Composite",
        className: "VirtualNetworkBgpCommunities",
        modelProperties: {
            virtualNetworkCommunity: {
                serializedName: "virtualNetworkCommunity",
                required: true,
                type: {
                    name: "String"
                }
            },
            regionalCommunity: {
                serializedName: "regionalCommunity",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkEncryption = {
    type: {
        name: "Composite",
        className: "VirtualNetworkEncryption",
        modelProperties: {
            enabled: {
                serializedName: "enabled",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            enforcement: {
                serializedName: "enforcement",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetwork"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PrepareNetworkPoliciesRequest = {
    type: {
        name: "Composite",
        className: "PrepareNetworkPoliciesRequest",
        modelProperties: {
            serviceName: {
                serializedName: "serviceName",
                type: {
                    name: "String"
                }
            },
            networkIntentPolicyConfigurations: {
                serializedName: "networkIntentPolicyConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkIntentPolicyConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const NetworkIntentPolicyConfiguration = {
    type: {
        name: "Composite",
        className: "NetworkIntentPolicyConfiguration",
        modelProperties: {
            networkIntentPolicyName: {
                serializedName: "networkIntentPolicyName",
                type: {
                    name: "String"
                }
            },
            sourceNetworkIntentPolicy: {
                serializedName: "sourceNetworkIntentPolicy",
                type: {
                    name: "Composite",
                    className: "NetworkIntentPolicy"
                }
            }
        }
    }
};
const UnprepareNetworkPoliciesRequest = {
    type: {
        name: "Composite",
        className: "UnprepareNetworkPoliciesRequest",
        modelProperties: {
            serviceName: {
                serializedName: "serviceName",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ResourceNavigationLinksListResult = {
    type: {
        name: "Composite",
        className: "ResourceNavigationLinksListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceNavigationLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ServiceAssociationLinksListResult = {
    type: {
        name: "Composite",
        className: "ServiceAssociationLinksListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceAssociationLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SubnetListResult = {
    type: {
        name: "Composite",
        className: "SubnetListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkPeeringListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkPeeringListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkPeering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const IPAddressAvailabilityResult = {
    type: {
        name: "Composite",
        className: "IPAddressAvailabilityResult",
        modelProperties: {
            available: {
                serializedName: "available",
                type: {
                    name: "Boolean"
                }
            },
            availableIPAddresses: {
                serializedName: "availableIPAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            isPlatformReserved: {
                serializedName: "isPlatformReserved",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const VirtualNetworkListUsageResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkListUsageResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkUsage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkUsage = {
    type: {
        name: "Composite",
        className: "VirtualNetworkUsage",
        modelProperties: {
            currentValue: {
                serializedName: "currentValue",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            id: {
                serializedName: "id",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            limit: {
                serializedName: "limit",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkUsageName"
                }
            },
            unit: {
                serializedName: "unit",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkUsageName = {
    type: {
        name: "Composite",
        className: "VirtualNetworkUsageName",
        modelProperties: {
            localizedValue: {
                serializedName: "localizedValue",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkDdosProtectionStatusResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkDdosProtectionStatusResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PublicIpDdosProtectionStatusResult"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkGatewaySku = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewaySku",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tier: {
                serializedName: "tier",
                type: {
                    name: "String"
                }
            },
            capacity: {
                serializedName: "capacity",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VpnClientConfiguration = {
    type: {
        name: "Composite",
        className: "VpnClientConfiguration",
        modelProperties: {
            vpnClientAddressPool: {
                serializedName: "vpnClientAddressPool",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            },
            vpnClientRootCertificates: {
                serializedName: "vpnClientRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnClientRootCertificate"
                        }
                    }
                }
            },
            vpnClientRevokedCertificates: {
                serializedName: "vpnClientRevokedCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnClientRevokedCertificate"
                        }
                    }
                }
            },
            vpnClientProtocols: {
                serializedName: "vpnClientProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vpnAuthenticationTypes: {
                serializedName: "vpnAuthenticationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            vpnClientIpsecPolicies: {
                serializedName: "vpnClientIpsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            },
            radiusServerAddress: {
                serializedName: "radiusServerAddress",
                type: {
                    name: "String"
                }
            },
            radiusServerSecret: {
                serializedName: "radiusServerSecret",
                type: {
                    name: "String"
                }
            },
            radiusServers: {
                serializedName: "radiusServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RadiusServer"
                        }
                    }
                }
            },
            aadTenant: {
                serializedName: "aadTenant",
                type: {
                    name: "String"
                }
            },
            aadAudience: {
                serializedName: "aadAudience",
                type: {
                    name: "String"
                }
            },
            aadIssuer: {
                serializedName: "aadIssuer",
                type: {
                    name: "String"
                }
            },
            vngClientConnectionConfigurations: {
                serializedName: "vngClientConnectionConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VngClientConnectionConfiguration"
                        }
                    }
                }
            }
        }
    }
};
const IpsecPolicy = {
    type: {
        name: "Composite",
        className: "IpsecPolicy",
        modelProperties: {
            saLifeTimeSeconds: {
                serializedName: "saLifeTimeSeconds",
                required: true,
                type: {
                    name: "Number"
                }
            },
            saDataSizeKilobytes: {
                serializedName: "saDataSizeKilobytes",
                required: true,
                type: {
                    name: "Number"
                }
            },
            ipsecEncryption: {
                serializedName: "ipsecEncryption",
                required: true,
                type: {
                    name: "String"
                }
            },
            ipsecIntegrity: {
                serializedName: "ipsecIntegrity",
                required: true,
                type: {
                    name: "String"
                }
            },
            ikeEncryption: {
                serializedName: "ikeEncryption",
                required: true,
                type: {
                    name: "String"
                }
            },
            ikeIntegrity: {
                serializedName: "ikeIntegrity",
                required: true,
                type: {
                    name: "String"
                }
            },
            dhGroup: {
                serializedName: "dhGroup",
                required: true,
                type: {
                    name: "String"
                }
            },
            pfsGroup: {
                serializedName: "pfsGroup",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RadiusServer = {
    type: {
        name: "Composite",
        className: "RadiusServer",
        modelProperties: {
            radiusServerAddress: {
                serializedName: "radiusServerAddress",
                required: true,
                type: {
                    name: "String"
                }
            },
            radiusServerScore: {
                serializedName: "radiusServerScore",
                type: {
                    name: "Number"
                }
            },
            radiusServerSecret: {
                serializedName: "radiusServerSecret",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkGatewayPolicyGroupMember = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayPolicyGroupMember",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            attributeType: {
                serializedName: "attributeType",
                type: {
                    name: "String"
                }
            },
            attributeValue: {
                serializedName: "attributeValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const BgpSettings = {
    type: {
        name: "Composite",
        className: "BgpSettings",
        modelProperties: {
            asn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "asn",
                type: {
                    name: "Number"
                }
            },
            bgpPeeringAddress: {
                serializedName: "bgpPeeringAddress",
                type: {
                    name: "String"
                }
            },
            peerWeight: {
                serializedName: "peerWeight",
                type: {
                    name: "Number"
                }
            },
            bgpPeeringAddresses: {
                serializedName: "bgpPeeringAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPConfigurationBgpPeeringAddress"
                        }
                    }
                }
            }
        }
    }
};
const IPConfigurationBgpPeeringAddress = {
    type: {
        name: "Composite",
        className: "IPConfigurationBgpPeeringAddress",
        modelProperties: {
            ipconfigurationId: {
                serializedName: "ipconfigurationId",
                type: {
                    name: "String"
                }
            },
            defaultBgpIpAddresses: {
                serializedName: "defaultBgpIpAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            customBgpIpAddresses: {
                serializedName: "customBgpIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            tunnelIpAddresses: {
                serializedName: "tunnelIpAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VpnNatRuleMapping = {
    type: {
        name: "Composite",
        className: "VpnNatRuleMapping",
        modelProperties: {
            addressSpace: {
                serializedName: "addressSpace",
                type: {
                    name: "String"
                }
            },
            portRange: {
                serializedName: "portRange",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkGatewayListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkGatewayListConnectionsResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayListConnectionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayConnectionListEntity"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkConnectionGatewayReference = {
    type: {
        name: "Composite",
        className: "VirtualNetworkConnectionGatewayReference",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TunnelConnectionHealth = {
    type: {
        name: "Composite",
        className: "TunnelConnectionHealth",
        modelProperties: {
            tunnel: {
                serializedName: "tunnel",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            connectionStatus: {
                serializedName: "connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            ingressBytesTransferred: {
                serializedName: "ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            egressBytesTransferred: {
                serializedName: "egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            lastConnectionEstablishedUtcTime: {
                serializedName: "lastConnectionEstablishedUtcTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GatewayCustomBgpIpAddressIpConfiguration = {
    type: {
        name: "Composite",
        className: "GatewayCustomBgpIpAddressIpConfiguration",
        modelProperties: {
            ipConfigurationId: {
                serializedName: "ipConfigurationId",
                required: true,
                type: {
                    name: "String"
                }
            },
            customBgpIpAddress: {
                serializedName: "customBgpIpAddress",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TrafficSelectorPolicy = {
    type: {
        name: "Composite",
        className: "TrafficSelectorPolicy",
        modelProperties: {
            localAddressRanges: {
                serializedName: "localAddressRanges",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            remoteAddressRanges: {
                serializedName: "remoteAddressRanges",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VpnClientParameters = {
    type: {
        name: "Composite",
        className: "VpnClientParameters",
        modelProperties: {
            processorArchitecture: {
                serializedName: "processorArchitecture",
                type: {
                    name: "String"
                }
            },
            authenticationMethod: {
                serializedName: "authenticationMethod",
                type: {
                    name: "String"
                }
            },
            radiusServerAuthCertificate: {
                serializedName: "radiusServerAuthCertificate",
                type: {
                    name: "String"
                }
            },
            clientRootCertificates: {
                serializedName: "clientRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const BgpPeerStatusListResult = {
    type: {
        name: "Composite",
        className: "BgpPeerStatusListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BgpPeerStatus"
                        }
                    }
                }
            }
        }
    }
};
const BgpPeerStatus = {
    type: {
        name: "Composite",
        className: "BgpPeerStatus",
        modelProperties: {
            localAddress: {
                serializedName: "localAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            neighbor: {
                serializedName: "neighbor",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            asn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "asn",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            state: {
                serializedName: "state",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            connectedDuration: {
                serializedName: "connectedDuration",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            routesReceived: {
                serializedName: "routesReceived",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            messagesSent: {
                serializedName: "messagesSent",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            messagesReceived: {
                serializedName: "messagesReceived",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const GatewayRouteListResult = {
    type: {
        name: "Composite",
        className: "GatewayRouteListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayRoute"
                        }
                    }
                }
            }
        }
    }
};
const GatewayRoute = {
    type: {
        name: "Composite",
        className: "GatewayRoute",
        modelProperties: {
            localAddress: {
                serializedName: "localAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            network: {
                serializedName: "network",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextHop: {
                serializedName: "nextHop",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sourcePeer: {
                serializedName: "sourcePeer",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            asPath: {
                serializedName: "asPath",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            weight: {
                serializedName: "weight",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VpnClientIPsecParameters = {
    type: {
        name: "Composite",
        className: "VpnClientIPsecParameters",
        modelProperties: {
            saLifeTimeSeconds: {
                serializedName: "saLifeTimeSeconds",
                required: true,
                type: {
                    name: "Number"
                }
            },
            saDataSizeKilobytes: {
                serializedName: "saDataSizeKilobytes",
                required: true,
                type: {
                    name: "Number"
                }
            },
            ipsecEncryption: {
                serializedName: "ipsecEncryption",
                required: true,
                type: {
                    name: "String"
                }
            },
            ipsecIntegrity: {
                serializedName: "ipsecIntegrity",
                required: true,
                type: {
                    name: "String"
                }
            },
            ikeEncryption: {
                serializedName: "ikeEncryption",
                required: true,
                type: {
                    name: "String"
                }
            },
            ikeIntegrity: {
                serializedName: "ikeIntegrity",
                required: true,
                type: {
                    name: "String"
                }
            },
            dhGroup: {
                serializedName: "dhGroup",
                required: true,
                type: {
                    name: "String"
                }
            },
            pfsGroup: {
                serializedName: "pfsGroup",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnDeviceScriptParameters = {
    type: {
        name: "Composite",
        className: "VpnDeviceScriptParameters",
        modelProperties: {
            vendor: {
                serializedName: "vendor",
                type: {
                    name: "String"
                }
            },
            deviceFamily: {
                serializedName: "deviceFamily",
                type: {
                    name: "String"
                }
            },
            firmwareVersion: {
                serializedName: "firmwareVersion",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnPacketCaptureStartParameters = {
    type: {
        name: "Composite",
        className: "VpnPacketCaptureStartParameters",
        modelProperties: {
            filterData: {
                serializedName: "filterData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnPacketCaptureStopParameters = {
    type: {
        name: "Composite",
        className: "VpnPacketCaptureStopParameters",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkGatewayConnectionListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayConnectionListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectionResetSharedKey = {
    type: {
        name: "Composite",
        className: "ConnectionResetSharedKey",
        modelProperties: {
            keyLength: {
                constraints: {
                    InclusiveMaximum: 128,
                    InclusiveMinimum: 1
                },
                serializedName: "keyLength",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const LocalNetworkGatewayListResult = {
    type: {
        name: "Composite",
        className: "LocalNetworkGatewayListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LocalNetworkGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnClientConnectionHealthDetailListResult = {
    type: {
        name: "Composite",
        className: "VpnClientConnectionHealthDetailListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnClientConnectionHealthDetail"
                        }
                    }
                }
            }
        }
    }
};
const VpnClientConnectionHealthDetail = {
    type: {
        name: "Composite",
        className: "VpnClientConnectionHealthDetail",
        modelProperties: {
            vpnConnectionId: {
                serializedName: "vpnConnectionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vpnConnectionDuration: {
                serializedName: "vpnConnectionDuration",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            vpnConnectionTime: {
                serializedName: "vpnConnectionTime",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            vpnUserName: {
                serializedName: "vpnUserName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            maxBandwidth: {
                serializedName: "maxBandwidth",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            egressPacketsTransferred: {
                serializedName: "egressPacketsTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            egressBytesTransferred: {
                serializedName: "egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            ingressPacketsTransferred: {
                serializedName: "ingressPacketsTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            ingressBytesTransferred: {
                serializedName: "ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            maxPacketsPerSecond: {
                serializedName: "maxPacketsPerSecond",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const P2SVpnConnectionRequest = {
    type: {
        name: "Composite",
        className: "P2SVpnConnectionRequest",
        modelProperties: {
            vpnConnectionIds: {
                serializedName: "vpnConnectionIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ListVirtualNetworkGatewayNatRulesResult = {
    type: {
        name: "Composite",
        className: "ListVirtualNetworkGatewayNatRulesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayNatRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualNetworkTapListResult = {
    type: {
        name: "Composite",
        className: "VirtualNetworkTapListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkTap"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualRouterListResult = {
    type: {
        name: "Composite",
        className: "VirtualRouterListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualRouter"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualRouterPeeringListResult = {
    type: {
        name: "Composite",
        className: "VirtualRouterPeeringListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualRouterPeering"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVirtualWANsResult = {
    type: {
        name: "Composite",
        className: "ListVirtualWANsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualWAN"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeviceProperties = {
    type: {
        name: "Composite",
        className: "DeviceProperties",
        modelProperties: {
            deviceVendor: {
                serializedName: "deviceVendor",
                type: {
                    name: "String"
                }
            },
            deviceModel: {
                serializedName: "deviceModel",
                type: {
                    name: "String"
                }
            },
            linkSpeedInMbps: {
                serializedName: "linkSpeedInMbps",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VpnLinkProviderProperties = {
    type: {
        name: "Composite",
        className: "VpnLinkProviderProperties",
        modelProperties: {
            linkProviderName: {
                serializedName: "linkProviderName",
                type: {
                    name: "String"
                }
            },
            linkSpeedInMbps: {
                serializedName: "linkSpeedInMbps",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VpnLinkBgpSettings = {
    type: {
        name: "Composite",
        className: "VpnLinkBgpSettings",
        modelProperties: {
            asn: {
                serializedName: "asn",
                type: {
                    name: "Number"
                }
            },
            bgpPeeringAddress: {
                serializedName: "bgpPeeringAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const O365PolicyProperties = {
    type: {
        name: "Composite",
        className: "O365PolicyProperties",
        modelProperties: {
            breakOutCategories: {
                serializedName: "breakOutCategories",
                type: {
                    name: "Composite",
                    className: "O365BreakOutCategoryPolicies"
                }
            }
        }
    }
};
const O365BreakOutCategoryPolicies = {
    type: {
        name: "Composite",
        className: "O365BreakOutCategoryPolicies",
        modelProperties: {
            allow: {
                serializedName: "allow",
                type: {
                    name: "Boolean"
                }
            },
            optimize: {
                serializedName: "optimize",
                type: {
                    name: "Boolean"
                }
            },
            default: {
                serializedName: "default",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ListVpnSitesResult = {
    type: {
        name: "Composite",
        className: "ListVpnSitesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSite"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVpnSiteLinksResult = {
    type: {
        name: "Composite",
        className: "ListVpnSiteLinksResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSiteLink"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetVpnSitesConfigurationRequest = {
    type: {
        name: "Composite",
        className: "GetVpnSitesConfigurationRequest",
        modelProperties: {
            vpnSites: {
                serializedName: "vpnSites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            outputBlobSasUrl: {
                serializedName: "outputBlobSasUrl",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualWanSecurityProviders = {
    type: {
        name: "Composite",
        className: "VirtualWanSecurityProviders",
        modelProperties: {
            supportedProviders: {
                serializedName: "supportedProviders",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualWanSecurityProvider"
                        }
                    }
                }
            }
        }
    }
};
const VirtualWanSecurityProvider = {
    type: {
        name: "Composite",
        className: "VirtualWanSecurityProvider",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "url",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigVpnClientRootCertificate = {
    type: {
        name: "Composite",
        className: "VpnServerConfigVpnClientRootCertificate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            publicCertData: {
                serializedName: "publicCertData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigVpnClientRevokedCertificate = {
    type: {
        name: "Composite",
        className: "VpnServerConfigVpnClientRevokedCertificate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigRadiusServerRootCertificate = {
    type: {
        name: "Composite",
        className: "VpnServerConfigRadiusServerRootCertificate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            publicCertData: {
                serializedName: "publicCertData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigRadiusClientRootCertificate = {
    type: {
        name: "Composite",
        className: "VpnServerConfigRadiusClientRootCertificate",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            thumbprint: {
                serializedName: "thumbprint",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AadAuthenticationParameters = {
    type: {
        name: "Composite",
        className: "AadAuthenticationParameters",
        modelProperties: {
            aadTenant: {
                serializedName: "aadTenant",
                type: {
                    name: "String"
                }
            },
            aadAudience: {
                serializedName: "aadAudience",
                type: {
                    name: "String"
                }
            },
            aadIssuer: {
                serializedName: "aadIssuer",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoutingConfiguration = {
    type: {
        name: "Composite",
        className: "RoutingConfiguration",
        modelProperties: {
            associatedRouteTable: {
                serializedName: "associatedRouteTable",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            propagatedRouteTables: {
                serializedName: "propagatedRouteTables",
                type: {
                    name: "Composite",
                    className: "PropagatedRouteTable"
                }
            },
            vnetRoutes: {
                serializedName: "vnetRoutes",
                type: {
                    name: "Composite",
                    className: "VnetRoute"
                }
            },
            inboundRouteMap: {
                serializedName: "inboundRouteMap",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            },
            outboundRouteMap: {
                serializedName: "outboundRouteMap",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }
        }
    }
};
const PropagatedRouteTable = {
    type: {
        name: "Composite",
        className: "PropagatedRouteTable",
        modelProperties: {
            labels: {
                serializedName: "labels",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            ids: {
                serializedName: "ids",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }
        }
    }
};
const VnetRoute = {
    type: {
        name: "Composite",
        className: "VnetRoute",
        modelProperties: {
            staticRoutesConfig: {
                serializedName: "staticRoutesConfig",
                type: {
                    name: "Composite",
                    className: "StaticRoutesConfig"
                }
            },
            staticRoutes: {
                serializedName: "staticRoutes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "StaticRoute"
                        }
                    }
                }
            },
            bgpConnections: {
                serializedName: "bgpConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }
        }
    }
};
const StaticRoutesConfig = {
    type: {
        name: "Composite",
        className: "StaticRoutesConfig",
        modelProperties: {
            propagateStaticRoutes: {
                serializedName: "propagateStaticRoutes",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            },
            vnetLocalRouteOverrideCriteria: {
                serializedName: "vnetLocalRouteOverrideCriteria",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const StaticRoute = {
    type: {
        name: "Composite",
        className: "StaticRoute",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            addressPrefixes: {
                serializedName: "addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopIpAddress: {
                serializedName: "nextHopIpAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigurationPolicyGroupMember = {
    type: {
        name: "Composite",
        className: "VpnServerConfigurationPolicyGroupMember",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            attributeType: {
                serializedName: "attributeType",
                type: {
                    name: "String"
                }
            },
            attributeValue: {
                serializedName: "attributeValue",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnClientConnectionHealth = {
    type: {
        name: "Composite",
        className: "VpnClientConnectionHealth",
        modelProperties: {
            totalIngressBytesTransferred: {
                serializedName: "totalIngressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            totalEgressBytesTransferred: {
                serializedName: "totalEgressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            vpnClientConnectionsCount: {
                serializedName: "vpnClientConnectionsCount",
                type: {
                    name: "Number"
                }
            },
            allocatedIpAddresses: {
                serializedName: "allocatedIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ListVpnServerConfigurationsResult = {
    type: {
        name: "Composite",
        className: "ListVpnServerConfigurationsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVpnServerConfigurationPolicyGroupsResult = {
    type: {
        name: "Composite",
        className: "ListVpnServerConfigurationPolicyGroupsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigurationPolicyGroup"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualHubRouteTable = {
    type: {
        name: "Composite",
        className: "VirtualHubRouteTable",
        modelProperties: {
            routes: {
                serializedName: "routes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubRoute"
                        }
                    }
                }
            }
        }
    }
};
const VirtualHubRoute = {
    type: {
        name: "Composite",
        className: "VirtualHubRoute",
        modelProperties: {
            addressPrefixes: {
                serializedName: "addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopIpAddress: {
                serializedName: "nextHopIpAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualHubRouteV2 = {
    type: {
        name: "Composite",
        className: "VirtualHubRouteV2",
        modelProperties: {
            destinationType: {
                serializedName: "destinationType",
                type: {
                    name: "String"
                }
            },
            destinations: {
                serializedName: "destinations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopType: {
                serializedName: "nextHopType",
                type: {
                    name: "String"
                }
            },
            nextHops: {
                serializedName: "nextHops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualRouterAutoScaleConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualRouterAutoScaleConfiguration",
        modelProperties: {
            minCapacity: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "minCapacity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ListVirtualHubsResult = {
    type: {
        name: "Composite",
        className: "ListVirtualHubsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHub"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RouteMapRule = {
    type: {
        name: "Composite",
        className: "RouteMapRule",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            matchCriteria: {
                serializedName: "matchCriteria",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Criterion"
                        }
                    }
                }
            },
            actions: {
                serializedName: "actions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Action"
                        }
                    }
                }
            },
            nextStepIfMatched: {
                serializedName: "nextStepIfMatched",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Criterion = {
    type: {
        name: "Composite",
        className: "Criterion",
        modelProperties: {
            routePrefix: {
                serializedName: "routePrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            community: {
                serializedName: "community",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            asPath: {
                serializedName: "asPath",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            matchCondition: {
                serializedName: "matchCondition",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Action = {
    type: {
        name: "Composite",
        className: "Action",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            parameters: {
                serializedName: "parameters",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Parameter"
                        }
                    }
                }
            }
        }
    }
};
const Parameter = {
    type: {
        name: "Composite",
        className: "Parameter",
        modelProperties: {
            routePrefix: {
                serializedName: "routePrefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            community: {
                serializedName: "community",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            asPath: {
                serializedName: "asPath",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ListRouteMapsResult = {
    type: {
        name: "Composite",
        className: "ListRouteMapsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteMap"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListHubVirtualNetworkConnectionsResult = {
    type: {
        name: "Composite",
        className: "ListHubVirtualNetworkConnectionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HubVirtualNetworkConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnGatewayIpConfiguration = {
    type: {
        name: "Composite",
        className: "VpnGatewayIpConfiguration",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            },
            publicIpAddress: {
                serializedName: "publicIpAddress",
                type: {
                    name: "String"
                }
            },
            privateIpAddress: {
                serializedName: "privateIpAddress",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnGatewayPacketCaptureStartParameters = {
    type: {
        name: "Composite",
        className: "VpnGatewayPacketCaptureStartParameters",
        modelProperties: {
            filterData: {
                serializedName: "filterData",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnGatewayPacketCaptureStopParameters = {
    type: {
        name: "Composite",
        className: "VpnGatewayPacketCaptureStopParameters",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVpnGatewaysResult = {
    type: {
        name: "Composite",
        className: "ListVpnGatewaysResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnConnectionPacketCaptureStartParameters = {
    type: {
        name: "Composite",
        className: "VpnConnectionPacketCaptureStartParameters",
        modelProperties: {
            filterData: {
                serializedName: "filterData",
                type: {
                    name: "String"
                }
            },
            linkConnectionNames: {
                serializedName: "linkConnectionNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VpnConnectionPacketCaptureStopParameters = {
    type: {
        name: "Composite",
        className: "VpnConnectionPacketCaptureStopParameters",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                type: {
                    name: "String"
                }
            },
            linkConnectionNames: {
                serializedName: "linkConnectionNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ListVpnConnectionsResult = {
    type: {
        name: "Composite",
        className: "ListVpnConnectionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVpnSiteLinkConnectionsResult = {
    type: {
        name: "Composite",
        className: "ListVpnSiteLinkConnectionsResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSiteLinkConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVpnGatewayNatRulesResult = {
    type: {
        name: "Composite",
        className: "ListVpnGatewayNatRulesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnGatewayNatRule"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListP2SVpnGatewaysResult = {
    type: {
        name: "Composite",
        className: "ListP2SVpnGatewaysResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "P2SVpnGateway"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const P2SVpnProfileParameters = {
    type: {
        name: "Composite",
        className: "P2SVpnProfileParameters",
        modelProperties: {
            authenticationMethod: {
                serializedName: "authenticationMethod",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnProfileResponse = {
    type: {
        name: "Composite",
        className: "VpnProfileResponse",
        modelProperties: {
            profileUrl: {
                serializedName: "profileUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const P2SVpnConnectionHealthRequest = {
    type: {
        name: "Composite",
        className: "P2SVpnConnectionHealthRequest",
        modelProperties: {
            vpnUserNamesFilter: {
                serializedName: "vpnUserNamesFilter",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            outputBlobSasUrl: {
                serializedName: "outputBlobSasUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const P2SVpnConnectionHealth = {
    type: {
        name: "Composite",
        className: "P2SVpnConnectionHealth",
        modelProperties: {
            sasUrl: {
                serializedName: "sasUrl",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnServerConfigurationsResponse = {
    type: {
        name: "Composite",
        className: "VpnServerConfigurationsResponse",
        modelProperties: {
            vpnServerConfigurationResourceIds: {
                serializedName: "vpnServerConfigurationResourceIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const VirtualWanVpnProfileParameters = {
    type: {
        name: "Composite",
        className: "VirtualWanVpnProfileParameters",
        modelProperties: {
            vpnServerConfigurationResourceId: {
                serializedName: "vpnServerConfigurationResourceId",
                type: {
                    name: "String"
                }
            },
            authenticationMethod: {
                serializedName: "authenticationMethod",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListVirtualHubRouteTableV2SResult = {
    type: {
        name: "Composite",
        className: "ListVirtualHubRouteTableV2SResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubRouteTableV2"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteGatewayList = {
    type: {
        name: "Composite",
        className: "ExpressRouteGatewayList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteGateway"
                        }
                    }
                }
            }
        }
    }
};
const ExpressRouteGatewayPropertiesAutoScaleConfiguration = {
    type: {
        name: "Composite",
        className: "ExpressRouteGatewayPropertiesAutoScaleConfiguration",
        modelProperties: {
            bounds: {
                serializedName: "bounds",
                type: {
                    name: "Composite",
                    className: "ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds"
                }
            }
        }
    }
};
const ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds = {
    type: {
        name: "Composite",
        className: "ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds",
        modelProperties: {
            min: {
                serializedName: "min",
                type: {
                    name: "Number"
                }
            },
            max: {
                serializedName: "max",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ExpressRouteCircuitPeeringId = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitPeeringId",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualHubId = {
    type: {
        name: "Composite",
        className: "VirtualHubId",
        modelProperties: {
            id: {
                serializedName: "id",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ExpressRouteConnectionList = {
    type: {
        name: "Composite",
        className: "ExpressRouteConnectionList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteConnection"
                        }
                    }
                }
            }
        }
    }
};
const ListVirtualHubBgpConnectionResults = {
    type: {
        name: "Composite",
        className: "ListVirtualHubBgpConnectionResults",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BgpConnection"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PeerRouteList = {
    type: {
        name: "Composite",
        className: "PeerRouteList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeerRoute"
                        }
                    }
                }
            }
        }
    }
};
const PeerRoute = {
    type: {
        name: "Composite",
        className: "PeerRoute",
        modelProperties: {
            localAddress: {
                serializedName: "localAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            network: {
                serializedName: "network",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            nextHop: {
                serializedName: "nextHop",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            sourcePeer: {
                serializedName: "sourcePeer",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            origin: {
                serializedName: "origin",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            asPath: {
                serializedName: "asPath",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            weight: {
                serializedName: "weight",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ListVirtualHubIpConfigurationResults = {
    type: {
        name: "Composite",
        className: "ListVirtualHubIpConfigurationResults",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HubIpConfiguration"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const HubRoute = {
    type: {
        name: "Composite",
        className: "HubRoute",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinationType: {
                serializedName: "destinationType",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinations: {
                serializedName: "destinations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopType: {
                serializedName: "nextHopType",
                required: true,
                type: {
                    name: "String"
                }
            },
            nextHop: {
                serializedName: "nextHop",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListHubRouteTablesResult = {
    type: {
        name: "Composite",
        className: "ListHubRouteTablesResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HubRouteTable"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveRoutesParameters = {
    type: {
        name: "Composite",
        className: "EffectiveRoutesParameters",
        modelProperties: {
            resourceId: {
                serializedName: "resourceId",
                type: {
                    name: "String"
                }
            },
            virtualWanResourceType: {
                serializedName: "virtualWanResourceType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetInboundRoutesParameters = {
    type: {
        name: "Composite",
        className: "GetInboundRoutesParameters",
        modelProperties: {
            resourceUri: {
                serializedName: "resourceUri",
                type: {
                    name: "String"
                }
            },
            connectionType: {
                serializedName: "connectionType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetOutboundRoutesParameters = {
    type: {
        name: "Composite",
        className: "GetOutboundRoutesParameters",
        modelProperties: {
            resourceUri: {
                serializedName: "resourceUri",
                type: {
                    name: "String"
                }
            },
            connectionType: {
                serializedName: "connectionType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RoutingPolicy = {
    type: {
        name: "Composite",
        className: "RoutingPolicy",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            destinations: {
                serializedName: "destinations",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHop: {
                serializedName: "nextHop",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ListRoutingIntentResult = {
    type: {
        name: "Composite",
        className: "ListRoutingIntentResult",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoutingIntent"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebApplicationFirewallPolicyListResult = {
    type: {
        name: "Composite",
        className: "WebApplicationFirewallPolicyListResult",
        modelProperties: {
            value: {
                serializedName: "value",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebApplicationFirewallPolicy"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PolicySettings = {
    type: {
        name: "Composite",
        className: "PolicySettings",
        modelProperties: {
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            mode: {
                serializedName: "mode",
                type: {
                    name: "String"
                }
            },
            requestBodyCheck: {
                serializedName: "requestBodyCheck",
                type: {
                    name: "Boolean"
                }
            },
            maxRequestBodySizeInKb: {
                constraints: {
                    InclusiveMinimum: 8
                },
                serializedName: "maxRequestBodySizeInKb",
                type: {
                    name: "Number"
                }
            },
            fileUploadLimitInMb: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "fileUploadLimitInMb",
                type: {
                    name: "Number"
                }
            },
            customBlockResponseStatusCode: {
                constraints: {
                    InclusiveMinimum: 0
                },
                serializedName: "customBlockResponseStatusCode",
                type: {
                    name: "Number"
                }
            },
            customBlockResponseBody: {
                constraints: {
                    Pattern: new RegExp("^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$"),
                    MaxLength: 32768
                },
                serializedName: "customBlockResponseBody",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const WebApplicationFirewallCustomRule = {
    type: {
        name: "Composite",
        className: "WebApplicationFirewallCustomRule",
        modelProperties: {
            name: {
                constraints: {
                    MaxLength: 128
                },
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            priority: {
                serializedName: "priority",
                required: true,
                type: {
                    name: "Number"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            ruleType: {
                serializedName: "ruleType",
                required: true,
                type: {
                    name: "String"
                }
            },
            matchConditions: {
                serializedName: "matchConditions",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MatchCondition"
                        }
                    }
                }
            },
            action: {
                serializedName: "action",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MatchCondition = {
    type: {
        name: "Composite",
        className: "MatchCondition",
        modelProperties: {
            matchVariables: {
                serializedName: "matchVariables",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "MatchVariable"
                        }
                    }
                }
            },
            operator: {
                serializedName: "operator",
                required: true,
                type: {
                    name: "String"
                }
            },
            negationConditon: {
                serializedName: "negationConditon",
                type: {
                    name: "Boolean"
                }
            },
            matchValues: {
                serializedName: "matchValues",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            transforms: {
                serializedName: "transforms",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const MatchVariable = {
    type: {
        name: "Composite",
        className: "MatchVariable",
        modelProperties: {
            variableName: {
                serializedName: "variableName",
                required: true,
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedRulesDefinition = {
    type: {
        name: "Composite",
        className: "ManagedRulesDefinition",
        modelProperties: {
            exclusions: {
                serializedName: "exclusions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OwaspCrsExclusionEntry"
                        }
                    }
                }
            },
            managedRuleSets: {
                serializedName: "managedRuleSets",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleSet"
                        }
                    }
                }
            }
        }
    }
};
const OwaspCrsExclusionEntry = {
    type: {
        name: "Composite",
        className: "OwaspCrsExclusionEntry",
        modelProperties: {
            matchVariable: {
                serializedName: "matchVariable",
                required: true,
                type: {
                    name: "String"
                }
            },
            selectorMatchOperator: {
                serializedName: "selectorMatchOperator",
                required: true,
                type: {
                    name: "String"
                }
            },
            selector: {
                serializedName: "selector",
                required: true,
                type: {
                    name: "String"
                }
            },
            exclusionManagedRuleSets: {
                serializedName: "exclusionManagedRuleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExclusionManagedRuleSet"
                        }
                    }
                }
            }
        }
    }
};
const ExclusionManagedRuleSet = {
    type: {
        name: "Composite",
        className: "ExclusionManagedRuleSet",
        modelProperties: {
            ruleSetType: {
                serializedName: "ruleSetType",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetVersion: {
                serializedName: "ruleSetVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleGroups: {
                serializedName: "ruleGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExclusionManagedRuleGroup"
                        }
                    }
                }
            }
        }
    }
};
const ExclusionManagedRuleGroup = {
    type: {
        name: "Composite",
        className: "ExclusionManagedRuleGroup",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExclusionManagedRule"
                        }
                    }
                }
            }
        }
    }
};
const ExclusionManagedRule = {
    type: {
        name: "Composite",
        className: "ExclusionManagedRule",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManagedRuleSet = {
    type: {
        name: "Composite",
        className: "ManagedRuleSet",
        modelProperties: {
            ruleSetType: {
                serializedName: "ruleSetType",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleSetVersion: {
                serializedName: "ruleSetVersion",
                required: true,
                type: {
                    name: "String"
                }
            },
            ruleGroupOverrides: {
                serializedName: "ruleGroupOverrides",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleGroupOverride"
                        }
                    }
                }
            }
        }
    }
};
const ManagedRuleGroupOverride = {
    type: {
        name: "Composite",
        className: "ManagedRuleGroupOverride",
        modelProperties: {
            ruleGroupName: {
                serializedName: "ruleGroupName",
                required: true,
                type: {
                    name: "String"
                }
            },
            rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManagedRuleOverride"
                        }
                    }
                }
            }
        }
    }
};
const ManagedRuleOverride = {
    type: {
        name: "Composite",
        className: "ManagedRuleOverride",
        modelProperties: {
            ruleId: {
                serializedName: "ruleId",
                required: true,
                type: {
                    name: "String"
                }
            },
            state: {
                serializedName: "state",
                type: {
                    name: "String"
                }
            },
            action: {
                serializedName: "action",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyNatRuleCollectionAction = {
    type: {
        name: "Composite",
        className: "FirewallPolicyNatRuleCollectionAction",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyRule = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRule",
        uberParent: "FirewallPolicyRule",
        polymorphicDiscriminator: {
            serializedName: "ruleType",
            clientName: "ruleType"
        },
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "description",
                type: {
                    name: "String"
                }
            },
            ruleType: {
                serializedName: "ruleType",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyFilterRuleCollectionAction = {
    type: {
        name: "Composite",
        className: "FirewallPolicyFilterRuleCollectionAction",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const FirewallPolicyRuleApplicationProtocol = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRuleApplicationProtocol",
        modelProperties: {
            protocolType: {
                serializedName: "protocolType",
                type: {
                    name: "String"
                }
            },
            port: {
                constraints: {
                    InclusiveMaximum: 64000,
                    InclusiveMinimum: 0
                },
                serializedName: "port",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const AzureAsyncOperationResult = {
    type: {
        name: "Composite",
        className: "AzureAsyncOperationResult",
        modelProperties: {
            status: {
                serializedName: "status",
                type: {
                    name: "String"
                }
            },
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ErrorModel"
                }
            }
        }
    }
};
const AddressPrefixItem = {
    type: {
        name: "Composite",
        className: "AddressPrefixItem",
        modelProperties: {
            addressPrefix: {
                serializedName: "addressPrefix",
                type: {
                    name: "String"
                }
            },
            addressPrefixType: {
                serializedName: "addressPrefixType",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VpnSiteId = {
    type: {
        name: "Composite",
        className: "VpnSiteId",
        modelProperties: {
            vpnSite: {
                serializedName: "vpnSite",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const VirtualHubEffectiveRouteList = {
    type: {
        name: "Composite",
        className: "VirtualHubEffectiveRouteList",
        modelProperties: {
            value: {
                serializedName: "value",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubEffectiveRoute"
                        }
                    }
                }
            }
        }
    }
};
const VirtualHubEffectiveRoute = {
    type: {
        name: "Composite",
        className: "VirtualHubEffectiveRoute",
        modelProperties: {
            addressPrefixes: {
                serializedName: "addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHops: {
                serializedName: "nextHops",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            nextHopType: {
                serializedName: "nextHopType",
                type: {
                    name: "String"
                }
            },
            asPath: {
                serializedName: "asPath",
                type: {
                    name: "String"
                }
            },
            routeOrigin: {
                serializedName: "routeOrigin",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const EffectiveRouteMapRoute = {
    type: {
        name: "Composite",
        className: "EffectiveRouteMapRoute",
        modelProperties: {
            prefix: {
                serializedName: "prefix",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            bgpCommunities: {
                serializedName: "bgpCommunities",
                type: {
                    name: "String"
                }
            },
            asPath: {
                serializedName: "asPath",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ApplicationGatewayIPConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayAuthenticationCertificate = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAuthenticationCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayTrustedRootCertificate = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayTrustedRootCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "String"
                }
            }, keyVaultSecretId: {
                serializedName: "properties.keyVaultSecretId",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayTrustedClientCertificate = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayTrustedClientCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "String"
                }
            }, validatedCertData: {
                serializedName: "properties.validatedCertData",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, clientCertIssuerDN: {
                serializedName: "properties.clientCertIssuerDN",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewaySslCertificate = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySslCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, data: {
                serializedName: "properties.data",
                type: {
                    name: "String"
                }
            }, password: {
                serializedName: "properties.password",
                type: {
                    name: "String"
                }
            }, publicCertData: {
                serializedName: "properties.publicCertData",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, keyVaultSecretId: {
                serializedName: "properties.keyVaultSecretId",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayFrontendIPConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFrontendIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, privateLinkConfiguration: {
                serializedName: "properties.privateLinkConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayFrontendPort = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFrontendPort",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, port: {
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayProbe = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayProbe",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, host: {
                serializedName: "properties.host",
                type: {
                    name: "String"
                }
            }, path: {
                serializedName: "properties.path",
                type: {
                    name: "String"
                }
            }, interval: {
                serializedName: "properties.interval",
                type: {
                    name: "Number"
                }
            }, timeout: {
                serializedName: "properties.timeout",
                type: {
                    name: "Number"
                }
            }, unhealthyThreshold: {
                serializedName: "properties.unhealthyThreshold",
                type: {
                    name: "Number"
                }
            }, pickHostNameFromBackendHttpSettings: {
                serializedName: "properties.pickHostNameFromBackendHttpSettings",
                type: {
                    name: "Boolean"
                }
            }, pickHostNameFromBackendSettings: {
                serializedName: "properties.pickHostNameFromBackendSettings",
                type: {
                    name: "Boolean"
                }
            }, minServers: {
                serializedName: "properties.minServers",
                type: {
                    name: "Number"
                }
            }, match: {
                serializedName: "properties.match",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayProbeHealthResponseMatch"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, port: {
                constraints: {
                    InclusiveMaximum: 65535,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            } })
    }
};
const NetworkInterfaceTapConfiguration = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceTapConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualNetworkTap: {
                serializedName: "properties.virtualNetworkTap",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkTap"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SecurityRule = {
    type: {
        name: "Composite",
        className: "SecurityRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, sourcePortRange: {
                serializedName: "properties.sourcePortRange",
                type: {
                    name: "String"
                }
            }, destinationPortRange: {
                serializedName: "properties.destinationPortRange",
                type: {
                    name: "String"
                }
            }, sourceAddressPrefix: {
                serializedName: "properties.sourceAddressPrefix",
                type: {
                    name: "String"
                }
            }, sourceAddressPrefixes: {
                serializedName: "properties.sourceAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceApplicationSecurityGroups: {
                serializedName: "properties.sourceApplicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            }, destinationAddressPrefix: {
                serializedName: "properties.destinationAddressPrefix",
                type: {
                    name: "String"
                }
            }, destinationAddressPrefixes: {
                serializedName: "properties.destinationAddressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationApplicationSecurityGroups: {
                serializedName: "properties.destinationApplicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, access: {
                serializedName: "properties.access",
                type: {
                    name: "String"
                }
            }, priority: {
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, direction: {
                serializedName: "properties.direction",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkServiceConnection = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateLinkServiceId: {
                serializedName: "properties.privateLinkServiceId",
                type: {
                    name: "String"
                }
            }, groupIds: {
                serializedName: "properties.groupIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requestMessage: {
                serializedName: "properties.requestMessage",
                type: {
                    name: "String"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            } })
    }
};
const PrivateLinkServiceIpConfiguration = {
    type: {
        name: "Composite",
        className: "PrivateLinkServiceIpConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddressVersion: {
                serializedName: "properties.privateIPAddressVersion",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "PrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkIdentifier: {
                serializedName: "properties.linkIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Route = {
    type: {
        name: "Composite",
        className: "Route",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, nextHopType: {
                serializedName: "properties.nextHopType",
                type: {
                    name: "String"
                }
            }, nextHopIpAddress: {
                serializedName: "properties.nextHopIpAddress",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, hasBgpOverride: {
                serializedName: "properties.hasBgpOverride",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const ServiceEndpointPolicyDefinition = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPolicyDefinition",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, service: {
                serializedName: "properties.service",
                type: {
                    name: "String"
                }
            }, serviceResources: {
                serializedName: "properties.serviceResources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const IPConfiguration = {
    type: {
        name: "Composite",
        className: "IPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const IPConfigurationProfile = {
    type: {
        name: "Composite",
        className: "IPConfigurationProfile",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ResourceNavigationLink = {
    type: {
        name: "Composite",
        className: "ResourceNavigationLink",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkedResourceType: {
                serializedName: "properties.linkedResourceType",
                type: {
                    name: "String"
                }
            }, link: {
                serializedName: "properties.link",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceAssociationLink = {
    type: {
        name: "Composite",
        className: "ServiceAssociationLink",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkedResourceType: {
                serializedName: "properties.linkedResourceType",
                type: {
                    name: "String"
                }
            }, link: {
                serializedName: "properties.link",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, allowDelete: {
                serializedName: "properties.allowDelete",
                type: {
                    name: "Boolean"
                }
            }, locations: {
                serializedName: "properties.locations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const Delegation = {
    type: {
        name: "Composite",
        className: "Delegation",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, serviceName: {
                serializedName: "properties.serviceName",
                type: {
                    name: "String"
                }
            }, actions: {
                serializedName: "properties.actions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Subnet = {
    type: {
        name: "Composite",
        className: "Subnet",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, addressPrefixes: {
                serializedName: "properties.addressPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, networkSecurityGroup: {
                serializedName: "properties.networkSecurityGroup",
                type: {
                    name: "Composite",
                    className: "NetworkSecurityGroup"
                }
            }, routeTable: {
                serializedName: "properties.routeTable",
                type: {
                    name: "Composite",
                    className: "RouteTable"
                }
            }, natGateway: {
                serializedName: "properties.natGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, serviceEndpoints: {
                serializedName: "properties.serviceEndpoints",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPropertiesFormat"
                        }
                    }
                }
            }, serviceEndpointPolicies: {
                serializedName: "properties.serviceEndpointPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPolicy"
                        }
                    }
                }
            }, privateEndpoints: {
                serializedName: "properties.privateEndpoints",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpoint"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPConfiguration"
                        }
                    }
                }
            }, ipConfigurationProfiles: {
                serializedName: "properties.ipConfigurationProfiles",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPConfigurationProfile"
                        }
                    }
                }
            }, ipAllocations: {
                serializedName: "properties.ipAllocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, resourceNavigationLinks: {
                serializedName: "properties.resourceNavigationLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ResourceNavigationLink"
                        }
                    }
                }
            }, serviceAssociationLinks: {
                serializedName: "properties.serviceAssociationLinks",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceAssociationLink"
                        }
                    }
                }
            }, delegations: {
                serializedName: "properties.delegations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Delegation"
                        }
                    }
                }
            }, purpose: {
                serializedName: "properties.purpose",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpointNetworkPolicies: {
                defaultValue: "Disabled",
                serializedName: "properties.privateEndpointNetworkPolicies",
                type: {
                    name: "String"
                }
            }, privateLinkServiceNetworkPolicies: {
                defaultValue: "Enabled",
                serializedName: "properties.privateLinkServiceNetworkPolicies",
                type: {
                    name: "String"
                }
            }, applicationGatewayIpConfigurations: {
                serializedName: "properties.applicationGatewayIpConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayIPConfiguration"
                        }
                    }
                }
            } })
    }
};
const FrontendIPConfiguration = {
    type: {
        name: "Composite",
        className: "FrontendIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, inboundNatRules: {
                serializedName: "properties.inboundNatRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, inboundNatPools: {
                serializedName: "properties.inboundNatPools",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, outboundRules: {
                serializedName: "properties.outboundRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, loadBalancingRules: {
                serializedName: "properties.loadBalancingRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, privateIPAddressVersion: {
                serializedName: "properties.privateIPAddressVersion",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, publicIPPrefix: {
                serializedName: "properties.publicIPPrefix",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, gatewayLoadBalancer: {
                serializedName: "properties.gatewayLoadBalancer",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const BackendAddressPool = {
    type: {
        name: "Composite",
        className: "BackendAddressPool",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "properties.location",
                type: {
                    name: "String"
                }
            }, tunnelInterfaces: {
                serializedName: "properties.tunnelInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayLoadBalancerTunnelInterface"
                        }
                    }
                }
            }, loadBalancerBackendAddresses: {
                serializedName: "properties.loadBalancerBackendAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancerBackendAddress"
                        }
                    }
                }
            }, backendIPConfigurations: {
                serializedName: "properties.backendIPConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceIPConfiguration"
                        }
                    }
                }
            }, loadBalancingRules: {
                serializedName: "properties.loadBalancingRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, outboundRule: {
                serializedName: "properties.outboundRule",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, outboundRules: {
                serializedName: "properties.outboundRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, inboundNatRules: {
                serializedName: "properties.inboundNatRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, drainPeriodInSeconds: {
                serializedName: "properties.drainPeriodInSeconds",
                type: {
                    name: "Number"
                }
            }, virtualNetwork: {
                serializedName: "properties.virtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            } })
    }
};
const InboundNatRule = {
    type: {
        name: "Composite",
        className: "InboundNatRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfiguration: {
                serializedName: "properties.frontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendIPConfiguration: {
                serializedName: "properties.backendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceIPConfiguration"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, frontendPort: {
                serializedName: "properties.frontendPort",
                type: {
                    name: "Number"
                }
            }, backendPort: {
                serializedName: "properties.backendPort",
                type: {
                    name: "Number"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, enableFloatingIP: {
                serializedName: "properties.enableFloatingIP",
                type: {
                    name: "Boolean"
                }
            }, enableTcpReset: {
                serializedName: "properties.enableTcpReset",
                type: {
                    name: "Boolean"
                }
            }, frontendPortRangeStart: {
                serializedName: "properties.frontendPortRangeStart",
                type: {
                    name: "Number"
                }
            }, frontendPortRangeEnd: {
                serializedName: "properties.frontendPortRangeEnd",
                type: {
                    name: "Number"
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkInterfaceIPConfiguration = {
    type: {
        name: "Composite",
        className: "NetworkInterfaceIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, gatewayLoadBalancer: {
                serializedName: "properties.gatewayLoadBalancer",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, virtualNetworkTaps: {
                serializedName: "properties.virtualNetworkTaps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkTap"
                        }
                    }
                }
            }, applicationGatewayBackendAddressPools: {
                serializedName: "properties.applicationGatewayBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendAddressPool"
                        }
                    }
                }
            }, loadBalancerBackendAddressPools: {
                serializedName: "properties.loadBalancerBackendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendAddressPool"
                        }
                    }
                }
            }, loadBalancerInboundNatRules: {
                serializedName: "properties.loadBalancerInboundNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatRule"
                        }
                    }
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, privateIPAddressVersion: {
                serializedName: "properties.privateIPAddressVersion",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, applicationSecurityGroups: {
                serializedName: "properties.applicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateLinkConnectionProperties: {
                serializedName: "properties.privateLinkConnectionProperties",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties"
                }
            } })
    }
};
const ApplicationGatewayBackendAddressPool = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendAddressPool",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, backendIPConfigurations: {
                serializedName: "properties.backendIPConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceIPConfiguration"
                        }
                    }
                }
            }, backendAddresses: {
                serializedName: "properties.backendAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendAddress"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayBackendHttpSettings = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendHttpSettings",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, port: {
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, cookieBasedAffinity: {
                serializedName: "properties.cookieBasedAffinity",
                type: {
                    name: "String"
                }
            }, requestTimeout: {
                serializedName: "properties.requestTimeout",
                type: {
                    name: "Number"
                }
            }, probe: {
                serializedName: "properties.probe",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, authenticationCertificates: {
                serializedName: "properties.authenticationCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, trustedRootCertificates: {
                serializedName: "properties.trustedRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, connectionDraining: {
                serializedName: "properties.connectionDraining",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayConnectionDraining"
                }
            }, hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }, pickHostNameFromBackendAddress: {
                serializedName: "properties.pickHostNameFromBackendAddress",
                type: {
                    name: "Boolean"
                }
            }, affinityCookieName: {
                serializedName: "properties.affinityCookieName",
                type: {
                    name: "String"
                }
            }, probeEnabled: {
                serializedName: "properties.probeEnabled",
                type: {
                    name: "Boolean"
                }
            }, path: {
                serializedName: "properties.path",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayBackendSettings = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayBackendSettings",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, port: {
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, timeout: {
                serializedName: "properties.timeout",
                type: {
                    name: "Number"
                }
            }, probe: {
                serializedName: "properties.probe",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, trustedRootCertificates: {
                serializedName: "properties.trustedRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }, pickHostNameFromBackendAddress: {
                serializedName: "properties.pickHostNameFromBackendAddress",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayHttpListener = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayHttpListener",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfiguration: {
                serializedName: "properties.frontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, frontendPort: {
                serializedName: "properties.frontendPort",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, hostName: {
                serializedName: "properties.hostName",
                type: {
                    name: "String"
                }
            }, sslCertificate: {
                serializedName: "properties.sslCertificate",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, sslProfile: {
                serializedName: "properties.sslProfile",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, requireServerNameIndication: {
                serializedName: "properties.requireServerNameIndication",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customErrorConfigurations: {
                serializedName: "properties.customErrorConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayCustomError"
                        }
                    }
                }
            }, firewallPolicy: {
                serializedName: "properties.firewallPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, hostNames: {
                serializedName: "properties.hostNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ApplicationGatewayListener = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayListener",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfiguration: {
                serializedName: "properties.frontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, frontendPort: {
                serializedName: "properties.frontendPort",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, sslCertificate: {
                serializedName: "properties.sslCertificate",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, sslProfile: {
                serializedName: "properties.sslProfile",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewaySslProfile = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySslProfile",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, trustedClientCertificates: {
                serializedName: "properties.trustedClientCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, sslPolicy: {
                serializedName: "properties.sslPolicy",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewaySslPolicy"
                }
            }, clientAuthConfiguration: {
                serializedName: "properties.clientAuthConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayClientAuthConfiguration"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayPathRule = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPathRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, paths: {
                serializedName: "properties.paths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendHttpSettings: {
                serializedName: "properties.backendHttpSettings",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, redirectConfiguration: {
                serializedName: "properties.redirectConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, rewriteRuleSet: {
                serializedName: "properties.rewriteRuleSet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, loadDistributionPolicy: {
                serializedName: "properties.loadDistributionPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, firewallPolicy: {
                serializedName: "properties.firewallPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            } })
    }
};
const ApplicationGatewayUrlPathMap = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayUrlPathMap",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, defaultBackendAddressPool: {
                serializedName: "properties.defaultBackendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, defaultBackendHttpSettings: {
                serializedName: "properties.defaultBackendHttpSettings",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, defaultRewriteRuleSet: {
                serializedName: "properties.defaultRewriteRuleSet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, defaultRedirectConfiguration: {
                serializedName: "properties.defaultRedirectConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, defaultLoadDistributionPolicy: {
                serializedName: "properties.defaultLoadDistributionPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, pathRules: {
                serializedName: "properties.pathRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPathRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayRequestRoutingRule = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRequestRoutingRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ruleType: {
                serializedName: "properties.ruleType",
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 20000,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendHttpSettings: {
                serializedName: "properties.backendHttpSettings",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, httpListener: {
                serializedName: "properties.httpListener",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, urlPathMap: {
                serializedName: "properties.urlPathMap",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, rewriteRuleSet: {
                serializedName: "properties.rewriteRuleSet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, redirectConfiguration: {
                serializedName: "properties.redirectConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, loadDistributionPolicy: {
                serializedName: "properties.loadDistributionPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayRoutingRule = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRoutingRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ruleType: {
                serializedName: "properties.ruleType",
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 20000,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendSettings: {
                serializedName: "properties.backendSettings",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, listener: {
                serializedName: "properties.listener",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayRewriteRuleSet = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRewriteRuleSet",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rewriteRules: {
                serializedName: "properties.rewriteRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRewriteRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayRedirectConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayRedirectConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, redirectType: {
                serializedName: "properties.redirectType",
                type: {
                    name: "String"
                }
            }, targetListener: {
                serializedName: "properties.targetListener",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, targetUrl: {
                serializedName: "properties.targetUrl",
                type: {
                    name: "String"
                }
            }, includePath: {
                serializedName: "properties.includePath",
                type: {
                    name: "Boolean"
                }
            }, includeQueryString: {
                serializedName: "properties.includeQueryString",
                type: {
                    name: "Boolean"
                }
            }, requestRoutingRules: {
                serializedName: "properties.requestRoutingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, urlPathMaps: {
                serializedName: "properties.urlPathMaps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, pathRules: {
                serializedName: "properties.pathRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const ApplicationGatewayPrivateLinkIpConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateLinkIpConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, primary: {
                serializedName: "properties.primary",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayPrivateLinkConfiguration = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateLinkConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateLinkIpConfiguration"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayPrivateEndpointConnection = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateEndpointConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, privateLinkServiceConnectionState: {
                serializedName: "properties.privateLinkServiceConnectionState",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServiceConnectionState"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkIdentifier: {
                serializedName: "properties.linkIdentifier",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayLoadDistributionTarget = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayLoadDistributionTarget",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, weightPerServer: {
                constraints: {
                    InclusiveMaximum: 100,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.weightPerServer",
                type: {
                    name: "Number"
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            } })
    }
};
const ApplicationGatewayLoadDistributionPolicy = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayLoadDistributionPolicy",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, loadDistributionTargets: {
                serializedName: "properties.loadDistributionTargets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayLoadDistributionTarget"
                        }
                    }
                }
            }, loadDistributionAlgorithm: {
                serializedName: "properties.loadDistributionAlgorithm",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationGatewayPrivateLinkResource = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayPrivateLinkResource",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, groupId: {
                serializedName: "properties.groupId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, requiredMembers: {
                serializedName: "properties.requiredMembers",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, requiredZoneNames: {
                serializedName: "properties.requiredZoneNames",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ApplicationGatewaySslPredefinedPolicy = {
    type: {
        name: "Composite",
        className: "ApplicationGatewaySslPredefinedPolicy",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, cipherSuites: {
                serializedName: "properties.cipherSuites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, minProtocolVersion: {
                serializedName: "properties.minProtocolVersion",
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirewallApplicationRuleCollection = {
    type: {
        name: "Composite",
        className: "AzureFirewallApplicationRuleCollection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, action: {
                serializedName: "properties.action",
                type: {
                    name: "Composite",
                    className: "AzureFirewallRCAction"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallApplicationRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirewallNatRuleCollection = {
    type: {
        name: "Composite",
        className: "AzureFirewallNatRuleCollection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, action: {
                serializedName: "properties.action",
                type: {
                    name: "Composite",
                    className: "AzureFirewallNatRCAction"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallNatRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirewallNetworkRuleCollection = {
    type: {
        name: "Composite",
        className: "AzureFirewallNetworkRuleCollection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, action: {
                serializedName: "properties.action",
                type: {
                    name: "Composite",
                    className: "AzureFirewallRCAction"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallNetworkRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AzureFirewallIPConfiguration = {
    type: {
        name: "Composite",
        className: "AzureFirewallIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const BastionHostIPConfiguration = {
    type: {
        name: "Composite",
        className: "BastionHostIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            } })
    }
};
const EndpointServiceResult = {
    type: {
        name: "Composite",
        className: "EndpointServiceResult",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCircuitAuthorization = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitAuthorization",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, authorizationUseStatus: {
                serializedName: "properties.authorizationUseStatus",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCircuitConnection = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteCircuitPeering: {
                serializedName: "properties.expressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, peerExpressRouteCircuitPeering: {
                serializedName: "properties.peerExpressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, ipv6CircuitConnectionConfig: {
                serializedName: "properties.ipv6CircuitConnectionConfig",
                type: {
                    name: "Composite",
                    className: "Ipv6CircuitConnectionConfig"
                }
            }, circuitConnectionStatus: {
                serializedName: "properties.circuitConnectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PeerExpressRouteCircuitConnection = {
    type: {
        name: "Composite",
        className: "PeerExpressRouteCircuitConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteCircuitPeering: {
                serializedName: "properties.expressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, peerExpressRouteCircuitPeering: {
                serializedName: "properties.peerExpressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, circuitConnectionStatus: {
                serializedName: "properties.circuitConnectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectionName: {
                serializedName: "properties.connectionName",
                type: {
                    name: "String"
                }
            }, authResourceGuid: {
                serializedName: "properties.authResourceGuid",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCircuitPeering = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuitPeering",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peeringType: {
                serializedName: "properties.peeringType",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, azureASN: {
                serializedName: "properties.azureASN",
                type: {
                    name: "Number"
                }
            }, peerASN: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.peerASN",
                type: {
                    name: "Number"
                }
            }, primaryPeerAddressPrefix: {
                serializedName: "properties.primaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            }, secondaryPeerAddressPrefix: {
                serializedName: "properties.secondaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            }, primaryAzurePort: {
                serializedName: "properties.primaryAzurePort",
                type: {
                    name: "String"
                }
            }, secondaryAzurePort: {
                serializedName: "properties.secondaryAzurePort",
                type: {
                    name: "String"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, vlanId: {
                serializedName: "properties.vlanId",
                type: {
                    name: "Number"
                }
            }, microsoftPeeringConfig: {
                serializedName: "properties.microsoftPeeringConfig",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitPeeringConfig"
                }
            }, stats: {
                serializedName: "properties.stats",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitStats"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, gatewayManagerEtag: {
                serializedName: "properties.gatewayManagerEtag",
                type: {
                    name: "String"
                }
            }, lastModifiedBy: {
                serializedName: "properties.lastModifiedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routeFilter: {
                serializedName: "properties.routeFilter",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, ipv6PeeringConfig: {
                serializedName: "properties.ipv6PeeringConfig",
                type: {
                    name: "Composite",
                    className: "Ipv6ExpressRouteCircuitPeeringConfig"
                }
            }, expressRouteConnection: {
                serializedName: "properties.expressRouteConnection",
                type: {
                    name: "Composite",
                    className: "ExpressRouteConnectionId"
                }
            }, connections: {
                serializedName: "properties.connections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitConnection"
                        }
                    }
                }
            }, peeredConnections: {
                serializedName: "properties.peeredConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PeerExpressRouteCircuitConnection"
                        }
                    }
                }
            } })
    }
};
const ExpressRouteCrossConnectionPeering = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnectionPeering",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peeringType: {
                serializedName: "properties.peeringType",
                type: {
                    name: "String"
                }
            }, state: {
                serializedName: "properties.state",
                type: {
                    name: "String"
                }
            }, azureASN: {
                serializedName: "properties.azureASN",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, peerASN: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.peerASN",
                type: {
                    name: "Number"
                }
            }, primaryPeerAddressPrefix: {
                serializedName: "properties.primaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            }, secondaryPeerAddressPrefix: {
                serializedName: "properties.secondaryPeerAddressPrefix",
                type: {
                    name: "String"
                }
            }, primaryAzurePort: {
                serializedName: "properties.primaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, secondaryAzurePort: {
                serializedName: "properties.secondaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, vlanId: {
                serializedName: "properties.vlanId",
                type: {
                    name: "Number"
                }
            }, microsoftPeeringConfig: {
                serializedName: "properties.microsoftPeeringConfig",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitPeeringConfig"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, gatewayManagerEtag: {
                serializedName: "properties.gatewayManagerEtag",
                type: {
                    name: "String"
                }
            }, lastModifiedBy: {
                serializedName: "properties.lastModifiedBy",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipv6PeeringConfig: {
                serializedName: "properties.ipv6PeeringConfig",
                type: {
                    name: "Composite",
                    className: "Ipv6ExpressRouteCircuitPeeringConfig"
                }
            } })
    }
};
const ExpressRouteLink = {
    type: {
        name: "Composite",
        className: "ExpressRouteLink",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routerName: {
                serializedName: "properties.routerName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, interfaceName: {
                serializedName: "properties.interfaceName",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, patchPanelId: {
                serializedName: "properties.patchPanelId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rackId: {
                serializedName: "properties.rackId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, coloLocation: {
                serializedName: "properties.coloLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectorType: {
                serializedName: "properties.connectorType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, adminState: {
                serializedName: "properties.adminState",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, macSecConfig: {
                serializedName: "properties.macSecConfig",
                type: {
                    name: "Composite",
                    className: "ExpressRouteLinkMacSecConfig"
                }
            } })
    }
};
const ExpressRoutePortAuthorization = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortAuthorization",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authorizationUseStatus: {
                serializedName: "properties.authorizationUseStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, circuitResourceUri: {
                serializedName: "properties.circuitResourceUri",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const FirewallPolicyRuleCollectionGroup = {
    type: {
        name: "Composite",
        className: "FirewallPolicyRuleCollectionGroup",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 65000,
                    InclusiveMinimum: 100
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, ruleCollections: {
                serializedName: "properties.ruleCollections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRuleCollection"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const LoadBalancingRule = {
    type: {
        name: "Composite",
        className: "LoadBalancingRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfiguration: {
                serializedName: "properties.frontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, backendAddressPools: {
                serializedName: "properties.backendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, probe: {
                serializedName: "properties.probe",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, loadDistribution: {
                serializedName: "properties.loadDistribution",
                type: {
                    name: "String"
                }
            }, frontendPort: {
                serializedName: "properties.frontendPort",
                type: {
                    name: "Number"
                }
            }, backendPort: {
                serializedName: "properties.backendPort",
                type: {
                    name: "Number"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, enableFloatingIP: {
                serializedName: "properties.enableFloatingIP",
                type: {
                    name: "Boolean"
                }
            }, enableTcpReset: {
                serializedName: "properties.enableTcpReset",
                type: {
                    name: "Boolean"
                }
            }, disableOutboundSnat: {
                serializedName: "properties.disableOutboundSnat",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Probe = {
    type: {
        name: "Composite",
        className: "Probe",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, loadBalancingRules: {
                serializedName: "properties.loadBalancingRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, port: {
                serializedName: "properties.port",
                type: {
                    name: "Number"
                }
            }, intervalInSeconds: {
                serializedName: "properties.intervalInSeconds",
                type: {
                    name: "Number"
                }
            }, numberOfProbes: {
                serializedName: "properties.numberOfProbes",
                type: {
                    name: "Number"
                }
            }, probeThreshold: {
                serializedName: "properties.probeThreshold",
                type: {
                    name: "Number"
                }
            }, requestPath: {
                serializedName: "properties.requestPath",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const InboundNatPool = {
    type: {
        name: "Composite",
        className: "InboundNatPool",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfiguration: {
                serializedName: "properties.frontendIPConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, frontendPortRangeStart: {
                serializedName: "properties.frontendPortRangeStart",
                type: {
                    name: "Number"
                }
            }, frontendPortRangeEnd: {
                serializedName: "properties.frontendPortRangeEnd",
                type: {
                    name: "Number"
                }
            }, backendPort: {
                serializedName: "properties.backendPort",
                type: {
                    name: "Number"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, enableFloatingIP: {
                serializedName: "properties.enableFloatingIP",
                type: {
                    name: "Boolean"
                }
            }, enableTcpReset: {
                serializedName: "properties.enableTcpReset",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const OutboundRule = {
    type: {
        name: "Composite",
        className: "OutboundRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, allocatedOutboundPorts: {
                serializedName: "properties.allocatedOutboundPorts",
                type: {
                    name: "Number"
                }
            }, frontendIPConfigurations: {
                serializedName: "properties.frontendIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, backendAddressPool: {
                serializedName: "properties.backendAddressPool",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, enableTcpReset: {
                serializedName: "properties.enableTcpReset",
                type: {
                    name: "Boolean"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            } })
    }
};
const ContainerNetworkInterfaceConfiguration = {
    type: {
        name: "Composite",
        className: "ContainerNetworkInterfaceConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IPConfigurationProfile"
                        }
                    }
                }
            }, containerNetworkInterfaces: {
                serializedName: "properties.containerNetworkInterfaces",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const Container = {
    type: {
        name: "Composite",
        className: "Container",
        modelProperties: Object.assign({}, SubResource.type.modelProperties)
    }
};
const ContainerNetworkInterface = {
    type: {
        name: "Composite",
        className: "ContainerNetworkInterface",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, containerNetworkInterfaceConfiguration: {
                serializedName: "properties.containerNetworkInterfaceConfiguration",
                type: {
                    name: "Composite",
                    className: "ContainerNetworkInterfaceConfiguration"
                }
            }, container: {
                serializedName: "properties.container",
                type: {
                    name: "Composite",
                    className: "Container"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerNetworkInterfaceIpConfiguration"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualApplianceSite = {
    type: {
        name: "Composite",
        className: "VirtualApplianceSite",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, o365Policy: {
                serializedName: "properties.o365Policy",
                type: {
                    name: "Composite",
                    className: "Office365PolicyProperties"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const InboundSecurityRule = {
    type: {
        name: "Composite",
        className: "InboundSecurityRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundSecurityRules"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateDnsZoneGroup = {
    type: {
        name: "Composite",
        className: "PrivateDnsZoneGroup",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateDnsZoneConfigs: {
                serializedName: "properties.privateDnsZoneConfigs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateDnsZoneConfig"
                        }
                    }
                }
            } })
    }
};
const RouteFilterRule = {
    type: {
        name: "Composite",
        className: "RouteFilterRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, access: {
                serializedName: "properties.access",
                type: {
                    name: "String"
                }
            }, routeFilterRuleType: {
                serializedName: "properties.routeFilterRuleType",
                type: {
                    name: "String"
                }
            }, communities: {
                serializedName: "properties.communities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkPeering = {
    type: {
        name: "Composite",
        className: "VirtualNetworkPeering",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }, allowVirtualNetworkAccess: {
                serializedName: "properties.allowVirtualNetworkAccess",
                type: {
                    name: "Boolean"
                }
            }, allowForwardedTraffic: {
                serializedName: "properties.allowForwardedTraffic",
                type: {
                    name: "Boolean"
                }
            }, allowGatewayTransit: {
                serializedName: "properties.allowGatewayTransit",
                type: {
                    name: "Boolean"
                }
            }, useRemoteGateways: {
                serializedName: "properties.useRemoteGateways",
                type: {
                    name: "Boolean"
                }
            }, remoteVirtualNetwork: {
                serializedName: "properties.remoteVirtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, remoteAddressSpace: {
                serializedName: "properties.remoteAddressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, remoteVirtualNetworkAddressSpace: {
                serializedName: "properties.remoteVirtualNetworkAddressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, remoteBgpCommunities: {
                serializedName: "properties.remoteBgpCommunities",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkBgpCommunities"
                }
            }, remoteVirtualNetworkEncryption: {
                serializedName: "properties.remoteVirtualNetworkEncryption",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkEncryption"
                }
            }, peeringState: {
                serializedName: "properties.peeringState",
                type: {
                    name: "String"
                }
            }, peeringSyncLevel: {
                serializedName: "properties.peeringSyncLevel",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, doNotVerifyRemoteGateways: {
                serializedName: "properties.doNotVerifyRemoteGateways",
                type: {
                    name: "Boolean"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkGatewayIPConfiguration = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayIPConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnClientRootCertificate = {
    type: {
        name: "Composite",
        className: "VpnClientRootCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicCertData: {
                serializedName: "properties.publicCertData",
                required: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnClientRevokedCertificate = {
    type: {
        name: "Composite",
        className: "VpnClientRevokedCertificate",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, thumbprint: {
                serializedName: "properties.thumbprint",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VngClientConnectionConfiguration = {
    type: {
        name: "Composite",
        className: "VngClientConnectionConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnClientAddressPool: {
                serializedName: "properties.vpnClientAddressPool",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, virtualNetworkGatewayPolicyGroups: {
                serializedName: "properties.virtualNetworkGatewayPolicyGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkGatewayPolicyGroup = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayPolicyGroup",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isDefault: {
                serializedName: "properties.isDefault",
                type: {
                    name: "Boolean"
                }
            }, priority: {
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, policyMembers: {
                serializedName: "properties.policyMembers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayPolicyGroupMember"
                        }
                    }
                }
            }, vngClientConnectionConfigurations: {
                serializedName: "properties.vngClientConnectionConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkGatewayNatRule = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayNatRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, mode: {
                serializedName: "properties.mode",
                type: {
                    name: "String"
                }
            }, internalMappings: {
                serializedName: "properties.internalMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnNatRuleMapping"
                        }
                    }
                }
            }, externalMappings: {
                serializedName: "properties.externalMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnNatRuleMapping"
                        }
                    }
                }
            }, ipConfigurationId: {
                serializedName: "properties.ipConfigurationId",
                type: {
                    name: "String"
                }
            } })
    }
};
const ConnectionSharedKey = {
    type: {
        name: "Composite",
        className: "ConnectionSharedKey",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualRouterPeering = {
    type: {
        name: "Composite",
        className: "VirtualRouterPeering",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peerAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.peerAsn",
                type: {
                    name: "Number"
                }
            }, peerIp: {
                serializedName: "properties.peerIp",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnSiteLink = {
    type: {
        name: "Composite",
        className: "VpnSiteLink",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, linkProperties: {
                serializedName: "properties.linkProperties",
                type: {
                    name: "Composite",
                    className: "VpnLinkProviderProperties"
                }
            }, ipAddress: {
                serializedName: "properties.ipAddress",
                type: {
                    name: "String"
                }
            }, fqdn: {
                serializedName: "properties.fqdn",
                type: {
                    name: "String"
                }
            }, bgpProperties: {
                serializedName: "properties.bgpProperties",
                type: {
                    name: "Composite",
                    className: "VpnLinkBgpSettings"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnServerConfigurationPolicyGroup = {
    type: {
        name: "Composite",
        className: "VpnServerConfigurationPolicyGroup",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isDefault: {
                serializedName: "properties.isDefault",
                type: {
                    name: "Boolean"
                }
            }, priority: {
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, policyMembers: {
                serializedName: "properties.policyMembers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigurationPolicyGroupMember"
                        }
                    }
                }
            }, p2SConnectionConfigurations: {
                serializedName: "properties.p2SConnectionConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const P2SConnectionConfiguration = {
    type: {
        name: "Composite",
        className: "P2SConnectionConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnClientAddressPool: {
                serializedName: "properties.vpnClientAddressPool",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, routingConfiguration: {
                serializedName: "properties.routingConfiguration",
                type: {
                    name: "Composite",
                    className: "RoutingConfiguration"
                }
            }, enableInternetSecurity: {
                serializedName: "properties.enableInternetSecurity",
                type: {
                    name: "Boolean"
                }
            }, configurationPolicyGroupAssociations: {
                serializedName: "properties.configurationPolicyGroupAssociations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, previousConfigurationPolicyGroupAssociations: {
                serializedName: "properties.previousConfigurationPolicyGroupAssociations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigurationPolicyGroup"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualHubRouteTableV2 = {
    type: {
        name: "Composite",
        className: "VirtualHubRouteTableV2",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routes: {
                serializedName: "properties.routes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubRouteV2"
                        }
                    }
                }
            }, attachedConnections: {
                serializedName: "properties.attachedConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RouteMap = {
    type: {
        name: "Composite",
        className: "RouteMap",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, associatedInboundConnections: {
                serializedName: "properties.associatedInboundConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, associatedOutboundConnections: {
                serializedName: "properties.associatedOutboundConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteMapRule"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const HubVirtualNetworkConnection = {
    type: {
        name: "Composite",
        className: "HubVirtualNetworkConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, remoteVirtualNetwork: {
                serializedName: "properties.remoteVirtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, allowHubToRemoteVnetTransit: {
                serializedName: "properties.allowHubToRemoteVnetTransit",
                type: {
                    name: "Boolean"
                }
            }, allowRemoteVnetToUseHubVnetGateways: {
                serializedName: "properties.allowRemoteVnetToUseHubVnetGateways",
                type: {
                    name: "Boolean"
                }
            }, enableInternetSecurity: {
                serializedName: "properties.enableInternetSecurity",
                type: {
                    name: "Boolean"
                }
            }, routingConfiguration: {
                serializedName: "properties.routingConfiguration",
                type: {
                    name: "Composite",
                    className: "RoutingConfiguration"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnSiteLinkConnection = {
    type: {
        name: "Composite",
        className: "VpnSiteLinkConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnSiteLink: {
                serializedName: "properties.vpnSiteLink",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, vpnLinkConnectionMode: {
                serializedName: "properties.vpnLinkConnectionMode",
                type: {
                    name: "String"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnConnectionProtocolType: {
                serializedName: "properties.vpnConnectionProtocolType",
                type: {
                    name: "String"
                }
            }, ingressBytesTransferred: {
                serializedName: "properties.ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, egressBytesTransferred: {
                serializedName: "properties.egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, connectionBandwidth: {
                serializedName: "properties.connectionBandwidth",
                type: {
                    name: "Number"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, vpnGatewayCustomBgpAddresses: {
                serializedName: "properties.vpnGatewayCustomBgpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayCustomBgpIpAddressIpConfiguration"
                        }
                    }
                }
            }, usePolicyBasedTrafficSelectors: {
                serializedName: "properties.usePolicyBasedTrafficSelectors",
                type: {
                    name: "Boolean"
                }
            }, ipsecPolicies: {
                serializedName: "properties.ipsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, enableRateLimiting: {
                serializedName: "properties.enableRateLimiting",
                type: {
                    name: "Boolean"
                }
            }, useLocalAzureIpAddress: {
                serializedName: "properties.useLocalAzureIpAddress",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ingressNatRules: {
                serializedName: "properties.ingressNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, egressNatRules: {
                serializedName: "properties.egressNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const VpnConnection = {
    type: {
        name: "Composite",
        className: "VpnConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, remoteVpnSite: {
                serializedName: "properties.remoteVpnSite",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, dpdTimeoutSeconds: {
                serializedName: "properties.dpdTimeoutSeconds",
                type: {
                    name: "Number"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnConnectionProtocolType: {
                serializedName: "properties.vpnConnectionProtocolType",
                type: {
                    name: "String"
                }
            }, ingressBytesTransferred: {
                serializedName: "properties.ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, egressBytesTransferred: {
                serializedName: "properties.egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, connectionBandwidth: {
                serializedName: "properties.connectionBandwidth",
                type: {
                    name: "Number"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, usePolicyBasedTrafficSelectors: {
                serializedName: "properties.usePolicyBasedTrafficSelectors",
                type: {
                    name: "Boolean"
                }
            }, ipsecPolicies: {
                serializedName: "properties.ipsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, trafficSelectorPolicies: {
                serializedName: "properties.trafficSelectorPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrafficSelectorPolicy"
                        }
                    }
                }
            }, enableRateLimiting: {
                serializedName: "properties.enableRateLimiting",
                type: {
                    name: "Boolean"
                }
            }, enableInternetSecurity: {
                serializedName: "properties.enableInternetSecurity",
                type: {
                    name: "Boolean"
                }
            }, useLocalAzureIpAddress: {
                serializedName: "properties.useLocalAzureIpAddress",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnLinkConnections: {
                serializedName: "properties.vpnLinkConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSiteLinkConnection"
                        }
                    }
                }
            }, routingConfiguration: {
                serializedName: "properties.routingConfiguration",
                type: {
                    name: "Composite",
                    className: "RoutingConfiguration"
                }
            } })
    }
};
const VpnGatewayNatRule = {
    type: {
        name: "Composite",
        className: "VpnGatewayNatRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, mode: {
                serializedName: "properties.mode",
                type: {
                    name: "String"
                }
            }, internalMappings: {
                serializedName: "properties.internalMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnNatRuleMapping"
                        }
                    }
                }
            }, externalMappings: {
                serializedName: "properties.externalMappings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnNatRuleMapping"
                        }
                    }
                }
            }, ipConfigurationId: {
                serializedName: "properties.ipConfigurationId",
                type: {
                    name: "String"
                }
            }, egressVpnSiteLinkConnections: {
                serializedName: "properties.egressVpnSiteLinkConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, ingressVpnSiteLinkConnections: {
                serializedName: "properties.ingressVpnSiteLinkConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const ExpressRouteConnection = {
    type: {
        name: "Composite",
        className: "ExpressRouteConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteCircuitPeering: {
                serializedName: "properties.expressRouteCircuitPeering",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitPeeringId"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, enableInternetSecurity: {
                serializedName: "properties.enableInternetSecurity",
                type: {
                    name: "Boolean"
                }
            }, expressRouteGatewayBypass: {
                serializedName: "properties.expressRouteGatewayBypass",
                type: {
                    name: "Boolean"
                }
            }, enablePrivateLinkFastPath: {
                serializedName: "properties.enablePrivateLinkFastPath",
                type: {
                    name: "Boolean"
                }
            }, routingConfiguration: {
                serializedName: "properties.routingConfiguration",
                type: {
                    name: "Composite",
                    className: "RoutingConfiguration"
                }
            } })
    }
};
const BgpConnection = {
    type: {
        name: "Composite",
        className: "BgpConnection",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peerAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.peerAsn",
                type: {
                    name: "Number"
                }
            }, peerIp: {
                serializedName: "properties.peerIp",
                type: {
                    name: "String"
                }
            }, hubVirtualNetworkConnection: {
                serializedName: "properties.hubVirtualNetworkConnection",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectionState: {
                serializedName: "properties.connectionState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const HubIpConfiguration = {
    type: {
        name: "Composite",
        className: "HubIpConfiguration",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateIPAddress: {
                serializedName: "properties.privateIPAddress",
                type: {
                    name: "String"
                }
            }, privateIPAllocationMethod: {
                serializedName: "properties.privateIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, publicIPAddress: {
                serializedName: "properties.publicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const HubRouteTable = {
    type: {
        name: "Composite",
        className: "HubRouteTable",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routes: {
                serializedName: "properties.routes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "HubRoute"
                        }
                    }
                }
            }, labels: {
                serializedName: "properties.labels",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, associatedConnections: {
                serializedName: "properties.associatedConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, propagatingConnections: {
                serializedName: "properties.propagatingConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RoutingIntent = {
    type: {
        name: "Composite",
        className: "RoutingIntent",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routingPolicies: {
                serializedName: "properties.routingPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RoutingPolicy"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PatchRouteFilterRule = {
    type: {
        name: "Composite",
        className: "PatchRouteFilterRule",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, access: {
                serializedName: "properties.access",
                type: {
                    name: "String"
                }
            }, routeFilterRuleType: {
                serializedName: "properties.routeFilterRuleType",
                type: {
                    name: "String"
                }
            }, communities: {
                serializedName: "properties.communities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PatchRouteFilter = {
    type: {
        name: "Composite",
        className: "PatchRouteFilter",
        modelProperties: Object.assign(Object.assign({}, SubResource.type.modelProperties), { name: {
                serializedName: "name",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, type: {
                serializedName: "type",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteFilterRule"
                        }
                    }
                }
            }, peerings: {
                serializedName: "properties.peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, ipv6Peerings: {
                serializedName: "properties.ipv6Peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationSecurityGroup = {
    type: {
        name: "Composite",
        className: "ApplicationSecurityGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateEndpoint = {
    type: {
        name: "Composite",
        className: "PrivateEndpoint",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "Subnet"
                }
            }, networkInterfaces: {
                serializedName: "properties.networkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateLinkServiceConnections: {
                serializedName: "properties.privateLinkServiceConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkServiceConnection"
                        }
                    }
                }
            }, manualPrivateLinkServiceConnections: {
                serializedName: "properties.manualPrivateLinkServiceConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkServiceConnection"
                        }
                    }
                }
            }, customDnsConfigs: {
                serializedName: "properties.customDnsConfigs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "CustomDnsConfigPropertiesFormat"
                        }
                    }
                }
            }, applicationSecurityGroups: {
                serializedName: "properties.applicationSecurityGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationSecurityGroup"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointIPConfiguration"
                        }
                    }
                }
            }, customNetworkInterfaceName: {
                serializedName: "properties.customNetworkInterfaceName",
                type: {
                    name: "String"
                }
            } })
    }
};
const PrivateLinkService = {
    type: {
        name: "Composite",
        className: "PrivateLinkService",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, loadBalancerFrontendIpConfigurations: {
                serializedName: "properties.loadBalancerFrontendIpConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendIPConfiguration"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateLinkServiceIpConfiguration"
                        }
                    }
                }
            }, networkInterfaces: {
                serializedName: "properties.networkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "PrivateEndpointConnection"
                        }
                    }
                }
            }, visibility: {
                serializedName: "properties.visibility",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServicePropertiesVisibility"
                }
            }, autoApproval: {
                serializedName: "properties.autoApproval",
                type: {
                    name: "Composite",
                    className: "PrivateLinkServicePropertiesAutoApproval"
                }
            }, fqdns: {
                serializedName: "properties.fqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, alias: {
                serializedName: "properties.alias",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, enableProxyProtocol: {
                serializedName: "properties.enableProxyProtocol",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const NetworkInterface = {
    type: {
        name: "Composite",
        className: "NetworkInterface",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualMachine: {
                serializedName: "properties.virtualMachine",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, networkSecurityGroup: {
                serializedName: "properties.networkSecurityGroup",
                type: {
                    name: "Composite",
                    className: "NetworkSecurityGroup"
                }
            }, privateEndpoint: {
                serializedName: "properties.privateEndpoint",
                type: {
                    name: "Composite",
                    className: "PrivateEndpoint"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceIPConfiguration"
                        }
                    }
                }
            }, tapConfigurations: {
                serializedName: "properties.tapConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceTapConfiguration"
                        }
                    }
                }
            }, dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceDnsSettings"
                }
            }, macAddress: {
                serializedName: "properties.macAddress",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, primary: {
                serializedName: "properties.primary",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, vnetEncryptionSupported: {
                serializedName: "properties.vnetEncryptionSupported",
                readOnly: true,
                type: {
                    name: "Boolean"
                }
            }, enableAcceleratedNetworking: {
                serializedName: "properties.enableAcceleratedNetworking",
                type: {
                    name: "Boolean"
                }
            }, disableTcpStateTracking: {
                serializedName: "properties.disableTcpStateTracking",
                type: {
                    name: "Boolean"
                }
            }, enableIPForwarding: {
                serializedName: "properties.enableIPForwarding",
                type: {
                    name: "Boolean"
                }
            }, hostedWorkloads: {
                serializedName: "properties.hostedWorkloads",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, dscpConfiguration: {
                serializedName: "properties.dscpConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, workloadType: {
                serializedName: "properties.workloadType",
                type: {
                    name: "String"
                }
            }, nicType: {
                serializedName: "properties.nicType",
                type: {
                    name: "String"
                }
            }, privateLinkService: {
                serializedName: "properties.privateLinkService",
                type: {
                    name: "Composite",
                    className: "PrivateLinkService"
                }
            }, migrationPhase: {
                serializedName: "properties.migrationPhase",
                type: {
                    name: "String"
                }
            }, auxiliaryMode: {
                serializedName: "properties.auxiliaryMode",
                type: {
                    name: "String"
                }
            } })
    }
};
const FlowLog = {
    type: {
        name: "Composite",
        className: "FlowLog",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, targetResourceId: {
                serializedName: "properties.targetResourceId",
                type: {
                    name: "String"
                }
            }, targetResourceGuid: {
                serializedName: "properties.targetResourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, storageId: {
                serializedName: "properties.storageId",
                type: {
                    name: "String"
                }
            }, enabled: {
                serializedName: "properties.enabled",
                type: {
                    name: "Boolean"
                }
            }, retentionPolicy: {
                serializedName: "properties.retentionPolicy",
                type: {
                    name: "Composite",
                    className: "RetentionPolicyParameters"
                }
            }, format: {
                serializedName: "properties.format",
                type: {
                    name: "Composite",
                    className: "FlowLogFormatParameters"
                }
            }, flowAnalyticsConfiguration: {
                serializedName: "properties.flowAnalyticsConfiguration",
                type: {
                    name: "Composite",
                    className: "TrafficAnalyticsProperties"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkSecurityGroup = {
    type: {
        name: "Composite",
        className: "NetworkSecurityGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, flushConnection: {
                serializedName: "properties.flushConnection",
                type: {
                    name: "Boolean"
                }
            }, securityRules: {
                serializedName: "properties.securityRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            }, defaultSecurityRules: {
                serializedName: "properties.defaultSecurityRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SecurityRule"
                        }
                    }
                }
            }, networkInterfaces: {
                serializedName: "properties.networkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            }, subnets: {
                serializedName: "properties.subnets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            }, flowLogs: {
                serializedName: "properties.flowLogs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FlowLog"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const RouteTable = {
    type: {
        name: "Composite",
        className: "RouteTable",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, routes: {
                serializedName: "properties.routes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Route"
                        }
                    }
                }
            }, subnets: {
                serializedName: "properties.subnets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            }, disableBgpRoutePropagation: {
                serializedName: "properties.disableBgpRoutePropagation",
                type: {
                    name: "Boolean"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ServiceEndpointPolicy = {
    type: {
        name: "Composite",
        className: "ServiceEndpointPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serviceEndpointPolicyDefinitions: {
                serializedName: "properties.serviceEndpointPolicyDefinitions",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ServiceEndpointPolicyDefinition"
                        }
                    }
                }
            }, subnets: {
                serializedName: "properties.subnets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, serviceAlias: {
                serializedName: "properties.serviceAlias",
                type: {
                    name: "String"
                }
            }, contextualServiceEndpointPolicies: {
                serializedName: "properties.contextualServiceEndpointPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const NatGateway = {
    type: {
        name: "Composite",
        className: "NatGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "NatGatewaySku"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, publicIpAddresses: {
                serializedName: "properties.publicIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, publicIpPrefixes: {
                serializedName: "properties.publicIpPrefixes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, subnets: {
                serializedName: "properties.subnets",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PublicIPAddress = {
    type: {
        name: "Composite",
        className: "PublicIPAddress",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "PublicIPAddressSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, publicIPAllocationMethod: {
                serializedName: "properties.publicIPAllocationMethod",
                type: {
                    name: "String"
                }
            }, publicIPAddressVersion: {
                serializedName: "properties.publicIPAddressVersion",
                type: {
                    name: "String"
                }
            }, ipConfiguration: {
                serializedName: "properties.ipConfiguration",
                type: {
                    name: "Composite",
                    className: "IPConfiguration"
                }
            }, dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "PublicIPAddressDnsSettings"
                }
            }, ddosSettings: {
                serializedName: "properties.ddosSettings",
                type: {
                    name: "Composite",
                    className: "DdosSettings"
                }
            }, ipTags: {
                serializedName: "properties.ipTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpTag"
                        }
                    }
                }
            }, ipAddress: {
                serializedName: "properties.ipAddress",
                type: {
                    name: "String"
                }
            }, publicIPPrefix: {
                serializedName: "properties.publicIPPrefix",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, idleTimeoutInMinutes: {
                serializedName: "properties.idleTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, servicePublicIPAddress: {
                serializedName: "properties.servicePublicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, natGateway: {
                serializedName: "properties.natGateway",
                type: {
                    name: "Composite",
                    className: "NatGateway"
                }
            }, migrationPhase: {
                serializedName: "properties.migrationPhase",
                type: {
                    name: "String"
                }
            }, linkedPublicIPAddress: {
                serializedName: "properties.linkedPublicIPAddress",
                type: {
                    name: "Composite",
                    className: "PublicIPAddress"
                }
            }, deleteOption: {
                serializedName: "properties.deleteOption",
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkTap = {
    type: {
        name: "Composite",
        className: "VirtualNetworkTap",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, networkInterfaceTapConfigurations: {
                serializedName: "properties.networkInterfaceTapConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterfaceTapConfiguration"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, destinationNetworkInterfaceIPConfiguration: {
                serializedName: "properties.destinationNetworkInterfaceIPConfiguration",
                type: {
                    name: "Composite",
                    className: "NetworkInterfaceIPConfiguration"
                }
            }, destinationLoadBalancerFrontEndIPConfiguration: {
                serializedName: "properties.destinationLoadBalancerFrontEndIPConfiguration",
                type: {
                    name: "Composite",
                    className: "FrontendIPConfiguration"
                }
            }, destinationPort: {
                serializedName: "properties.destinationPort",
                type: {
                    name: "Number"
                }
            } })
    }
};
const ApplicationGateway = {
    type: {
        name: "Composite",
        className: "ApplicationGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewaySku"
                }
            }, sslPolicy: {
                serializedName: "properties.sslPolicy",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewaySslPolicy"
                }
            }, operationalState: {
                serializedName: "properties.operationalState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, gatewayIPConfigurations: {
                serializedName: "properties.gatewayIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayIPConfiguration"
                        }
                    }
                }
            }, authenticationCertificates: {
                serializedName: "properties.authenticationCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayAuthenticationCertificate"
                        }
                    }
                }
            }, trustedRootCertificates: {
                serializedName: "properties.trustedRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayTrustedRootCertificate"
                        }
                    }
                }
            }, trustedClientCertificates: {
                serializedName: "properties.trustedClientCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayTrustedClientCertificate"
                        }
                    }
                }
            }, sslCertificates: {
                serializedName: "properties.sslCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewaySslCertificate"
                        }
                    }
                }
            }, frontendIPConfigurations: {
                serializedName: "properties.frontendIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFrontendIPConfiguration"
                        }
                    }
                }
            }, frontendPorts: {
                serializedName: "properties.frontendPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFrontendPort"
                        }
                    }
                }
            }, probes: {
                serializedName: "properties.probes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayProbe"
                        }
                    }
                }
            }, backendAddressPools: {
                serializedName: "properties.backendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendAddressPool"
                        }
                    }
                }
            }, backendHttpSettingsCollection: {
                serializedName: "properties.backendHttpSettingsCollection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendHttpSettings"
                        }
                    }
                }
            }, backendSettingsCollection: {
                serializedName: "properties.backendSettingsCollection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayBackendSettings"
                        }
                    }
                }
            }, httpListeners: {
                serializedName: "properties.httpListeners",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayHttpListener"
                        }
                    }
                }
            }, listeners: {
                serializedName: "properties.listeners",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayListener"
                        }
                    }
                }
            }, sslProfiles: {
                serializedName: "properties.sslProfiles",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewaySslProfile"
                        }
                    }
                }
            }, urlPathMaps: {
                serializedName: "properties.urlPathMaps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayUrlPathMap"
                        }
                    }
                }
            }, requestRoutingRules: {
                serializedName: "properties.requestRoutingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRequestRoutingRule"
                        }
                    }
                }
            }, routingRules: {
                serializedName: "properties.routingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRoutingRule"
                        }
                    }
                }
            }, rewriteRuleSets: {
                serializedName: "properties.rewriteRuleSets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRewriteRuleSet"
                        }
                    }
                }
            }, redirectConfigurations: {
                serializedName: "properties.redirectConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayRedirectConfiguration"
                        }
                    }
                }
            }, webApplicationFirewallConfiguration: {
                serializedName: "properties.webApplicationFirewallConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayWebApplicationFirewallConfiguration"
                }
            }, firewallPolicy: {
                serializedName: "properties.firewallPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, enableHttp2: {
                serializedName: "properties.enableHttp2",
                type: {
                    name: "Boolean"
                }
            }, enableFips: {
                serializedName: "properties.enableFips",
                type: {
                    name: "Boolean"
                }
            }, autoscaleConfiguration: {
                serializedName: "properties.autoscaleConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayAutoscaleConfiguration"
                }
            }, privateLinkConfigurations: {
                serializedName: "properties.privateLinkConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateLinkConfiguration"
                        }
                    }
                }
            }, privateEndpointConnections: {
                serializedName: "properties.privateEndpointConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayPrivateEndpointConnection"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, customErrorConfigurations: {
                serializedName: "properties.customErrorConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayCustomError"
                        }
                    }
                }
            }, forceFirewallPolicyAssociation: {
                serializedName: "properties.forceFirewallPolicyAssociation",
                type: {
                    name: "Boolean"
                }
            }, loadDistributionPolicies: {
                serializedName: "properties.loadDistributionPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayLoadDistributionPolicy"
                        }
                    }
                }
            }, globalConfiguration: {
                serializedName: "properties.globalConfiguration",
                type: {
                    name: "Composite",
                    className: "ApplicationGatewayGlobalConfiguration"
                }
            } })
    }
};
const ApplicationGatewayFirewallRuleSet = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayFirewallRuleSet",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ruleSetType: {
                serializedName: "properties.ruleSetType",
                type: {
                    name: "String"
                }
            }, ruleSetVersion: {
                serializedName: "properties.ruleSetVersion",
                type: {
                    name: "String"
                }
            }, ruleGroups: {
                serializedName: "properties.ruleGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGatewayFirewallRuleGroup"
                        }
                    }
                }
            }, tiers: {
                serializedName: "properties.tiers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const ApplicationGatewayAvailableSslOptions = {
    type: {
        name: "Composite",
        className: "ApplicationGatewayAvailableSslOptions",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { predefinedPolicies: {
                serializedName: "properties.predefinedPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, defaultPolicy: {
                serializedName: "properties.defaultPolicy",
                type: {
                    name: "String"
                }
            }, availableCipherSuites: {
                serializedName: "properties.availableCipherSuites",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, availableProtocols: {
                serializedName: "properties.availableProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const AzureFirewall = {
    type: {
        name: "Composite",
        className: "AzureFirewall",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, applicationRuleCollections: {
                serializedName: "properties.applicationRuleCollections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallApplicationRuleCollection"
                        }
                    }
                }
            }, natRuleCollections: {
                serializedName: "properties.natRuleCollections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallNatRuleCollection"
                        }
                    }
                }
            }, networkRuleCollections: {
                serializedName: "properties.networkRuleCollections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallNetworkRuleCollection"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallIPConfiguration"
                        }
                    }
                }
            }, managementIpConfiguration: {
                serializedName: "properties.managementIpConfiguration",
                type: {
                    name: "Composite",
                    className: "AzureFirewallIPConfiguration"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, threatIntelMode: {
                serializedName: "properties.threatIntelMode",
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, firewallPolicy: {
                serializedName: "properties.firewallPolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, hubIPAddresses: {
                serializedName: "properties.hubIPAddresses",
                type: {
                    name: "Composite",
                    className: "HubIPAddresses"
                }
            }, ipGroups: {
                serializedName: "properties.ipGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AzureFirewallIpGroups"
                        }
                    }
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "AzureFirewallSku"
                }
            }, additionalProperties: {
                serializedName: "properties.additionalProperties",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const AzureFirewallFqdnTag = {
    type: {
        name: "Composite",
        className: "AzureFirewallFqdnTag",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, fqdnTagName: {
                serializedName: "properties.fqdnTagName",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const BastionHost = {
    type: {
        name: "Composite",
        className: "BastionHost",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "Sku"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BastionHostIPConfiguration"
                        }
                    }
                }
            }, dnsName: {
                serializedName: "properties.dnsName",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, scaleUnits: {
                constraints: {
                    InclusiveMaximum: 50,
                    InclusiveMinimum: 2
                },
                serializedName: "properties.scaleUnits",
                type: {
                    name: "Number"
                }
            }, disableCopyPaste: {
                defaultValue: false,
                serializedName: "properties.disableCopyPaste",
                type: {
                    name: "Boolean"
                }
            }, enableFileCopy: {
                defaultValue: false,
                serializedName: "properties.enableFileCopy",
                type: {
                    name: "Boolean"
                }
            }, enableIpConnect: {
                defaultValue: false,
                serializedName: "properties.enableIpConnect",
                type: {
                    name: "Boolean"
                }
            }, enableShareableLink: {
                defaultValue: false,
                serializedName: "properties.enableShareableLink",
                type: {
                    name: "Boolean"
                }
            }, enableTunneling: {
                defaultValue: false,
                serializedName: "properties.enableTunneling",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const Vm = {
    type: {
        name: "Composite",
        className: "Vm",
        modelProperties: Object.assign({}, Resource.type.modelProperties)
    }
};
const CustomIpPrefix = {
    type: {
        name: "Composite",
        className: "CustomIpPrefix",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, asn: {
                serializedName: "properties.asn",
                type: {
                    name: "String"
                }
            }, cidr: {
                serializedName: "properties.cidr",
                type: {
                    name: "String"
                }
            }, signedMessage: {
                serializedName: "properties.signedMessage",
                type: {
                    name: "String"
                }
            }, authorizationMessage: {
                serializedName: "properties.authorizationMessage",
                type: {
                    name: "String"
                }
            }, customIpPrefixParent: {
                serializedName: "properties.customIpPrefixParent",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, childCustomIpPrefixes: {
                serializedName: "properties.childCustomIpPrefixes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, commissionedState: {
                serializedName: "properties.commissionedState",
                type: {
                    name: "String"
                }
            }, expressRouteAdvertise: {
                serializedName: "properties.expressRouteAdvertise",
                type: {
                    name: "Boolean"
                }
            }, geo: {
                serializedName: "properties.geo",
                type: {
                    name: "String"
                }
            }, noInternetAdvertise: {
                serializedName: "properties.noInternetAdvertise",
                type: {
                    name: "Boolean"
                }
            }, prefixType: {
                serializedName: "properties.prefixType",
                type: {
                    name: "String"
                }
            }, publicIpPrefixes: {
                serializedName: "properties.publicIpPrefixes",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, failedReason: {
                serializedName: "properties.failedReason",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DdosCustomPolicy = {
    type: {
        name: "Composite",
        className: "DdosCustomPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DscpConfiguration = {
    type: {
        name: "Composite",
        className: "DscpConfiguration",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, markings: {
                serializedName: "properties.markings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }, sourceIpRanges: {
                serializedName: "properties.sourceIpRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosIpRange"
                        }
                    }
                }
            }, destinationIpRanges: {
                serializedName: "properties.destinationIpRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosIpRange"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosPortRange"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosPortRange"
                        }
                    }
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, qosDefinitionCollection: {
                serializedName: "properties.qosDefinitionCollection",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "QosDefinition"
                        }
                    }
                }
            }, qosCollectionId: {
                serializedName: "properties.qosCollectionId",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, associatedNetworkInterfaces: {
                serializedName: "properties.associatedNetworkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkInterface"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCircuit = {
    type: {
        name: "Composite",
        className: "ExpressRouteCircuit",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, allowClassicOperations: {
                serializedName: "properties.allowClassicOperations",
                type: {
                    name: "Boolean"
                }
            }, circuitProvisioningState: {
                serializedName: "properties.circuitProvisioningState",
                type: {
                    name: "String"
                }
            }, serviceProviderProvisioningState: {
                serializedName: "properties.serviceProviderProvisioningState",
                type: {
                    name: "String"
                }
            }, authorizations: {
                serializedName: "properties.authorizations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitAuthorization"
                        }
                    }
                }
            }, peerings: {
                serializedName: "properties.peerings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, serviceKey: {
                serializedName: "properties.serviceKey",
                type: {
                    name: "String"
                }
            }, serviceProviderNotes: {
                serializedName: "properties.serviceProviderNotes",
                type: {
                    name: "String"
                }
            }, serviceProviderProperties: {
                serializedName: "properties.serviceProviderProperties",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitServiceProviderProperties"
                }
            }, expressRoutePort: {
                serializedName: "properties.expressRoutePort",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, bandwidthInGbps: {
                serializedName: "properties.bandwidthInGbps",
                type: {
                    name: "Number"
                }
            }, stag: {
                serializedName: "properties.stag",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, gatewayManagerEtag: {
                serializedName: "properties.gatewayManagerEtag",
                type: {
                    name: "String"
                }
            }, globalReachEnabled: {
                serializedName: "properties.globalReachEnabled",
                type: {
                    name: "Boolean"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, authorizationStatus: {
                serializedName: "properties.authorizationStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteServiceProvider = {
    type: {
        name: "Composite",
        className: "ExpressRouteServiceProvider",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { peeringLocations: {
                serializedName: "properties.peeringLocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, bandwidthsOffered: {
                serializedName: "properties.bandwidthsOffered",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteServiceProviderBandwidthsOffered"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteCrossConnection = {
    type: {
        name: "Composite",
        className: "ExpressRouteCrossConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, primaryAzurePort: {
                serializedName: "properties.primaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, secondaryAzurePort: {
                serializedName: "properties.secondaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sTag: {
                serializedName: "properties.sTag",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, peeringLocation: {
                serializedName: "properties.peeringLocation",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, bandwidthInMbps: {
                serializedName: "properties.bandwidthInMbps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, expressRouteCircuit: {
                serializedName: "properties.expressRouteCircuit",
                type: {
                    name: "Composite",
                    className: "ExpressRouteCircuitReference"
                }
            }, serviceProviderProvisioningState: {
                serializedName: "properties.serviceProviderProvisioningState",
                type: {
                    name: "String"
                }
            }, serviceProviderNotes: {
                serializedName: "properties.serviceProviderNotes",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peerings: {
                serializedName: "properties.peerings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCrossConnectionPeering"
                        }
                    }
                }
            } })
    }
};
const ExpressRoutePortsLocation = {
    type: {
        name: "Composite",
        className: "ExpressRoutePortsLocation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { address: {
                serializedName: "properties.address",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, contact: {
                serializedName: "properties.contact",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, availableBandwidths: {
                serializedName: "properties.availableBandwidths",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRoutePortsLocationBandwidths"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRoutePort = {
    type: {
        name: "Composite",
        className: "ExpressRoutePort",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, peeringLocation: {
                serializedName: "properties.peeringLocation",
                type: {
                    name: "String"
                }
            }, bandwidthInGbps: {
                serializedName: "properties.bandwidthInGbps",
                type: {
                    name: "Number"
                }
            }, provisionedBandwidthInGbps: {
                serializedName: "properties.provisionedBandwidthInGbps",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, mtu: {
                serializedName: "properties.mtu",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, encapsulation: {
                serializedName: "properties.encapsulation",
                type: {
                    name: "String"
                }
            }, etherType: {
                serializedName: "properties.etherType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, allocationDate: {
                serializedName: "properties.allocationDate",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, links: {
                serializedName: "properties.links",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteLink"
                        }
                    }
                }
            }, circuits: {
                serializedName: "properties.circuits",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, billingType: {
                serializedName: "properties.billingType",
                type: {
                    name: "String"
                }
            } })
    }
};
const ExpressRouteProviderPort = {
    type: {
        name: "Composite",
        className: "ExpressRouteProviderPort",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, portPairDescriptor: {
                serializedName: "properties.portPairDescriptor",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, primaryAzurePort: {
                serializedName: "properties.primaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, secondaryAzurePort: {
                serializedName: "properties.secondaryAzurePort",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, peeringLocation: {
                serializedName: "properties.peeringLocation",
                type: {
                    name: "String"
                }
            }, overprovisionFactor: {
                serializedName: "properties.overprovisionFactor",
                type: {
                    name: "Number"
                }
            }, portBandwidthInMbps: {
                serializedName: "properties.portBandwidthInMbps",
                type: {
                    name: "Number"
                }
            }, usedBandwidthInMbps: {
                serializedName: "properties.usedBandwidthInMbps",
                type: {
                    name: "Number"
                }
            }, remainingBandwidthInMbps: {
                serializedName: "properties.remainingBandwidthInMbps",
                type: {
                    name: "Number"
                }
            } })
    }
};
const FirewallPolicy = {
    type: {
        name: "Composite",
        className: "FirewallPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, ruleCollectionGroups: {
                serializedName: "properties.ruleCollectionGroups",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, basePolicy: {
                serializedName: "properties.basePolicy",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, firewalls: {
                serializedName: "properties.firewalls",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, childPolicies: {
                serializedName: "properties.childPolicies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, threatIntelMode: {
                serializedName: "properties.threatIntelMode",
                type: {
                    name: "String"
                }
            }, threatIntelWhitelist: {
                serializedName: "properties.threatIntelWhitelist",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyThreatIntelWhitelist"
                }
            }, insights: {
                serializedName: "properties.insights",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyInsights"
                }
            }, snat: {
                serializedName: "properties.snat",
                type: {
                    name: "Composite",
                    className: "FirewallPolicySnat"
                }
            }, sql: {
                serializedName: "properties.sql",
                type: {
                    name: "Composite",
                    className: "FirewallPolicySQL"
                }
            }, dnsSettings: {
                serializedName: "properties.dnsSettings",
                type: {
                    name: "Composite",
                    className: "DnsSettings"
                }
            }, explicitProxy: {
                serializedName: "properties.explicitProxy",
                type: {
                    name: "Composite",
                    className: "ExplicitProxy"
                }
            }, intrusionDetection: {
                serializedName: "properties.intrusionDetection",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyIntrusionDetection"
                }
            }, transportSecurity: {
                serializedName: "properties.transportSecurity",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyTransportSecurity"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "FirewallPolicySku"
                }
            } })
    }
};
const IpAllocation = {
    type: {
        name: "Composite",
        className: "IpAllocation",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, subnet: {
                serializedName: "properties.subnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, virtualNetwork: {
                serializedName: "properties.virtualNetwork",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            }, prefix: {
                serializedName: "properties.prefix",
                type: {
                    name: "String"
                }
            }, prefixLength: {
                defaultValue: 0,
                serializedName: "properties.prefixLength",
                nullable: true,
                type: {
                    name: "Number"
                }
            }, prefixType: {
                serializedName: "properties.prefixType",
                type: {
                    name: "String"
                }
            }, ipamAllocationId: {
                serializedName: "properties.ipamAllocationId",
                type: {
                    name: "String"
                }
            }, allocationTags: {
                serializedName: "properties.allocationTags",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "String" } }
                }
            } })
    }
};
const IpGroup = {
    type: {
        name: "Composite",
        className: "IpGroup",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipAddresses: {
                serializedName: "properties.ipAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, firewalls: {
                serializedName: "properties.firewalls",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, firewallPolicies: {
                serializedName: "properties.firewallPolicies",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const LoadBalancer = {
    type: {
        name: "Composite",
        className: "LoadBalancer",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "LoadBalancerSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, frontendIPConfigurations: {
                serializedName: "properties.frontendIPConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FrontendIPConfiguration"
                        }
                    }
                }
            }, backendAddressPools: {
                serializedName: "properties.backendAddressPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BackendAddressPool"
                        }
                    }
                }
            }, loadBalancingRules: {
                serializedName: "properties.loadBalancingRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "LoadBalancingRule"
                        }
                    }
                }
            }, probes: {
                serializedName: "properties.probes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Probe"
                        }
                    }
                }
            }, inboundNatRules: {
                serializedName: "properties.inboundNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatRule"
                        }
                    }
                }
            }, inboundNatPools: {
                serializedName: "properties.inboundNatPools",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "InboundNatPool"
                        }
                    }
                }
            }, outboundRules: {
                serializedName: "properties.outboundRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "OutboundRule"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkManager = {
    type: {
        name: "Composite",
        className: "NetworkManager",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, networkManagerScopes: {
                serializedName: "properties.networkManagerScopes",
                type: {
                    name: "Composite",
                    className: "NetworkManagerPropertiesNetworkManagerScopes"
                }
            }, networkManagerScopeAccesses: {
                serializedName: "properties.networkManagerScopeAccesses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkProfile = {
    type: {
        name: "Composite",
        className: "NetworkProfile",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, containerNetworkInterfaces: {
                serializedName: "properties.containerNetworkInterfaces",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerNetworkInterface"
                        }
                    }
                }
            }, containerNetworkInterfaceConfigurations: {
                serializedName: "properties.containerNetworkInterfaceConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ContainerNetworkInterfaceConfiguration"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkVirtualAppliance = {
    type: {
        name: "Composite",
        className: "NetworkVirtualAppliance",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { identity: {
                serializedName: "identity",
                type: {
                    name: "Composite",
                    className: "ManagedServiceIdentity"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, nvaSku: {
                serializedName: "properties.nvaSku",
                type: {
                    name: "Composite",
                    className: "VirtualApplianceSkuProperties"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, bootStrapConfigurationBlobs: {
                serializedName: "properties.bootStrapConfigurationBlobs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, cloudInitConfigurationBlobs: {
                serializedName: "properties.cloudInitConfigurationBlobs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, cloudInitConfiguration: {
                serializedName: "properties.cloudInitConfiguration",
                type: {
                    name: "String"
                }
            }, virtualApplianceAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.virtualApplianceAsn",
                type: {
                    name: "Number"
                }
            }, sshPublicKey: {
                serializedName: "properties.sshPublicKey",
                type: {
                    name: "String"
                }
            }, virtualApplianceNics: {
                serializedName: "properties.virtualApplianceNics",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualApplianceNicProperties"
                        }
                    }
                }
            }, virtualApplianceSites: {
                serializedName: "properties.virtualApplianceSites",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, inboundSecurityRules: {
                serializedName: "properties.inboundSecurityRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deploymentType: {
                serializedName: "properties.deploymentType",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, delegation: {
                serializedName: "properties.delegation",
                type: {
                    name: "Composite",
                    className: "DelegationProperties"
                }
            }, partnerManagedResource: {
                serializedName: "properties.partnerManagedResource",
                type: {
                    name: "Composite",
                    className: "PartnerManagedResourceProperties"
                }
            } })
    }
};
const NetworkVirtualApplianceSku = {
    type: {
        name: "Composite",
        className: "NetworkVirtualApplianceSku",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vendor: {
                serializedName: "properties.vendor",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, availableVersions: {
                serializedName: "properties.availableVersions",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, availableScaleUnits: {
                serializedName: "properties.availableScaleUnits",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkVirtualApplianceSkuInstances"
                        }
                    }
                }
            } })
    }
};
const NetworkWatcher = {
    type: {
        name: "Composite",
        className: "NetworkWatcher",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PublicIPPrefix = {
    type: {
        name: "Composite",
        className: "PublicIPPrefix",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, sku: {
                serializedName: "sku",
                type: {
                    name: "Composite",
                    className: "PublicIPPrefixSku"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, zones: {
                serializedName: "zones",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, publicIPAddressVersion: {
                serializedName: "properties.publicIPAddressVersion",
                type: {
                    name: "String"
                }
            }, ipTags: {
                serializedName: "properties.ipTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpTag"
                        }
                    }
                }
            }, prefixLength: {
                serializedName: "properties.prefixLength",
                type: {
                    name: "Number"
                }
            }, ipPrefix: {
                serializedName: "properties.ipPrefix",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, publicIPAddresses: {
                serializedName: "properties.publicIPAddresses",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ReferencedPublicIpAddress"
                        }
                    }
                }
            }, loadBalancerFrontendIpConfiguration: {
                serializedName: "properties.loadBalancerFrontendIpConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, customIPPrefix: {
                serializedName: "properties.customIPPrefix",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, natGateway: {
                serializedName: "properties.natGateway",
                type: {
                    name: "Composite",
                    className: "NatGateway"
                }
            } })
    }
};
const RouteFilter = {
    type: {
        name: "Composite",
        className: "RouteFilter",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, rules: {
                serializedName: "properties.rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RouteFilterRule"
                        }
                    }
                }
            }, peerings: {
                serializedName: "properties.peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, ipv6Peerings: {
                serializedName: "properties.ipv6Peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteCircuitPeering"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const SecurityPartnerProvider = {
    type: {
        name: "Composite",
        className: "SecurityPartnerProvider",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, securityProviderName: {
                serializedName: "properties.securityProviderName",
                type: {
                    name: "String"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            } })
    }
};
const BgpServiceCommunity = {
    type: {
        name: "Composite",
        className: "BgpServiceCommunity",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { serviceName: {
                serializedName: "properties.serviceName",
                type: {
                    name: "String"
                }
            }, bgpCommunities: {
                serializedName: "properties.bgpCommunities",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "BGPCommunity"
                        }
                    }
                }
            } })
    }
};
const VirtualNetwork = {
    type: {
        name: "Composite",
        className: "VirtualNetwork",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, addressSpace: {
                serializedName: "properties.addressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, dhcpOptions: {
                serializedName: "properties.dhcpOptions",
                type: {
                    name: "Composite",
                    className: "DhcpOptions"
                }
            }, flowTimeoutInMinutes: {
                serializedName: "properties.flowTimeoutInMinutes",
                type: {
                    name: "Number"
                }
            }, subnets: {
                serializedName: "properties.subnets",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Subnet"
                        }
                    }
                }
            }, virtualNetworkPeerings: {
                serializedName: "properties.virtualNetworkPeerings",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkPeering"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, enableDdosProtection: {
                defaultValue: false,
                serializedName: "properties.enableDdosProtection",
                type: {
                    name: "Boolean"
                }
            }, enableVmProtection: {
                defaultValue: false,
                serializedName: "properties.enableVmProtection",
                type: {
                    name: "Boolean"
                }
            }, ddosProtectionPlan: {
                serializedName: "properties.ddosProtectionPlan",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, bgpCommunities: {
                serializedName: "properties.bgpCommunities",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkBgpCommunities"
                }
            }, encryption: {
                serializedName: "properties.encryption",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkEncryption"
                }
            }, ipAllocations: {
                serializedName: "properties.ipAllocations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, flowLogs: {
                serializedName: "properties.flowLogs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FlowLog"
                        }
                    }
                }
            } })
    }
};
const NetworkIntentPolicy = {
    type: {
        name: "Composite",
        className: "NetworkIntentPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkGateway = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { extendedLocation: {
                serializedName: "extendedLocation",
                type: {
                    name: "Composite",
                    className: "ExtendedLocation"
                }
            }, etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayIPConfiguration"
                        }
                    }
                }
            }, gatewayType: {
                serializedName: "properties.gatewayType",
                type: {
                    name: "String"
                }
            }, vpnType: {
                serializedName: "properties.vpnType",
                type: {
                    name: "String"
                }
            }, vpnGatewayGeneration: {
                serializedName: "properties.vpnGatewayGeneration",
                type: {
                    name: "String"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, enablePrivateIpAddress: {
                serializedName: "properties.enablePrivateIpAddress",
                type: {
                    name: "Boolean"
                }
            }, active: {
                serializedName: "properties.activeActive",
                type: {
                    name: "Boolean"
                }
            }, disableIPSecReplayProtection: {
                serializedName: "properties.disableIPSecReplayProtection",
                type: {
                    name: "Boolean"
                }
            }, gatewayDefaultSite: {
                serializedName: "properties.gatewayDefaultSite",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkGatewaySku"
                }
            }, vpnClientConfiguration: {
                serializedName: "properties.vpnClientConfiguration",
                type: {
                    name: "Composite",
                    className: "VpnClientConfiguration"
                }
            }, virtualNetworkGatewayPolicyGroups: {
                serializedName: "properties.virtualNetworkGatewayPolicyGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayPolicyGroup"
                        }
                    }
                }
            }, bgpSettings: {
                serializedName: "properties.bgpSettings",
                type: {
                    name: "Composite",
                    className: "BgpSettings"
                }
            }, customRoutes: {
                serializedName: "properties.customRoutes",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, enableDnsForwarding: {
                serializedName: "properties.enableDnsForwarding",
                type: {
                    name: "Boolean"
                }
            }, inboundDnsForwardingEndpoint: {
                serializedName: "properties.inboundDnsForwardingEndpoint",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vNetExtendedLocationResourceId: {
                serializedName: "properties.vNetExtendedLocationResourceId",
                type: {
                    name: "String"
                }
            }, natRules: {
                serializedName: "properties.natRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualNetworkGatewayNatRule"
                        }
                    }
                }
            }, enableBgpRouteTranslationForNat: {
                serializedName: "properties.enableBgpRouteTranslationForNat",
                type: {
                    name: "Boolean"
                }
            }, allowVirtualWanTraffic: {
                serializedName: "properties.allowVirtualWanTraffic",
                type: {
                    name: "Boolean"
                }
            }, allowRemoteVnetTraffic: {
                serializedName: "properties.allowRemoteVnetTraffic",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const VirtualNetworkGatewayConnectionListEntity = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayConnectionListEntity",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, virtualNetworkGateway1: {
                serializedName: "properties.virtualNetworkGateway1",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConnectionGatewayReference"
                }
            }, virtualNetworkGateway2: {
                serializedName: "properties.virtualNetworkGateway2",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConnectionGatewayReference"
                }
            }, localNetworkGateway2: {
                serializedName: "properties.localNetworkGateway2",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkConnectionGatewayReference"
                }
            }, connectionType: {
                serializedName: "properties.connectionType",
                required: true,
                type: {
                    name: "String"
                }
            }, connectionProtocol: {
                serializedName: "properties.connectionProtocol",
                type: {
                    name: "String"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, connectionMode: {
                serializedName: "properties.connectionMode",
                type: {
                    name: "String"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tunnelConnectionStatus: {
                serializedName: "properties.tunnelConnectionStatus",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TunnelConnectionHealth"
                        }
                    }
                }
            }, egressBytesTransferred: {
                serializedName: "properties.egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, ingressBytesTransferred: {
                serializedName: "properties.ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, peer: {
                serializedName: "properties.peer",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, gatewayCustomBgpIpAddresses: {
                serializedName: "properties.gatewayCustomBgpIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayCustomBgpIpAddressIpConfiguration"
                        }
                    }
                }
            }, usePolicyBasedTrafficSelectors: {
                serializedName: "properties.usePolicyBasedTrafficSelectors",
                type: {
                    name: "Boolean"
                }
            }, ipsecPolicies: {
                serializedName: "properties.ipsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, trafficSelectorPolicies: {
                serializedName: "properties.trafficSelectorPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrafficSelectorPolicy"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteGatewayBypass: {
                serializedName: "properties.expressRouteGatewayBypass",
                type: {
                    name: "Boolean"
                }
            }, enablePrivateLinkFastPath: {
                serializedName: "properties.enablePrivateLinkFastPath",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const LocalNetworkGateway = {
    type: {
        name: "Composite",
        className: "LocalNetworkGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, localNetworkAddressSpace: {
                serializedName: "properties.localNetworkAddressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, gatewayIpAddress: {
                serializedName: "properties.gatewayIpAddress",
                type: {
                    name: "String"
                }
            }, fqdn: {
                serializedName: "properties.fqdn",
                type: {
                    name: "String"
                }
            }, bgpSettings: {
                serializedName: "properties.bgpSettings",
                type: {
                    name: "Composite",
                    className: "BgpSettings"
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualNetworkGatewayConnection = {
    type: {
        name: "Composite",
        className: "VirtualNetworkGatewayConnection",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, authorizationKey: {
                serializedName: "properties.authorizationKey",
                type: {
                    name: "String"
                }
            }, virtualNetworkGateway1: {
                serializedName: "properties.virtualNetworkGateway1",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkGateway"
                }
            }, virtualNetworkGateway2: {
                serializedName: "properties.virtualNetworkGateway2",
                type: {
                    name: "Composite",
                    className: "VirtualNetworkGateway"
                }
            }, localNetworkGateway2: {
                serializedName: "properties.localNetworkGateway2",
                type: {
                    name: "Composite",
                    className: "LocalNetworkGateway"
                }
            }, ingressNatRules: {
                serializedName: "properties.ingressNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, egressNatRules: {
                serializedName: "properties.egressNatRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, connectionType: {
                serializedName: "properties.connectionType",
                required: true,
                type: {
                    name: "String"
                }
            }, connectionProtocol: {
                serializedName: "properties.connectionProtocol",
                type: {
                    name: "String"
                }
            }, routingWeight: {
                serializedName: "properties.routingWeight",
                type: {
                    name: "Number"
                }
            }, dpdTimeoutSeconds: {
                serializedName: "properties.dpdTimeoutSeconds",
                type: {
                    name: "Number"
                }
            }, connectionMode: {
                serializedName: "properties.connectionMode",
                type: {
                    name: "String"
                }
            }, sharedKey: {
                serializedName: "properties.sharedKey",
                type: {
                    name: "String"
                }
            }, connectionStatus: {
                serializedName: "properties.connectionStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, tunnelConnectionStatus: {
                serializedName: "properties.tunnelConnectionStatus",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TunnelConnectionHealth"
                        }
                    }
                }
            }, egressBytesTransferred: {
                serializedName: "properties.egressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, ingressBytesTransferred: {
                serializedName: "properties.ingressBytesTransferred",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, peer: {
                serializedName: "properties.peer",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, enableBgp: {
                serializedName: "properties.enableBgp",
                type: {
                    name: "Boolean"
                }
            }, gatewayCustomBgpIpAddresses: {
                serializedName: "properties.gatewayCustomBgpIpAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "GatewayCustomBgpIpAddressIpConfiguration"
                        }
                    }
                }
            }, useLocalAzureIpAddress: {
                serializedName: "properties.useLocalAzureIpAddress",
                type: {
                    name: "Boolean"
                }
            }, usePolicyBasedTrafficSelectors: {
                serializedName: "properties.usePolicyBasedTrafficSelectors",
                type: {
                    name: "Boolean"
                }
            }, ipsecPolicies: {
                serializedName: "properties.ipsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, trafficSelectorPolicies: {
                serializedName: "properties.trafficSelectorPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TrafficSelectorPolicy"
                        }
                    }
                }
            }, resourceGuid: {
                serializedName: "properties.resourceGuid",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, expressRouteGatewayBypass: {
                serializedName: "properties.expressRouteGatewayBypass",
                type: {
                    name: "Boolean"
                }
            }, enablePrivateLinkFastPath: {
                serializedName: "properties.enablePrivateLinkFastPath",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const VirtualRouter = {
    type: {
        name: "Composite",
        className: "VirtualRouter",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualRouterAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.virtualRouterAsn",
                type: {
                    name: "Number"
                }
            }, virtualRouterIps: {
                serializedName: "properties.virtualRouterIps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, hostedSubnet: {
                serializedName: "properties.hostedSubnet",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, hostedGateway: {
                serializedName: "properties.hostedGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, peerings: {
                serializedName: "properties.peerings",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualWAN = {
    type: {
        name: "Composite",
        className: "VirtualWAN",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, disableVpnEncryption: {
                serializedName: "properties.disableVpnEncryption",
                type: {
                    name: "Boolean"
                }
            }, virtualHubs: {
                serializedName: "properties.virtualHubs",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, vpnSites: {
                serializedName: "properties.vpnSites",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, allowBranchToBranchTraffic: {
                serializedName: "properties.allowBranchToBranchTraffic",
                type: {
                    name: "Boolean"
                }
            }, allowVnetToVnetTraffic: {
                serializedName: "properties.allowVnetToVnetTraffic",
                type: {
                    name: "Boolean"
                }
            }, office365LocalBreakoutCategory: {
                serializedName: "properties.office365LocalBreakoutCategory",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, typePropertiesType: {
                serializedName: "properties.type",
                type: {
                    name: "String"
                }
            } })
    }
};
const VpnSite = {
    type: {
        name: "Composite",
        className: "VpnSite",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualWan: {
                serializedName: "properties.virtualWan",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, deviceProperties: {
                serializedName: "properties.deviceProperties",
                type: {
                    name: "Composite",
                    className: "DeviceProperties"
                }
            }, ipAddress: {
                serializedName: "properties.ipAddress",
                type: {
                    name: "String"
                }
            }, siteKey: {
                serializedName: "properties.siteKey",
                type: {
                    name: "String"
                }
            }, addressSpace: {
                serializedName: "properties.addressSpace",
                type: {
                    name: "Composite",
                    className: "AddressSpace"
                }
            }, bgpProperties: {
                serializedName: "properties.bgpProperties",
                type: {
                    name: "Composite",
                    className: "BgpSettings"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, isSecuritySite: {
                serializedName: "properties.isSecuritySite",
                type: {
                    name: "Boolean"
                }
            }, vpnSiteLinks: {
                serializedName: "properties.vpnSiteLinks",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnSiteLink"
                        }
                    }
                }
            }, o365Policy: {
                serializedName: "properties.o365Policy",
                type: {
                    name: "Composite",
                    className: "O365PolicyProperties"
                }
            } })
    }
};
const P2SVpnGateway = {
    type: {
        name: "Composite",
        className: "P2SVpnGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, p2SConnectionConfigurations: {
                serializedName: "properties.p2SConnectionConfigurations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "P2SConnectionConfiguration"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnGatewayScaleUnit: {
                serializedName: "properties.vpnGatewayScaleUnit",
                type: {
                    name: "Number"
                }
            }, vpnServerConfiguration: {
                serializedName: "properties.vpnServerConfiguration",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, vpnClientConnectionHealth: {
                serializedName: "properties.vpnClientConnectionHealth",
                type: {
                    name: "Composite",
                    className: "VpnClientConnectionHealth"
                }
            }, customDnsServers: {
                serializedName: "properties.customDnsServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, isRoutingPreferenceInternet: {
                serializedName: "properties.isRoutingPreferenceInternet",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const VpnServerConfiguration = {
    type: {
        name: "Composite",
        className: "VpnServerConfiguration",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, namePropertiesName: {
                serializedName: "properties.name",
                type: {
                    name: "String"
                }
            }, vpnProtocols: {
                serializedName: "properties.vpnProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, vpnAuthenticationTypes: {
                serializedName: "properties.vpnAuthenticationTypes",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, vpnClientRootCertificates: {
                serializedName: "properties.vpnClientRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigVpnClientRootCertificate"
                        }
                    }
                }
            }, vpnClientRevokedCertificates: {
                serializedName: "properties.vpnClientRevokedCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigVpnClientRevokedCertificate"
                        }
                    }
                }
            }, radiusServerRootCertificates: {
                serializedName: "properties.radiusServerRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigRadiusServerRootCertificate"
                        }
                    }
                }
            }, radiusClientRootCertificates: {
                serializedName: "properties.radiusClientRootCertificates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigRadiusClientRootCertificate"
                        }
                    }
                }
            }, vpnClientIpsecPolicies: {
                serializedName: "properties.vpnClientIpsecPolicies",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "IpsecPolicy"
                        }
                    }
                }
            }, radiusServerAddress: {
                serializedName: "properties.radiusServerAddress",
                type: {
                    name: "String"
                }
            }, radiusServerSecret: {
                serializedName: "properties.radiusServerSecret",
                type: {
                    name: "String"
                }
            }, radiusServers: {
                serializedName: "properties.radiusServers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "RadiusServer"
                        }
                    }
                }
            }, aadAuthenticationParameters: {
                serializedName: "properties.aadAuthenticationParameters",
                type: {
                    name: "Composite",
                    className: "AadAuthenticationParameters"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, p2SVpnGateways: {
                serializedName: "properties.p2SVpnGateways",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "P2SVpnGateway"
                        }
                    }
                }
            }, configurationPolicyGroups: {
                serializedName: "properties.configurationPolicyGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnServerConfigurationPolicyGroup"
                        }
                    }
                }
            }, etagPropertiesEtag: {
                serializedName: "properties.etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const VirtualHub = {
    type: {
        name: "Composite",
        className: "VirtualHub",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, kind: {
                serializedName: "kind",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualWan: {
                serializedName: "properties.virtualWan",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, vpnGateway: {
                serializedName: "properties.vpnGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, p2SVpnGateway: {
                serializedName: "properties.p2SVpnGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, expressRouteGateway: {
                serializedName: "properties.expressRouteGateway",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, azureFirewall: {
                serializedName: "properties.azureFirewall",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, securityPartnerProvider: {
                serializedName: "properties.securityPartnerProvider",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, addressPrefix: {
                serializedName: "properties.addressPrefix",
                type: {
                    name: "String"
                }
            }, routeTable: {
                serializedName: "properties.routeTable",
                type: {
                    name: "Composite",
                    className: "VirtualHubRouteTable"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, securityProviderName: {
                serializedName: "properties.securityProviderName",
                type: {
                    name: "String"
                }
            }, virtualHubRouteTableV2S: {
                serializedName: "properties.virtualHubRouteTableV2s",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VirtualHubRouteTableV2"
                        }
                    }
                }
            }, sku: {
                serializedName: "properties.sku",
                type: {
                    name: "String"
                }
            }, routingState: {
                serializedName: "properties.routingState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, bgpConnections: {
                serializedName: "properties.bgpConnections",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, routeMaps: {
                serializedName: "properties.routeMaps",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, virtualRouterAsn: {
                constraints: {
                    InclusiveMaximum: 4294967295,
                    InclusiveMinimum: 0
                },
                serializedName: "properties.virtualRouterAsn",
                type: {
                    name: "Number"
                }
            }, virtualRouterIps: {
                serializedName: "properties.virtualRouterIps",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, allowBranchToBranchTraffic: {
                serializedName: "properties.allowBranchToBranchTraffic",
                type: {
                    name: "Boolean"
                }
            }, preferredRoutingGateway: {
                serializedName: "properties.preferredRoutingGateway",
                type: {
                    name: "String"
                }
            }, hubRoutingPreference: {
                serializedName: "properties.hubRoutingPreference",
                type: {
                    name: "String"
                }
            }, virtualRouterAutoScaleConfiguration: {
                serializedName: "properties.virtualRouterAutoScaleConfiguration",
                type: {
                    name: "Composite",
                    className: "VirtualRouterAutoScaleConfiguration"
                }
            } })
    }
};
const VpnGateway = {
    type: {
        name: "Composite",
        className: "VpnGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "SubResource"
                }
            }, connections: {
                serializedName: "properties.connections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnConnection"
                        }
                    }
                }
            }, bgpSettings: {
                serializedName: "properties.bgpSettings",
                type: {
                    name: "Composite",
                    className: "BgpSettings"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, vpnGatewayScaleUnit: {
                serializedName: "properties.vpnGatewayScaleUnit",
                type: {
                    name: "Number"
                }
            }, ipConfigurations: {
                serializedName: "properties.ipConfigurations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnGatewayIpConfiguration"
                        }
                    }
                }
            }, enableBgpRouteTranslationForNat: {
                serializedName: "properties.enableBgpRouteTranslationForNat",
                type: {
                    name: "Boolean"
                }
            }, isRoutingPreferenceInternet: {
                serializedName: "properties.isRoutingPreferenceInternet",
                type: {
                    name: "Boolean"
                }
            }, natRules: {
                serializedName: "properties.natRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VpnGatewayNatRule"
                        }
                    }
                }
            } })
    }
};
const ExpressRouteGateway = {
    type: {
        name: "Composite",
        className: "ExpressRouteGateway",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, autoScaleConfiguration: {
                serializedName: "properties.autoScaleConfiguration",
                type: {
                    name: "Composite",
                    className: "ExpressRouteGatewayPropertiesAutoScaleConfiguration"
                }
            }, expressRouteConnections: {
                serializedName: "properties.expressRouteConnections",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ExpressRouteConnection"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, virtualHub: {
                serializedName: "properties.virtualHub",
                type: {
                    name: "Composite",
                    className: "VirtualHubId"
                }
            }, allowNonVirtualWanTraffic: {
                serializedName: "properties.allowNonVirtualWanTraffic",
                type: {
                    name: "Boolean"
                }
            } })
    }
};
const WebApplicationFirewallPolicy = {
    type: {
        name: "Composite",
        className: "WebApplicationFirewallPolicy",
        modelProperties: Object.assign(Object.assign({}, Resource.type.modelProperties), { etag: {
                serializedName: "etag",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, policySettings: {
                serializedName: "properties.policySettings",
                type: {
                    name: "Composite",
                    className: "PolicySettings"
                }
            }, customRules: {
                serializedName: "properties.customRules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "WebApplicationFirewallCustomRule"
                        }
                    }
                }
            }, applicationGateways: {
                serializedName: "properties.applicationGateways",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ApplicationGateway"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, resourceState: {
                serializedName: "properties.resourceState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, managedRules: {
                serializedName: "properties.managedRules",
                type: {
                    name: "Composite",
                    className: "ManagedRulesDefinition"
                }
            }, httpListeners: {
                serializedName: "properties.httpListeners",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            }, pathBasedRules: {
                serializedName: "properties.pathBasedRules",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "SubResource"
                        }
                    }
                }
            } })
    }
};
const PrivateLinkServicePropertiesVisibility = {
    type: {
        name: "Composite",
        className: "PrivateLinkServicePropertiesVisibility",
        modelProperties: Object.assign({}, ResourceSet.type.modelProperties)
    }
};
const PrivateLinkServicePropertiesAutoApproval = {
    type: {
        name: "Composite",
        className: "PrivateLinkServicePropertiesAutoApproval",
        modelProperties: Object.assign({}, ResourceSet.type.modelProperties)
    }
};
const FirewallPolicyNatRuleCollection = {
    serializedName: "FirewallPolicyNatRuleCollection",
    type: {
        name: "Composite",
        className: "FirewallPolicyNatRuleCollection",
        uberParent: "FirewallPolicyRuleCollection",
        polymorphicDiscriminator: FirewallPolicyRuleCollection.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRuleCollection.type.modelProperties), { action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyNatRuleCollectionAction"
                }
            }, rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRule"
                        }
                    }
                }
            } })
    }
};
const FirewallPolicyFilterRuleCollection = {
    serializedName: "FirewallPolicyFilterRuleCollection",
    type: {
        name: "Composite",
        className: "FirewallPolicyFilterRuleCollection",
        uberParent: "FirewallPolicyRuleCollection",
        polymorphicDiscriminator: FirewallPolicyRuleCollection.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRuleCollection.type.modelProperties), { action: {
                serializedName: "action",
                type: {
                    name: "Composite",
                    className: "FirewallPolicyFilterRuleCollectionAction"
                }
            }, rules: {
                serializedName: "rules",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRule"
                        }
                    }
                }
            } })
    }
};
const ActiveConnectivityConfiguration = {
    type: {
        name: "Composite",
        className: "ActiveConnectivityConfiguration",
        modelProperties: Object.assign(Object.assign({}, EffectiveConnectivityConfiguration.type.modelProperties), { commitTime: {
                serializedName: "commitTime",
                type: {
                    name: "DateTime"
                }
            }, region: {
                serializedName: "region",
                type: {
                    name: "String"
                }
            } })
    }
};
const ActiveSecurityAdminRule = {
    serializedName: "Custom",
    type: {
        name: "Composite",
        className: "ActiveSecurityAdminRule",
        uberParent: "ActiveBaseSecurityAdminRule",
        polymorphicDiscriminator: ActiveBaseSecurityAdminRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ActiveBaseSecurityAdminRule.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, sources: {
                serializedName: "properties.sources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, destinations: {
                serializedName: "properties.destinations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, access: {
                serializedName: "properties.access",
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 4096,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, direction: {
                serializedName: "properties.direction",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ActiveDefaultSecurityAdminRule = {
    serializedName: "Default",
    type: {
        name: "Composite",
        className: "ActiveDefaultSecurityAdminRule",
        uberParent: "ActiveBaseSecurityAdminRule",
        polymorphicDiscriminator: ActiveBaseSecurityAdminRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, ActiveBaseSecurityAdminRule.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, flag: {
                serializedName: "properties.flag",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sources: {
                serializedName: "properties.sources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, destinations: {
                serializedName: "properties.destinations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, access: {
                serializedName: "properties.access",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                serializedName: "properties.priority",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, direction: {
                serializedName: "properties.direction",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkManagerConnection = {
    type: {
        name: "Composite",
        className: "NetworkManagerConnection",
        modelProperties: Object.assign(Object.assign({}, ChildResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, networkManagerId: {
                serializedName: "properties.networkManagerId",
                type: {
                    name: "String"
                }
            }, connectionState: {
                serializedName: "properties.connectionState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const ConnectivityConfiguration = {
    type: {
        name: "Composite",
        className: "ConnectivityConfiguration",
        modelProperties: Object.assign(Object.assign({}, ChildResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, connectivityTopology: {
                serializedName: "properties.connectivityTopology",
                type: {
                    name: "String"
                }
            }, hubs: {
                serializedName: "properties.hubs",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Hub"
                        }
                    }
                }
            }, isGlobal: {
                serializedName: "properties.isGlobal",
                type: {
                    name: "String"
                }
            }, appliesToGroups: {
                serializedName: "properties.appliesToGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ConnectivityGroupItem"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, deleteExistingPeering: {
                serializedName: "properties.deleteExistingPeering",
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkGroup = {
    type: {
        name: "Composite",
        className: "NetworkGroup",
        modelProperties: Object.assign(Object.assign({}, ChildResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const StaticMember = {
    type: {
        name: "Composite",
        className: "StaticMember",
        modelProperties: Object.assign(Object.assign({}, ChildResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, resourceId: {
                serializedName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, region: {
                serializedName: "properties.region",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ScopeConnection = {
    type: {
        name: "Composite",
        className: "ScopeConnection",
        modelProperties: Object.assign(Object.assign({}, ChildResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, tenantId: {
                serializedName: "properties.tenantId",
                type: {
                    name: "String"
                }
            }, resourceId: {
                serializedName: "properties.resourceId",
                type: {
                    name: "String"
                }
            }, connectionState: {
                serializedName: "properties.connectionState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            } })
    }
};
const SecurityAdminConfiguration = {
    type: {
        name: "Composite",
        className: "SecurityAdminConfiguration",
        modelProperties: Object.assign(Object.assign({}, ChildResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, applyOnNetworkIntentPolicyBasedServices: {
                serializedName: "properties.applyOnNetworkIntentPolicyBasedServices",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const AdminRuleCollection = {
    type: {
        name: "Composite",
        className: "AdminRuleCollection",
        modelProperties: Object.assign(Object.assign({}, ChildResource.type.modelProperties), { systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            }, description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, appliesToGroups: {
                serializedName: "properties.appliesToGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "NetworkManagerSecurityGroupItem"
                        }
                    }
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const BaseAdminRule = {
    serializedName: "BaseAdminRule",
    type: {
        name: "Composite",
        className: "BaseAdminRule",
        uberParent: "ChildResource",
        polymorphicDiscriminator: {
            serializedName: "kind",
            clientName: "kind"
        },
        modelProperties: Object.assign(Object.assign({}, ChildResource.type.modelProperties), { kind: {
                serializedName: "kind",
                required: true,
                type: {
                    name: "String"
                }
            }, systemData: {
                serializedName: "systemData",
                type: {
                    name: "Composite",
                    className: "SystemData"
                }
            } })
    }
};
const EffectiveSecurityAdminRule = {
    serializedName: "Custom",
    type: {
        name: "Composite",
        className: "EffectiveSecurityAdminRule",
        uberParent: "EffectiveBaseSecurityAdminRule",
        polymorphicDiscriminator: EffectiveBaseSecurityAdminRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EffectiveBaseSecurityAdminRule.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, sources: {
                serializedName: "properties.sources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, destinations: {
                serializedName: "properties.destinations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, access: {
                serializedName: "properties.access",
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 4096,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, direction: {
                serializedName: "properties.direction",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const EffectiveDefaultSecurityAdminRule = {
    serializedName: "Default",
    type: {
        name: "Composite",
        className: "EffectiveDefaultSecurityAdminRule",
        uberParent: "EffectiveBaseSecurityAdminRule",
        polymorphicDiscriminator: EffectiveBaseSecurityAdminRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, EffectiveBaseSecurityAdminRule.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, flag: {
                serializedName: "properties.flag",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sources: {
                serializedName: "properties.sources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, destinations: {
                serializedName: "properties.destinations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, access: {
                serializedName: "properties.access",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                serializedName: "properties.priority",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, direction: {
                serializedName: "properties.direction",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PacketCaptureResultProperties = {
    type: {
        name: "Composite",
        className: "PacketCaptureResultProperties",
        modelProperties: Object.assign(Object.assign({}, PacketCaptureParameters.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ConnectionMonitorResultProperties = {
    type: {
        name: "Composite",
        className: "ConnectionMonitorResultProperties",
        modelProperties: Object.assign(Object.assign({}, ConnectionMonitorParameters.type.modelProperties), { provisioningState: {
                serializedName: "provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, startTime: {
                serializedName: "startTime",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }, monitoringStatus: {
                serializedName: "monitoringStatus",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, connectionMonitorType: {
                serializedName: "connectionMonitorType",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const ApplicationRule = {
    serializedName: "ApplicationRule",
    type: {
        name: "Composite",
        className: "ApplicationRule",
        uberParent: "FirewallPolicyRule",
        polymorphicDiscriminator: FirewallPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRule.type.modelProperties), { sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, protocols: {
                serializedName: "protocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FirewallPolicyRuleApplicationProtocol"
                        }
                    }
                }
            }, targetFqdns: {
                serializedName: "targetFqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, targetUrls: {
                serializedName: "targetUrls",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, fqdnTags: {
                serializedName: "fqdnTags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, terminateTLS: {
                serializedName: "terminateTLS",
                type: {
                    name: "Boolean"
                }
            }, webCategories: {
                serializedName: "webCategories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const NatRule = {
    serializedName: "NatRule",
    type: {
        name: "Composite",
        className: "NatRule",
        uberParent: "FirewallPolicyRule",
        polymorphicDiscriminator: FirewallPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRule.type.modelProperties), { ipProtocols: {
                serializedName: "ipProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, translatedAddress: {
                serializedName: "translatedAddress",
                type: {
                    name: "String"
                }
            }, translatedPort: {
                serializedName: "translatedPort",
                type: {
                    name: "String"
                }
            }, sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, translatedFqdn: {
                serializedName: "translatedFqdn",
                type: {
                    name: "String"
                }
            } })
    }
};
const NetworkRule = {
    serializedName: "NetworkRule",
    type: {
        name: "Composite",
        className: "NetworkRule",
        uberParent: "FirewallPolicyRule",
        polymorphicDiscriminator: FirewallPolicyRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, FirewallPolicyRule.type.modelProperties), { ipProtocols: {
                serializedName: "ipProtocols",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceAddresses: {
                serializedName: "sourceAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationAddresses: {
                serializedName: "destinationAddresses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPorts: {
                serializedName: "destinationPorts",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, sourceIpGroups: {
                serializedName: "sourceIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationIpGroups: {
                serializedName: "destinationIpGroups",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationFqdns: {
                serializedName: "destinationFqdns",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            } })
    }
};
const AdminRule = {
    serializedName: "Custom",
    type: {
        name: "Composite",
        className: "AdminRule",
        uberParent: "BaseAdminRule",
        polymorphicDiscriminator: BaseAdminRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BaseAdminRule.type.modelProperties), { description: {
                serializedName: "properties.description",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                type: {
                    name: "String"
                }
            }, sources: {
                serializedName: "properties.sources",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, destinations: {
                serializedName: "properties.destinations",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, access: {
                serializedName: "properties.access",
                type: {
                    name: "String"
                }
            }, priority: {
                constraints: {
                    InclusiveMaximum: 4096,
                    InclusiveMinimum: 1
                },
                serializedName: "properties.priority",
                type: {
                    name: "Number"
                }
            }, direction: {
                serializedName: "properties.direction",
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const DefaultAdminRule = {
    serializedName: "Default",
    type: {
        name: "Composite",
        className: "DefaultAdminRule",
        uberParent: "BaseAdminRule",
        polymorphicDiscriminator: BaseAdminRule.type.polymorphicDiscriminator,
        modelProperties: Object.assign(Object.assign({}, BaseAdminRule.type.modelProperties), { description: {
                serializedName: "properties.description",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, flag: {
                serializedName: "properties.flag",
                type: {
                    name: "String"
                }
            }, protocol: {
                serializedName: "properties.protocol",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, sources: {
                serializedName: "properties.sources",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, destinations: {
                serializedName: "properties.destinations",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AddressPrefixItem"
                        }
                    }
                }
            }, sourcePortRanges: {
                serializedName: "properties.sourcePortRanges",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, destinationPortRanges: {
                serializedName: "properties.destinationPortRanges",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }, access: {
                serializedName: "properties.access",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, priority: {
                serializedName: "properties.priority",
                readOnly: true,
                type: {
                    name: "Number"
                }
            }, direction: {
                serializedName: "properties.direction",
                readOnly: true,
                type: {
                    name: "String"
                }
            }, provisioningState: {
                serializedName: "properties.provisioningState",
                readOnly: true,
                type: {
                    name: "String"
                }
            } })
    }
};
const PublicIPAddressesDeleteHeaders = {
    type: {
        name: "Composite",
        className: "PublicIPAddressesDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PublicIPAddressesDdosProtectionStatusHeaders = {
    type: {
        name: "Composite",
        className: "PublicIPAddressesDdosProtectionStatusHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DdosProtectionPlansDeleteHeaders = {
    type: {
        name: "Composite",
        className: "DdosProtectionPlansDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagersDeleteHeaders = {
    type: {
        name: "Composite",
        className: "NetworkManagersDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkManagerCommitsPostHeaders = {
    type: {
        name: "Composite",
        className: "NetworkManagerCommitsPostHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ConnectivityConfigurationsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "ConnectivityConfigurationsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkGroupsCreateOrUpdateHeaders = {
    type: {
        name: "Composite",
        className: "NetworkGroupsCreateOrUpdateHeaders",
        modelProperties: {
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const NetworkGroupsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "NetworkGroupsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SecurityAdminConfigurationsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "SecurityAdminConfigurationsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdminRuleCollectionsDeleteHeaders = {
    type: {
        name: "Composite",
        className: "AdminRuleCollectionsDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AdminRulesDeleteHeaders = {
    type: {
        name: "Composite",
        className: "AdminRulesDeleteHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
let discriminators = {
    FirewallPolicyRuleCollection: FirewallPolicyRuleCollection,
    ActiveBaseSecurityAdminRule: ActiveBaseSecurityAdminRule,
    EffectiveBaseSecurityAdminRule: EffectiveBaseSecurityAdminRule,
    FirewallPolicyRule: FirewallPolicyRule,
    "FirewallPolicyRuleCollection.FirewallPolicyNatRuleCollection": FirewallPolicyNatRuleCollection,
    "FirewallPolicyRuleCollection.FirewallPolicyFilterRuleCollection": FirewallPolicyFilterRuleCollection,
    "ActiveBaseSecurityAdminRule.Custom": ActiveSecurityAdminRule,
    "ActiveBaseSecurityAdminRule.Default": ActiveDefaultSecurityAdminRule,
    "ChildResource.BaseAdminRule": BaseAdminRule,
    "EffectiveBaseSecurityAdminRule.Custom": EffectiveSecurityAdminRule,
    "EffectiveBaseSecurityAdminRule.Default": EffectiveDefaultSecurityAdminRule,
    "FirewallPolicyRule.ApplicationRule": ApplicationRule,
    "FirewallPolicyRule.NatRule": NatRule,
    "FirewallPolicyRule.NetworkRule": NetworkRule,
    "BaseAdminRule.Custom": AdminRule,
    "BaseAdminRule.Default": DefaultAdminRule
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    CloudError: CloudError,
    CloudErrorBody: CloudErrorBody,
    ApplicationGatewaySku: ApplicationGatewaySku,
    ApplicationGatewaySslPolicy: ApplicationGatewaySslPolicy,
    SubResource: SubResource,
    ApplicationGatewayProbeHealthResponseMatch: ApplicationGatewayProbeHealthResponseMatch,
    Resource: Resource,
    ExtendedLocation: ExtendedLocation,
    PrivateLinkServiceConnectionState: PrivateLinkServiceConnectionState,
    CustomDnsConfigPropertiesFormat: CustomDnsConfigPropertiesFormat,
    PrivateEndpointIPConfiguration: PrivateEndpointIPConfiguration,
    NetworkInterfaceDnsSettings: NetworkInterfaceDnsSettings,
    ResourceSet: ResourceSet,
    RetentionPolicyParameters: RetentionPolicyParameters,
    FlowLogFormatParameters: FlowLogFormatParameters,
    TrafficAnalyticsProperties: TrafficAnalyticsProperties,
    TrafficAnalyticsConfigurationProperties: TrafficAnalyticsConfigurationProperties,
    ServiceEndpointPropertiesFormat: ServiceEndpointPropertiesFormat,
    PublicIPAddressSku: PublicIPAddressSku,
    PublicIPAddressDnsSettings: PublicIPAddressDnsSettings,
    DdosSettings: DdosSettings,
    IpTag: IpTag,
    NatGatewaySku: NatGatewaySku,
    GatewayLoadBalancerTunnelInterface: GatewayLoadBalancerTunnelInterface,
    LoadBalancerBackendAddress: LoadBalancerBackendAddress,
    NatRulePortMapping: NatRulePortMapping,
    NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties: NetworkInterfaceIPConfigurationPrivateLinkConnectionProperties,
    ApplicationGatewayBackendAddress: ApplicationGatewayBackendAddress,
    ApplicationGatewayConnectionDraining: ApplicationGatewayConnectionDraining,
    ApplicationGatewayCustomError: ApplicationGatewayCustomError,
    ApplicationGatewayClientAuthConfiguration: ApplicationGatewayClientAuthConfiguration,
    ApplicationGatewayRewriteRule: ApplicationGatewayRewriteRule,
    ApplicationGatewayRewriteRuleCondition: ApplicationGatewayRewriteRuleCondition,
    ApplicationGatewayRewriteRuleActionSet: ApplicationGatewayRewriteRuleActionSet,
    ApplicationGatewayHeaderConfiguration: ApplicationGatewayHeaderConfiguration,
    ApplicationGatewayUrlConfiguration: ApplicationGatewayUrlConfiguration,
    ApplicationGatewayWebApplicationFirewallConfiguration: ApplicationGatewayWebApplicationFirewallConfiguration,
    ApplicationGatewayFirewallDisabledRuleGroup: ApplicationGatewayFirewallDisabledRuleGroup,
    ApplicationGatewayFirewallExclusion: ApplicationGatewayFirewallExclusion,
    ApplicationGatewayAutoscaleConfiguration: ApplicationGatewayAutoscaleConfiguration,
    ApplicationGatewayGlobalConfiguration: ApplicationGatewayGlobalConfiguration,
    ManagedServiceIdentity: ManagedServiceIdentity,
    Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties: Components1Jq1T4ISchemasManagedserviceidentityPropertiesUserassignedidentitiesAdditionalproperties,
    TagsObject: TagsObject,
    ApplicationGatewayListResult: ApplicationGatewayListResult,
    ApplicationGatewayBackendHealth: ApplicationGatewayBackendHealth,
    ApplicationGatewayBackendHealthPool: ApplicationGatewayBackendHealthPool,
    ApplicationGatewayBackendHealthHttpSettings: ApplicationGatewayBackendHealthHttpSettings,
    ApplicationGatewayBackendHealthServer: ApplicationGatewayBackendHealthServer,
    ApplicationGatewayOnDemandProbe: ApplicationGatewayOnDemandProbe,
    ApplicationGatewayBackendHealthOnDemand: ApplicationGatewayBackendHealthOnDemand,
    ApplicationGatewayPrivateLinkResourceListResult: ApplicationGatewayPrivateLinkResourceListResult,
    ApplicationGatewayPrivateEndpointConnectionListResult: ApplicationGatewayPrivateEndpointConnectionListResult,
    ErrorModel: ErrorModel,
    ErrorDetails: ErrorDetails,
    ApplicationGatewayAvailableWafRuleSetsResult: ApplicationGatewayAvailableWafRuleSetsResult,
    ApplicationGatewayFirewallRuleGroup: ApplicationGatewayFirewallRuleGroup,
    ApplicationGatewayFirewallRule: ApplicationGatewayFirewallRule,
    ApplicationGatewayAvailableSslPredefinedPolicies: ApplicationGatewayAvailableSslPredefinedPolicies,
    ApplicationGatewayWafDynamicManifestResult: ApplicationGatewayWafDynamicManifestResult,
    ApplicationGatewayFirewallManifestRuleSet: ApplicationGatewayFirewallManifestRuleSet,
    ApplicationGatewayWafDynamicManifestResultList: ApplicationGatewayWafDynamicManifestResultList,
    ApplicationSecurityGroupListResult: ApplicationSecurityGroupListResult,
    AvailableDelegationsResult: AvailableDelegationsResult,
    AvailableDelegation: AvailableDelegation,
    AvailableServiceAliasesResult: AvailableServiceAliasesResult,
    AvailableServiceAlias: AvailableServiceAlias,
    AzureFirewallRCAction: AzureFirewallRCAction,
    AzureFirewallApplicationRule: AzureFirewallApplicationRule,
    AzureFirewallApplicationRuleProtocol: AzureFirewallApplicationRuleProtocol,
    AzureFirewallNatRCAction: AzureFirewallNatRCAction,
    AzureFirewallNatRule: AzureFirewallNatRule,
    AzureFirewallNetworkRule: AzureFirewallNetworkRule,
    HubIPAddresses: HubIPAddresses,
    HubPublicIPAddresses: HubPublicIPAddresses,
    AzureFirewallPublicIPAddress: AzureFirewallPublicIPAddress,
    AzureFirewallIpGroups: AzureFirewallIpGroups,
    AzureFirewallSku: AzureFirewallSku,
    AzureFirewallListResult: AzureFirewallListResult,
    IPPrefixesList: IPPrefixesList,
    AzureFirewallFqdnTagListResult: AzureFirewallFqdnTagListResult,
    AzureWebCategory: AzureWebCategory,
    AzureWebCategoryListResult: AzureWebCategoryListResult,
    Sku: Sku,
    BastionHostListResult: BastionHostListResult,
    BastionShareableLinkListRequest: BastionShareableLinkListRequest,
    BastionShareableLink: BastionShareableLink,
    BastionShareableLinkListResult: BastionShareableLinkListResult,
    BastionActiveSessionListResult: BastionActiveSessionListResult,
    BastionActiveSession: BastionActiveSession,
    SessionIds: SessionIds,
    BastionSessionDeleteResult: BastionSessionDeleteResult,
    BastionSessionState: BastionSessionState,
    DnsNameAvailabilityResult: DnsNameAvailabilityResult,
    NetworkInterfaceListResult: NetworkInterfaceListResult,
    PublicIPAddressListResult: PublicIPAddressListResult,
    SwapResource: SwapResource,
    SwapResourceProperties: SwapResourceProperties,
    SwapResourceListResult: SwapResourceListResult,
    CustomIpPrefixListResult: CustomIpPrefixListResult,
    DdosProtectionPlan: DdosProtectionPlan,
    DdosProtectionPlanListResult: DdosProtectionPlanListResult,
    QosIpRange: QosIpRange,
    QosPortRange: QosPortRange,
    QosDefinition: QosDefinition,
    DscpConfigurationListResult: DscpConfigurationListResult,
    EndpointServicesListResult: EndpointServicesListResult,
    AuthorizationListResult: AuthorizationListResult,
    ExpressRouteCircuitPeeringConfig: ExpressRouteCircuitPeeringConfig,
    ExpressRouteCircuitStats: ExpressRouteCircuitStats,
    Ipv6ExpressRouteCircuitPeeringConfig: Ipv6ExpressRouteCircuitPeeringConfig,
    ExpressRouteConnectionId: ExpressRouteConnectionId,
    Ipv6CircuitConnectionConfig: Ipv6CircuitConnectionConfig,
    ExpressRouteCircuitPeeringListResult: ExpressRouteCircuitPeeringListResult,
    ExpressRouteCircuitConnectionListResult: ExpressRouteCircuitConnectionListResult,
    PeerExpressRouteCircuitConnectionListResult: PeerExpressRouteCircuitConnectionListResult,
    ExpressRouteCircuitSku: ExpressRouteCircuitSku,
    ExpressRouteCircuitServiceProviderProperties: ExpressRouteCircuitServiceProviderProperties,
    ExpressRouteCircuitsArpTableListResult: ExpressRouteCircuitsArpTableListResult,
    ExpressRouteCircuitArpTable: ExpressRouteCircuitArpTable,
    ExpressRouteCircuitsRoutesTableListResult: ExpressRouteCircuitsRoutesTableListResult,
    ExpressRouteCircuitRoutesTable: ExpressRouteCircuitRoutesTable,
    ExpressRouteCircuitsRoutesTableSummaryListResult: ExpressRouteCircuitsRoutesTableSummaryListResult,
    ExpressRouteCircuitRoutesTableSummary: ExpressRouteCircuitRoutesTableSummary,
    ExpressRouteCircuitListResult: ExpressRouteCircuitListResult,
    ExpressRouteServiceProviderListResult: ExpressRouteServiceProviderListResult,
    ExpressRouteServiceProviderBandwidthsOffered: ExpressRouteServiceProviderBandwidthsOffered,
    ExpressRouteCrossConnectionListResult: ExpressRouteCrossConnectionListResult,
    ExpressRouteCircuitReference: ExpressRouteCircuitReference,
    ExpressRouteCrossConnectionPeeringList: ExpressRouteCrossConnectionPeeringList,
    ExpressRouteCrossConnectionsRoutesTableSummaryListResult: ExpressRouteCrossConnectionsRoutesTableSummaryListResult,
    ExpressRouteCrossConnectionRoutesTableSummary: ExpressRouteCrossConnectionRoutesTableSummary,
    ExpressRoutePortsLocationListResult: ExpressRoutePortsLocationListResult,
    ExpressRoutePortsLocationBandwidths: ExpressRoutePortsLocationBandwidths,
    ExpressRouteLinkMacSecConfig: ExpressRouteLinkMacSecConfig,
    ExpressRoutePortListResult: ExpressRoutePortListResult,
    ExpressRouteLinkListResult: ExpressRouteLinkListResult,
    GenerateExpressRoutePortsLOARequest: GenerateExpressRoutePortsLOARequest,
    GenerateExpressRoutePortsLOAResult: GenerateExpressRoutePortsLOAResult,
    ExpressRoutePortAuthorizationListResult: ExpressRoutePortAuthorizationListResult,
    ExpressRouteProviderPortListResult: ExpressRouteProviderPortListResult,
    FirewallPolicyThreatIntelWhitelist: FirewallPolicyThreatIntelWhitelist,
    FirewallPolicyInsights: FirewallPolicyInsights,
    FirewallPolicyLogAnalyticsResources: FirewallPolicyLogAnalyticsResources,
    FirewallPolicyLogAnalyticsWorkspace: FirewallPolicyLogAnalyticsWorkspace,
    FirewallPolicySnat: FirewallPolicySnat,
    FirewallPolicySQL: FirewallPolicySQL,
    DnsSettings: DnsSettings,
    ExplicitProxy: ExplicitProxy,
    FirewallPolicyIntrusionDetection: FirewallPolicyIntrusionDetection,
    FirewallPolicyIntrusionDetectionConfiguration: FirewallPolicyIntrusionDetectionConfiguration,
    FirewallPolicyIntrusionDetectionSignatureSpecification: FirewallPolicyIntrusionDetectionSignatureSpecification,
    FirewallPolicyIntrusionDetectionBypassTrafficSpecifications: FirewallPolicyIntrusionDetectionBypassTrafficSpecifications,
    FirewallPolicyTransportSecurity: FirewallPolicyTransportSecurity,
    FirewallPolicyCertificateAuthority: FirewallPolicyCertificateAuthority,
    FirewallPolicySku: FirewallPolicySku,
    FirewallPolicyListResult: FirewallPolicyListResult,
    FirewallPolicyRuleCollection: FirewallPolicyRuleCollection,
    FirewallPolicyRuleCollectionGroupListResult: FirewallPolicyRuleCollectionGroupListResult,
    IdpsQueryObject: IdpsQueryObject,
    FilterItems: FilterItems,
    OrderBy: OrderBy,
    QueryResults: QueryResults,
    SingleQueryResult: SingleQueryResult,
    SignaturesOverrides: SignaturesOverrides,
    SignaturesOverridesProperties: SignaturesOverridesProperties,
    SignatureOverridesFilterValuesQuery: SignatureOverridesFilterValuesQuery,
    SignatureOverridesFilterValuesResponse: SignatureOverridesFilterValuesResponse,
    SignaturesOverridesList: SignaturesOverridesList,
    IpAllocationListResult: IpAllocationListResult,
    IpGroupListResult: IpGroupListResult,
    LoadBalancerSku: LoadBalancerSku,
    LoadBalancerListResult: LoadBalancerListResult,
    LoadBalancerBackendAddressPoolListResult: LoadBalancerBackendAddressPoolListResult,
    LoadBalancerFrontendIPConfigurationListResult: LoadBalancerFrontendIPConfigurationListResult,
    InboundNatRuleListResult: InboundNatRuleListResult,
    LoadBalancerLoadBalancingRuleListResult: LoadBalancerLoadBalancingRuleListResult,
    LoadBalancerOutboundRuleListResult: LoadBalancerOutboundRuleListResult,
    LoadBalancerProbeListResult: LoadBalancerProbeListResult,
    LoadBalancerVipSwapRequest: LoadBalancerVipSwapRequest,
    LoadBalancerVipSwapRequestFrontendIPConfiguration: LoadBalancerVipSwapRequestFrontendIPConfiguration,
    QueryInboundNatRulePortMappingRequest: QueryInboundNatRulePortMappingRequest,
    BackendAddressInboundNatRulePortMappings: BackendAddressInboundNatRulePortMappings,
    InboundNatRulePortMapping: InboundNatRulePortMapping,
    NatGatewayListResult: NatGatewayListResult,
    EffectiveRouteListResult: EffectiveRouteListResult,
    EffectiveRoute: EffectiveRoute,
    EffectiveNetworkSecurityGroupListResult: EffectiveNetworkSecurityGroupListResult,
    EffectiveNetworkSecurityGroup: EffectiveNetworkSecurityGroup,
    EffectiveNetworkSecurityGroupAssociation: EffectiveNetworkSecurityGroupAssociation,
    EffectiveNetworkSecurityRule: EffectiveNetworkSecurityRule,
    NetworkInterfaceIPConfigurationListResult: NetworkInterfaceIPConfigurationListResult,
    NetworkInterfaceLoadBalancerListResult: NetworkInterfaceLoadBalancerListResult,
    NetworkInterfaceTapConfigurationListResult: NetworkInterfaceTapConfigurationListResult,
    NetworkManagerPropertiesNetworkManagerScopes: NetworkManagerPropertiesNetworkManagerScopes,
    CrossTenantScopes: CrossTenantScopes,
    SystemData: SystemData,
    PatchObject: PatchObject,
    NetworkManagerCommit: NetworkManagerCommit,
    NetworkManagerDeploymentStatusParameter: NetworkManagerDeploymentStatusParameter,
    NetworkManagerDeploymentStatusListResult: NetworkManagerDeploymentStatusListResult,
    NetworkManagerDeploymentStatus: NetworkManagerDeploymentStatus,
    NetworkManagerListResult: NetworkManagerListResult,
    ActiveConfigurationParameter: ActiveConfigurationParameter,
    ActiveConnectivityConfigurationsListResult: ActiveConnectivityConfigurationsListResult,
    EffectiveConnectivityConfiguration: EffectiveConnectivityConfiguration,
    Hub: Hub,
    ConnectivityGroupItem: ConnectivityGroupItem,
    ConfigurationGroup: ConfigurationGroup,
    ActiveSecurityAdminRulesListResult: ActiveSecurityAdminRulesListResult,
    ActiveBaseSecurityAdminRule: ActiveBaseSecurityAdminRule,
    NetworkManagerSecurityGroupItem: NetworkManagerSecurityGroupItem,
    ChildResource: ChildResource,
    NetworkManagerConnectionListResult: NetworkManagerConnectionListResult,
    ConnectivityConfigurationListResult: ConnectivityConfigurationListResult,
    QueryRequestOptions: QueryRequestOptions,
    NetworkManagerEffectiveConnectivityConfigurationListResult: NetworkManagerEffectiveConnectivityConfigurationListResult,
    NetworkManagerEffectiveSecurityAdminRulesListResult: NetworkManagerEffectiveSecurityAdminRulesListResult,
    EffectiveBaseSecurityAdminRule: EffectiveBaseSecurityAdminRule,
    NetworkGroupListResult: NetworkGroupListResult,
    StaticMemberListResult: StaticMemberListResult,
    ScopeConnectionListResult: ScopeConnectionListResult,
    SecurityAdminConfigurationListResult: SecurityAdminConfigurationListResult,
    AdminRuleCollectionListResult: AdminRuleCollectionListResult,
    AdminRuleListResult: AdminRuleListResult,
    ContainerNetworkInterfaceIpConfiguration: ContainerNetworkInterfaceIpConfiguration,
    NetworkProfileListResult: NetworkProfileListResult,
    NetworkSecurityGroupListResult: NetworkSecurityGroupListResult,
    SecurityRuleListResult: SecurityRuleListResult,
    VirtualApplianceSkuProperties: VirtualApplianceSkuProperties,
    VirtualApplianceNicProperties: VirtualApplianceNicProperties,
    DelegationProperties: DelegationProperties,
    PartnerManagedResourceProperties: PartnerManagedResourceProperties,
    NetworkVirtualApplianceListResult: NetworkVirtualApplianceListResult,
    Office365PolicyProperties: Office365PolicyProperties,
    BreakOutCategoryPolicies: BreakOutCategoryPolicies,
    NetworkVirtualApplianceSiteListResult: NetworkVirtualApplianceSiteListResult,
    NetworkVirtualApplianceSkuListResult: NetworkVirtualApplianceSkuListResult,
    NetworkVirtualApplianceSkuInstances: NetworkVirtualApplianceSkuInstances,
    InboundSecurityRules: InboundSecurityRules,
    ErrorResponse: ErrorResponse,
    NetworkWatcherListResult: NetworkWatcherListResult,
    TopologyParameters: TopologyParameters,
    Topology: Topology,
    TopologyResource: TopologyResource,
    TopologyAssociation: TopologyAssociation,
    VerificationIPFlowParameters: VerificationIPFlowParameters,
    VerificationIPFlowResult: VerificationIPFlowResult,
    NextHopParameters: NextHopParameters,
    NextHopResult: NextHopResult,
    SecurityGroupViewParameters: SecurityGroupViewParameters,
    SecurityGroupViewResult: SecurityGroupViewResult,
    SecurityGroupNetworkInterface: SecurityGroupNetworkInterface,
    SecurityRuleAssociations: SecurityRuleAssociations,
    NetworkInterfaceAssociation: NetworkInterfaceAssociation,
    SubnetAssociation: SubnetAssociation,
    PacketCapture: PacketCapture,
    PacketCaptureParameters: PacketCaptureParameters,
    PacketCaptureMachineScope: PacketCaptureMachineScope,
    PacketCaptureStorageLocation: PacketCaptureStorageLocation,
    PacketCaptureFilter: PacketCaptureFilter,
    PacketCaptureResult: PacketCaptureResult,
    PacketCaptureQueryStatusResult: PacketCaptureQueryStatusResult,
    PacketCaptureListResult: PacketCaptureListResult,
    TroubleshootingParameters: TroubleshootingParameters,
    TroubleshootingResult: TroubleshootingResult,
    TroubleshootingDetails: TroubleshootingDetails,
    TroubleshootingRecommendedActions: TroubleshootingRecommendedActions,
    QueryTroubleshootingParameters: QueryTroubleshootingParameters,
    FlowLogInformation: FlowLogInformation,
    FlowLogStatusParameters: FlowLogStatusParameters,
    ConnectivityParameters: ConnectivityParameters,
    ConnectivitySource: ConnectivitySource,
    ConnectivityDestination: ConnectivityDestination,
    ProtocolConfiguration: ProtocolConfiguration,
    HttpConfiguration: HttpConfiguration,
    HttpHeader: HttpHeader,
    ConnectivityInformation: ConnectivityInformation,
    ConnectivityHop: ConnectivityHop,
    HopLink: HopLink,
    ConnectivityIssue: ConnectivityIssue,
    AzureReachabilityReportParameters: AzureReachabilityReportParameters,
    AzureReachabilityReportLocation: AzureReachabilityReportLocation,
    AzureReachabilityReport: AzureReachabilityReport,
    AzureReachabilityReportItem: AzureReachabilityReportItem,
    AzureReachabilityReportLatencyInfo: AzureReachabilityReportLatencyInfo,
    AvailableProvidersListParameters: AvailableProvidersListParameters,
    AvailableProvidersList: AvailableProvidersList,
    AvailableProvidersListCountry: AvailableProvidersListCountry,
    AvailableProvidersListState: AvailableProvidersListState,
    AvailableProvidersListCity: AvailableProvidersListCity,
    NetworkConfigurationDiagnosticParameters: NetworkConfigurationDiagnosticParameters,
    NetworkConfigurationDiagnosticProfile: NetworkConfigurationDiagnosticProfile,
    NetworkConfigurationDiagnosticResponse: NetworkConfigurationDiagnosticResponse,
    NetworkConfigurationDiagnosticResult: NetworkConfigurationDiagnosticResult,
    NetworkSecurityGroupResult: NetworkSecurityGroupResult,
    EvaluatedNetworkSecurityGroup: EvaluatedNetworkSecurityGroup,
    MatchedRule: MatchedRule,
    NetworkSecurityRulesEvaluationResult: NetworkSecurityRulesEvaluationResult,
    ConnectionMonitor: ConnectionMonitor,
    ConnectionMonitorParameters: ConnectionMonitorParameters,
    ConnectionMonitorSource: ConnectionMonitorSource,
    ConnectionMonitorDestination: ConnectionMonitorDestination,
    ConnectionMonitorEndpoint: ConnectionMonitorEndpoint,
    ConnectionMonitorEndpointFilter: ConnectionMonitorEndpointFilter,
    ConnectionMonitorEndpointFilterItem: ConnectionMonitorEndpointFilterItem,
    ConnectionMonitorEndpointScope: ConnectionMonitorEndpointScope,
    ConnectionMonitorEndpointScopeItem: ConnectionMonitorEndpointScopeItem,
    ConnectionMonitorTestConfiguration: ConnectionMonitorTestConfiguration,
    ConnectionMonitorHttpConfiguration: ConnectionMonitorHttpConfiguration,
    ConnectionMonitorTcpConfiguration: ConnectionMonitorTcpConfiguration,
    ConnectionMonitorIcmpConfiguration: ConnectionMonitorIcmpConfiguration,
    ConnectionMonitorSuccessThreshold: ConnectionMonitorSuccessThreshold,
    ConnectionMonitorTestGroup: ConnectionMonitorTestGroup,
    ConnectionMonitorOutput: ConnectionMonitorOutput,
    ConnectionMonitorWorkspaceSettings: ConnectionMonitorWorkspaceSettings,
    ConnectionMonitorResult: ConnectionMonitorResult,
    ConnectionMonitorQueryResult: ConnectionMonitorQueryResult,
    ConnectionStateSnapshot: ConnectionStateSnapshot,
    ConnectionMonitorListResult: ConnectionMonitorListResult,
    FlowLogListResult: FlowLogListResult,
    OperationListResult: OperationListResult,
    Operation: Operation,
    OperationDisplay: OperationDisplay,
    OperationPropertiesFormatServiceSpecification: OperationPropertiesFormatServiceSpecification,
    MetricSpecification: MetricSpecification,
    Availability: Availability,
    Dimension: Dimension,
    LogSpecification: LogSpecification,
    PrivateEndpointListResult: PrivateEndpointListResult,
    AvailablePrivateEndpointTypesResult: AvailablePrivateEndpointTypesResult,
    AvailablePrivateEndpointType: AvailablePrivateEndpointType,
    PrivateDnsZoneConfig: PrivateDnsZoneConfig,
    RecordSet: RecordSet,
    PrivateDnsZoneGroupListResult: PrivateDnsZoneGroupListResult,
    PrivateLinkServiceListResult: PrivateLinkServiceListResult,
    PrivateEndpointConnectionListResult: PrivateEndpointConnectionListResult,
    CheckPrivateLinkServiceVisibilityRequest: CheckPrivateLinkServiceVisibilityRequest,
    PrivateLinkServiceVisibility: PrivateLinkServiceVisibility,
    AutoApprovedPrivateLinkServicesResult: AutoApprovedPrivateLinkServicesResult,
    AutoApprovedPrivateLinkService: AutoApprovedPrivateLinkService,
    PublicIpDdosProtectionStatusResult: PublicIpDdosProtectionStatusResult,
    PublicIPPrefixSku: PublicIPPrefixSku,
    ReferencedPublicIpAddress: ReferencedPublicIpAddress,
    PublicIPPrefixListResult: PublicIPPrefixListResult,
    RouteFilterListResult: RouteFilterListResult,
    RouteFilterRuleListResult: RouteFilterRuleListResult,
    RouteTableListResult: RouteTableListResult,
    RouteListResult: RouteListResult,
    SecurityPartnerProviderListResult: SecurityPartnerProviderListResult,
    BgpServiceCommunityListResult: BgpServiceCommunityListResult,
    BGPCommunity: BGPCommunity,
    ServiceEndpointPolicyListResult: ServiceEndpointPolicyListResult,
    ServiceEndpointPolicyDefinitionListResult: ServiceEndpointPolicyDefinitionListResult,
    ServiceTagsListResult: ServiceTagsListResult,
    ServiceTagInformation: ServiceTagInformation,
    ServiceTagInformationPropertiesFormat: ServiceTagInformationPropertiesFormat,
    ServiceTagInformationListResult: ServiceTagInformationListResult,
    UsagesListResult: UsagesListResult,
    Usage: Usage,
    UsageName: UsageName,
    AddressSpace: AddressSpace,
    DhcpOptions: DhcpOptions,
    VirtualNetworkBgpCommunities: VirtualNetworkBgpCommunities,
    VirtualNetworkEncryption: VirtualNetworkEncryption,
    VirtualNetworkListResult: VirtualNetworkListResult,
    PrepareNetworkPoliciesRequest: PrepareNetworkPoliciesRequest,
    NetworkIntentPolicyConfiguration: NetworkIntentPolicyConfiguration,
    UnprepareNetworkPoliciesRequest: UnprepareNetworkPoliciesRequest,
    ResourceNavigationLinksListResult: ResourceNavigationLinksListResult,
    ServiceAssociationLinksListResult: ServiceAssociationLinksListResult,
    SubnetListResult: SubnetListResult,
    VirtualNetworkPeeringListResult: VirtualNetworkPeeringListResult,
    IPAddressAvailabilityResult: IPAddressAvailabilityResult,
    VirtualNetworkListUsageResult: VirtualNetworkListUsageResult,
    VirtualNetworkUsage: VirtualNetworkUsage,
    VirtualNetworkUsageName: VirtualNetworkUsageName,
    VirtualNetworkDdosProtectionStatusResult: VirtualNetworkDdosProtectionStatusResult,
    VirtualNetworkGatewaySku: VirtualNetworkGatewaySku,
    VpnClientConfiguration: VpnClientConfiguration,
    IpsecPolicy: IpsecPolicy,
    RadiusServer: RadiusServer,
    VirtualNetworkGatewayPolicyGroupMember: VirtualNetworkGatewayPolicyGroupMember,
    BgpSettings: BgpSettings,
    IPConfigurationBgpPeeringAddress: IPConfigurationBgpPeeringAddress,
    VpnNatRuleMapping: VpnNatRuleMapping,
    VirtualNetworkGatewayListResult: VirtualNetworkGatewayListResult,
    VirtualNetworkGatewayListConnectionsResult: VirtualNetworkGatewayListConnectionsResult,
    VirtualNetworkConnectionGatewayReference: VirtualNetworkConnectionGatewayReference,
    TunnelConnectionHealth: TunnelConnectionHealth,
    GatewayCustomBgpIpAddressIpConfiguration: GatewayCustomBgpIpAddressIpConfiguration,
    TrafficSelectorPolicy: TrafficSelectorPolicy,
    VpnClientParameters: VpnClientParameters,
    BgpPeerStatusListResult: BgpPeerStatusListResult,
    BgpPeerStatus: BgpPeerStatus,
    GatewayRouteListResult: GatewayRouteListResult,
    GatewayRoute: GatewayRoute,
    VpnClientIPsecParameters: VpnClientIPsecParameters,
    VpnDeviceScriptParameters: VpnDeviceScriptParameters,
    VpnPacketCaptureStartParameters: VpnPacketCaptureStartParameters,
    VpnPacketCaptureStopParameters: VpnPacketCaptureStopParameters,
    VirtualNetworkGatewayConnectionListResult: VirtualNetworkGatewayConnectionListResult,
    ConnectionResetSharedKey: ConnectionResetSharedKey,
    LocalNetworkGatewayListResult: LocalNetworkGatewayListResult,
    VpnClientConnectionHealthDetailListResult: VpnClientConnectionHealthDetailListResult,
    VpnClientConnectionHealthDetail: VpnClientConnectionHealthDetail,
    P2SVpnConnectionRequest: P2SVpnConnectionRequest,
    ListVirtualNetworkGatewayNatRulesResult: ListVirtualNetworkGatewayNatRulesResult,
    VirtualNetworkTapListResult: VirtualNetworkTapListResult,
    VirtualRouterListResult: VirtualRouterListResult,
    VirtualRouterPeeringListResult: VirtualRouterPeeringListResult,
    ListVirtualWANsResult: ListVirtualWANsResult,
    DeviceProperties: DeviceProperties,
    VpnLinkProviderProperties: VpnLinkProviderProperties,
    VpnLinkBgpSettings: VpnLinkBgpSettings,
    O365PolicyProperties: O365PolicyProperties,
    O365BreakOutCategoryPolicies: O365BreakOutCategoryPolicies,
    ListVpnSitesResult: ListVpnSitesResult,
    ListVpnSiteLinksResult: ListVpnSiteLinksResult,
    GetVpnSitesConfigurationRequest: GetVpnSitesConfigurationRequest,
    VirtualWanSecurityProviders: VirtualWanSecurityProviders,
    VirtualWanSecurityProvider: VirtualWanSecurityProvider,
    VpnServerConfigVpnClientRootCertificate: VpnServerConfigVpnClientRootCertificate,
    VpnServerConfigVpnClientRevokedCertificate: VpnServerConfigVpnClientRevokedCertificate,
    VpnServerConfigRadiusServerRootCertificate: VpnServerConfigRadiusServerRootCertificate,
    VpnServerConfigRadiusClientRootCertificate: VpnServerConfigRadiusClientRootCertificate,
    AadAuthenticationParameters: AadAuthenticationParameters,
    RoutingConfiguration: RoutingConfiguration,
    PropagatedRouteTable: PropagatedRouteTable,
    VnetRoute: VnetRoute,
    StaticRoutesConfig: StaticRoutesConfig,
    StaticRoute: StaticRoute,
    VpnServerConfigurationPolicyGroupMember: VpnServerConfigurationPolicyGroupMember,
    VpnClientConnectionHealth: VpnClientConnectionHealth,
    ListVpnServerConfigurationsResult: ListVpnServerConfigurationsResult,
    ListVpnServerConfigurationPolicyGroupsResult: ListVpnServerConfigurationPolicyGroupsResult,
    VirtualHubRouteTable: VirtualHubRouteTable,
    VirtualHubRoute: VirtualHubRoute,
    VirtualHubRouteV2: VirtualHubRouteV2,
    VirtualRouterAutoScaleConfiguration: VirtualRouterAutoScaleConfiguration,
    ListVirtualHubsResult: ListVirtualHubsResult,
    RouteMapRule: RouteMapRule,
    Criterion: Criterion,
    Action: Action,
    Parameter: Parameter,
    ListRouteMapsResult: ListRouteMapsResult,
    ListHubVirtualNetworkConnectionsResult: ListHubVirtualNetworkConnectionsResult,
    VpnGatewayIpConfiguration: VpnGatewayIpConfiguration,
    VpnGatewayPacketCaptureStartParameters: VpnGatewayPacketCaptureStartParameters,
    VpnGatewayPacketCaptureStopParameters: VpnGatewayPacketCaptureStopParameters,
    ListVpnGatewaysResult: ListVpnGatewaysResult,
    VpnConnectionPacketCaptureStartParameters: VpnConnectionPacketCaptureStartParameters,
    VpnConnectionPacketCaptureStopParameters: VpnConnectionPacketCaptureStopParameters,
    ListVpnConnectionsResult: ListVpnConnectionsResult,
    ListVpnSiteLinkConnectionsResult: ListVpnSiteLinkConnectionsResult,
    ListVpnGatewayNatRulesResult: ListVpnGatewayNatRulesResult,
    ListP2SVpnGatewaysResult: ListP2SVpnGatewaysResult,
    P2SVpnProfileParameters: P2SVpnProfileParameters,
    VpnProfileResponse: VpnProfileResponse,
    P2SVpnConnectionHealthRequest: P2SVpnConnectionHealthRequest,
    P2SVpnConnectionHealth: P2SVpnConnectionHealth,
    VpnServerConfigurationsResponse: VpnServerConfigurationsResponse,
    VirtualWanVpnProfileParameters: VirtualWanVpnProfileParameters,
    ListVirtualHubRouteTableV2SResult: ListVirtualHubRouteTableV2SResult,
    ExpressRouteGatewayList: ExpressRouteGatewayList,
    ExpressRouteGatewayPropertiesAutoScaleConfiguration: ExpressRouteGatewayPropertiesAutoScaleConfiguration,
    ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds: ExpressRouteGatewayPropertiesAutoScaleConfigurationBounds,
    ExpressRouteCircuitPeeringId: ExpressRouteCircuitPeeringId,
    VirtualHubId: VirtualHubId,
    ExpressRouteConnectionList: ExpressRouteConnectionList,
    ListVirtualHubBgpConnectionResults: ListVirtualHubBgpConnectionResults,
    PeerRouteList: PeerRouteList,
    PeerRoute: PeerRoute,
    ListVirtualHubIpConfigurationResults: ListVirtualHubIpConfigurationResults,
    HubRoute: HubRoute,
    ListHubRouteTablesResult: ListHubRouteTablesResult,
    EffectiveRoutesParameters: EffectiveRoutesParameters,
    GetInboundRoutesParameters: GetInboundRoutesParameters,
    GetOutboundRoutesParameters: GetOutboundRoutesParameters,
    RoutingPolicy: RoutingPolicy,
    ListRoutingIntentResult: ListRoutingIntentResult,
    WebApplicationFirewallPolicyListResult: WebApplicationFirewallPolicyListResult,
    PolicySettings: PolicySettings,
    WebApplicationFirewallCustomRule: WebApplicationFirewallCustomRule,
    MatchCondition: MatchCondition,
    MatchVariable: MatchVariable,
    ManagedRulesDefinition: ManagedRulesDefinition,
    OwaspCrsExclusionEntry: OwaspCrsExclusionEntry,
    ExclusionManagedRuleSet: ExclusionManagedRuleSet,
    ExclusionManagedRuleGroup: ExclusionManagedRuleGroup,
    ExclusionManagedRule: ExclusionManagedRule,
    ManagedRuleSet: ManagedRuleSet,
    ManagedRuleGroupOverride: ManagedRuleGroupOverride,
    ManagedRuleOverride: ManagedRuleOverride,
    FirewallPolicyNatRuleCollectionAction: FirewallPolicyNatRuleCollectionAction,
    FirewallPolicyRule: FirewallPolicyRule,
    FirewallPolicyFilterRuleCollectionAction: FirewallPolicyFilterRuleCollectionAction,
    FirewallPolicyRuleApplicationProtocol: FirewallPolicyRuleApplicationProtocol,
    AzureAsyncOperationResult: AzureAsyncOperationResult,
    AddressPrefixItem: AddressPrefixItem,
    VpnSiteId: VpnSiteId,
    VirtualHubEffectiveRouteList: VirtualHubEffectiveRouteList,
    VirtualHubEffectiveRoute: VirtualHubEffectiveRoute,
    EffectiveRouteMapRoute: EffectiveRouteMapRoute,
    ApplicationGatewayIPConfiguration: ApplicationGatewayIPConfiguration,
    ApplicationGatewayAuthenticationCertificate: ApplicationGatewayAuthenticationCertificate,
    ApplicationGatewayTrustedRootCertificate: ApplicationGatewayTrustedRootCertificate,
    ApplicationGatewayTrustedClientCertificate: ApplicationGatewayTrustedClientCertificate,
    ApplicationGatewaySslCertificate: ApplicationGatewaySslCertificate,
    ApplicationGatewayFrontendIPConfiguration: ApplicationGatewayFrontendIPConfiguration,
    ApplicationGatewayFrontendPort: ApplicationGatewayFrontendPort,
    ApplicationGatewayProbe: ApplicationGatewayProbe,
    NetworkInterfaceTapConfiguration: NetworkInterfaceTapConfiguration,
    SecurityRule: SecurityRule,
    PrivateLinkServiceConnection: PrivateLinkServiceConnection,
    PrivateLinkServiceIpConfiguration: PrivateLinkServiceIpConfiguration,
    PrivateEndpointConnection: PrivateEndpointConnection,
    Route: Route,
    ServiceEndpointPolicyDefinition: ServiceEndpointPolicyDefinition,
    IPConfiguration: IPConfiguration,
    IPConfigurationProfile: IPConfigurationProfile,
    ResourceNavigationLink: ResourceNavigationLink,
    ServiceAssociationLink: ServiceAssociationLink,
    Delegation: Delegation,
    Subnet: Subnet,
    FrontendIPConfiguration: FrontendIPConfiguration,
    BackendAddressPool: BackendAddressPool,
    InboundNatRule: InboundNatRule,
    NetworkInterfaceIPConfiguration: NetworkInterfaceIPConfiguration,
    ApplicationGatewayBackendAddressPool: ApplicationGatewayBackendAddressPool,
    ApplicationGatewayBackendHttpSettings: ApplicationGatewayBackendHttpSettings,
    ApplicationGatewayBackendSettings: ApplicationGatewayBackendSettings,
    ApplicationGatewayHttpListener: ApplicationGatewayHttpListener,
    ApplicationGatewayListener: ApplicationGatewayListener,
    ApplicationGatewaySslProfile: ApplicationGatewaySslProfile,
    ApplicationGatewayPathRule: ApplicationGatewayPathRule,
    ApplicationGatewayUrlPathMap: ApplicationGatewayUrlPathMap,
    ApplicationGatewayRequestRoutingRule: ApplicationGatewayRequestRoutingRule,
    ApplicationGatewayRoutingRule: ApplicationGatewayRoutingRule,
    ApplicationGatewayRewriteRuleSet: ApplicationGatewayRewriteRuleSet,
    ApplicationGatewayRedirectConfiguration: ApplicationGatewayRedirectConfiguration,
    ApplicationGatewayPrivateLinkIpConfiguration: ApplicationGatewayPrivateLinkIpConfiguration,
    ApplicationGatewayPrivateLinkConfiguration: ApplicationGatewayPrivateLinkConfiguration,
    ApplicationGatewayPrivateEndpointConnection: ApplicationGatewayPrivateEndpointConnection,
    ApplicationGatewayLoadDistributionTarget: ApplicationGatewayLoadDistributionTarget,
    ApplicationGatewayLoadDistributionPolicy: ApplicationGatewayLoadDistributionPolicy,
    ApplicationGatewayPrivateLinkResource: ApplicationGatewayPrivateLinkResource,
    ApplicationGatewaySslPredefinedPolicy: ApplicationGatewaySslPredefinedPolicy,
    AzureFirewallApplicationRuleCollection: AzureFirewallApplicationRuleCollection,
    AzureFirewallNatRuleCollection: AzureFirewallNatRuleCollection,
    AzureFirewallNetworkRuleCollection: AzureFirewallNetworkRuleCollection,
    AzureFirewallIPConfiguration: AzureFirewallIPConfiguration,
    BastionHostIPConfiguration: BastionHostIPConfiguration,
    EndpointServiceResult: EndpointServiceResult,
    ExpressRouteCircuitAuthorization: ExpressRouteCircuitAuthorization,
    ExpressRouteCircuitConnection: ExpressRouteCircuitConnection,
    PeerExpressRouteCircuitConnection: PeerExpressRouteCircuitConnection,
    ExpressRouteCircuitPeering: ExpressRouteCircuitPeering,
    ExpressRouteCrossConnectionPeering: ExpressRouteCrossConnectionPeering,
    ExpressRouteLink: ExpressRouteLink,
    ExpressRoutePortAuthorization: ExpressRoutePortAuthorization,
    FirewallPolicyRuleCollectionGroup: FirewallPolicyRuleCollectionGroup,
    LoadBalancingRule: LoadBalancingRule,
    Probe: Probe,
    InboundNatPool: InboundNatPool,
    OutboundRule: OutboundRule,
    ContainerNetworkInterfaceConfiguration: ContainerNetworkInterfaceConfiguration,
    Container: Container,
    ContainerNetworkInterface: ContainerNetworkInterface,
    VirtualApplianceSite: VirtualApplianceSite,
    InboundSecurityRule: InboundSecurityRule,
    PrivateDnsZoneGroup: PrivateDnsZoneGroup,
    RouteFilterRule: RouteFilterRule,
    VirtualNetworkPeering: VirtualNetworkPeering,
    VirtualNetworkGatewayIPConfiguration: VirtualNetworkGatewayIPConfiguration,
    VpnClientRootCertificate: VpnClientRootCertificate,
    VpnClientRevokedCertificate: VpnClientRevokedCertificate,
    VngClientConnectionConfiguration: VngClientConnectionConfiguration,
    VirtualNetworkGatewayPolicyGroup: VirtualNetworkGatewayPolicyGroup,
    VirtualNetworkGatewayNatRule: VirtualNetworkGatewayNatRule,
    ConnectionSharedKey: ConnectionSharedKey,
    VirtualRouterPeering: VirtualRouterPeering,
    VpnSiteLink: VpnSiteLink,
    VpnServerConfigurationPolicyGroup: VpnServerConfigurationPolicyGroup,
    P2SConnectionConfiguration: P2SConnectionConfiguration,
    VirtualHubRouteTableV2: VirtualHubRouteTableV2,
    RouteMap: RouteMap,
    HubVirtualNetworkConnection: HubVirtualNetworkConnection,
    VpnSiteLinkConnection: VpnSiteLinkConnection,
    VpnConnection: VpnConnection,
    VpnGatewayNatRule: VpnGatewayNatRule,
    ExpressRouteConnection: ExpressRouteConnection,
    BgpConnection: BgpConnection,
    HubIpConfiguration: HubIpConfiguration,
    HubRouteTable: HubRouteTable,
    RoutingIntent: RoutingIntent,
    PatchRouteFilterRule: PatchRouteFilterRule,
    PatchRouteFilter: PatchRouteFilter,
    ApplicationSecurityGroup: ApplicationSecurityGroup,
    PrivateEndpoint: PrivateEndpoint,
    PrivateLinkService: PrivateLinkService,
    NetworkInterface: NetworkInterface,
    FlowLog: FlowLog,
    NetworkSecurityGroup: NetworkSecurityGroup,
    RouteTable: RouteTable,
    ServiceEndpointPolicy: ServiceEndpointPolicy,
    NatGateway: NatGateway,
    PublicIPAddress: PublicIPAddress,
    VirtualNetworkTap: VirtualNetworkTap,
    ApplicationGateway: ApplicationGateway,
    ApplicationGatewayFirewallRuleSet: ApplicationGatewayFirewallRuleSet,
    ApplicationGatewayAvailableSslOptions: ApplicationGatewayAvailableSslOptions,
    AzureFirewall: AzureFirewall,
    AzureFirewallFqdnTag: AzureFirewallFqdnTag,
    BastionHost: BastionHost,
    Vm: Vm,
    CustomIpPrefix: CustomIpPrefix,
    DdosCustomPolicy: DdosCustomPolicy,
    DscpConfiguration: DscpConfiguration,
    ExpressRouteCircuit: ExpressRouteCircuit,
    ExpressRouteServiceProvider: ExpressRouteServiceProvider,
    ExpressRouteCrossConnection: ExpressRouteCrossConnection,
    ExpressRoutePortsLocation: ExpressRoutePortsLocation,
    ExpressRoutePort: ExpressRoutePort,
    ExpressRouteProviderPort: ExpressRouteProviderPort,
    FirewallPolicy: FirewallPolicy,
    IpAllocation: IpAllocation,
    IpGroup: IpGroup,
    LoadBalancer: LoadBalancer,
    NetworkManager: NetworkManager,
    NetworkProfile: NetworkProfile,
    NetworkVirtualAppliance: NetworkVirtualAppliance,
    NetworkVirtualApplianceSku: NetworkVirtualApplianceSku,
    NetworkWatcher: NetworkWatcher,
    PublicIPPrefix: PublicIPPrefix,
    RouteFilter: RouteFilter,
    SecurityPartnerProvider: SecurityPartnerProvider,
    BgpServiceCommunity: BgpServiceCommunity,
    VirtualNetwork: VirtualNetwork,
    NetworkIntentPolicy: NetworkIntentPolicy,
    VirtualNetworkGateway: VirtualNetworkGateway,
    VirtualNetworkGatewayConnectionListEntity: VirtualNetworkGatewayConnectionListEntity,
    LocalNetworkGateway: LocalNetworkGateway,
    VirtualNetworkGatewayConnection: VirtualNetworkGatewayConnection,
    VirtualRouter: VirtualRouter,
    VirtualWAN: VirtualWAN,
    VpnSite: VpnSite,
    P2SVpnGateway: P2SVpnGateway,
    VpnServerConfiguration: VpnServerConfiguration,
    VirtualHub: VirtualHub,
    VpnGateway: VpnGateway,
    ExpressRouteGateway: ExpressRouteGateway,
    WebApplicationFirewallPolicy: WebApplicationFirewallPolicy,
    PrivateLinkServicePropertiesVisibility: PrivateLinkServicePropertiesVisibility,
    PrivateLinkServicePropertiesAutoApproval: PrivateLinkServicePropertiesAutoApproval,
    FirewallPolicyNatRuleCollection: FirewallPolicyNatRuleCollection,
    FirewallPolicyFilterRuleCollection: FirewallPolicyFilterRuleCollection,
    ActiveConnectivityConfiguration: ActiveConnectivityConfiguration,
    ActiveSecurityAdminRule: ActiveSecurityAdminRule,
    ActiveDefaultSecurityAdminRule: ActiveDefaultSecurityAdminRule,
    NetworkManagerConnection: NetworkManagerConnection,
    ConnectivityConfiguration: ConnectivityConfiguration,
    NetworkGroup: NetworkGroup,
    StaticMember: StaticMember,
    ScopeConnection: ScopeConnection,
    SecurityAdminConfiguration: SecurityAdminConfiguration,
    AdminRuleCollection: AdminRuleCollection,
    BaseAdminRule: BaseAdminRule,
    EffectiveSecurityAdminRule: EffectiveSecurityAdminRule,
    EffectiveDefaultSecurityAdminRule: EffectiveDefaultSecurityAdminRule,
    PacketCaptureResultProperties: PacketCaptureResultProperties,
    ConnectionMonitorResultProperties: ConnectionMonitorResultProperties,
    ApplicationRule: ApplicationRule,
    NatRule: NatRule,
    NetworkRule: NetworkRule,
    AdminRule: AdminRule,
    DefaultAdminRule: DefaultAdminRule,
    PublicIPAddressesDeleteHeaders: PublicIPAddressesDeleteHeaders,
    PublicIPAddressesDdosProtectionStatusHeaders: PublicIPAddressesDdosProtectionStatusHeaders,
    DdosProtectionPlansDeleteHeaders: DdosProtectionPlansDeleteHeaders,
    NetworkManagersDeleteHeaders: NetworkManagersDeleteHeaders,
    NetworkManagerCommitsPostHeaders: NetworkManagerCommitsPostHeaders,
    ConnectivityConfigurationsDeleteHeaders: ConnectivityConfigurationsDeleteHeaders,
    NetworkGroupsCreateOrUpdateHeaders: NetworkGroupsCreateOrUpdateHeaders,
    NetworkGroupsDeleteHeaders: NetworkGroupsDeleteHeaders,
    SecurityAdminConfigurationsDeleteHeaders: SecurityAdminConfigurationsDeleteHeaders,
    AdminRuleCollectionsDeleteHeaders: AdminRuleCollectionsDeleteHeaders,
    AdminRulesDeleteHeaders: AdminRulesDeleteHeaders,
    discriminators: discriminators
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const $host = {
    parameterPath: "$host",
    mapper: {
        serializedName: "$host",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const resourceGroupName = {
    parameterPath: "resourceGroupName",
    mapper: {
        serializedName: "resourceGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const applicationGatewayName = {
    parameterPath: "applicationGatewayName",
    mapper: {
        serializedName: "applicationGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2022-09-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const subscriptionId = {
    parameterPath: "subscriptionId",
    mapper: {
        serializedName: "subscriptionId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const parameters = {
    parameterPath: "parameters",
    mapper: ApplicationGateway
};
const parameters1 = {
    parameterPath: "parameters",
    mapper: TagsObject
};
const expand = {
    parameterPath: ["options", "expand"],
    mapper: {
        serializedName: "$expand",
        type: {
            name: "String"
        }
    }
};
const probeRequest = {
    parameterPath: "probeRequest",
    mapper: ApplicationGatewayOnDemandProbe
};
const predefinedPolicyName = {
    parameterPath: "predefinedPolicyName",
    mapper: {
        serializedName: "predefinedPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const connectionName = {
    parameterPath: "connectionName",
    mapper: {
        serializedName: "connectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters2 = {
    parameterPath: "parameters",
    mapper: ApplicationGatewayPrivateEndpointConnection
};
const location = {
    parameterPath: "location",
    mapper: {
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const applicationSecurityGroupName = {
    parameterPath: "applicationSecurityGroupName",
    mapper: {
        serializedName: "applicationSecurityGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters3 = {
    parameterPath: "parameters",
    mapper: ApplicationSecurityGroup
};
const azureFirewallName = {
    parameterPath: "azureFirewallName",
    mapper: {
        serializedName: "azureFirewallName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters4 = {
    parameterPath: "parameters",
    mapper: AzureFirewall
};
const azureFirewallName1 = {
    parameterPath: "azureFirewallName",
    mapper: {
        constraints: {
            MaxLength: 56,
            MinLength: 1
        },
        serializedName: "azureFirewallName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const bastionHostName = {
    parameterPath: "bastionHostName",
    mapper: {
        serializedName: "bastionHostName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters5 = {
    parameterPath: "parameters",
    mapper: BastionHost
};
const bslRequest = {
    parameterPath: "bslRequest",
    mapper: BastionShareableLinkListRequest
};
const sessionIds = {
    parameterPath: "sessionIds",
    mapper: SessionIds
};
const domainNameLabel = {
    parameterPath: "domainNameLabel",
    mapper: {
        serializedName: "domainNameLabel",
        required: true,
        type: {
            name: "String"
        }
    }
};
const providerport = {
    parameterPath: "providerport",
    mapper: {
        serializedName: "providerport",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters6 = {
    parameterPath: "parameters",
    mapper: ActiveConfigurationParameter
};
const networkManagerName = {
    parameterPath: "networkManagerName",
    mapper: {
        serializedName: "networkManagerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        constraints: {
            InclusiveMaximum: 20,
            InclusiveMinimum: 1
        },
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const parameters7 = {
    parameterPath: "parameters",
    mapper: QueryRequestOptions
};
const virtualNetworkName = {
    parameterPath: "virtualNetworkName",
    mapper: {
        serializedName: "virtualNetworkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualWANName = {
    parameterPath: "virtualWANName",
    mapper: {
        serializedName: "virtualWANName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnClientParams = {
    parameterPath: "vpnClientParams",
    mapper: VirtualWanVpnProfileParameters
};
const cloudServiceName = {
    parameterPath: "cloudServiceName",
    mapper: {
        serializedName: "cloudServiceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const roleInstanceName = {
    parameterPath: "roleInstanceName",
    mapper: {
        serializedName: "roleInstanceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const networkInterfaceName = {
    parameterPath: "networkInterfaceName",
    mapper: {
        serializedName: "networkInterfaceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters8 = {
    parameterPath: "parameters",
    mapper: NetworkInterface
};
const virtualMachineScaleSetName = {
    parameterPath: "virtualMachineScaleSetName",
    mapper: {
        serializedName: "virtualMachineScaleSetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualmachineIndex = {
    parameterPath: "virtualmachineIndex",
    mapper: {
        serializedName: "virtualmachineIndex",
        required: true,
        type: {
            name: "String"
        }
    }
};
const apiVersion1 = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2018-10-01",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const ipConfigurationName = {
    parameterPath: "ipConfigurationName",
    mapper: {
        serializedName: "ipConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const publicIpAddressName = {
    parameterPath: "publicIpAddressName",
    mapper: {
        serializedName: "publicIpAddressName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters9 = {
    parameterPath: "parameters",
    mapper: PublicIPAddress
};
const groupName = {
    parameterPath: "groupName",
    mapper: {
        serializedName: "groupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const resourceName = {
    parameterPath: "resourceName",
    mapper: {
        serializedName: "resourceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const singletonResource = {
    parameterPath: "singletonResource",
    mapper: {
        defaultValue: "swap",
        isConstant: true,
        serializedName: "singletonResource",
        type: {
            name: "String"
        }
    }
};
const parameters10 = {
    parameterPath: "parameters",
    mapper: SwapResource
};
const customIpPrefixName = {
    parameterPath: "customIpPrefixName",
    mapper: {
        serializedName: "customIpPrefixName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters11 = {
    parameterPath: "parameters",
    mapper: CustomIpPrefix
};
const ddosCustomPolicyName = {
    parameterPath: "ddosCustomPolicyName",
    mapper: {
        serializedName: "ddosCustomPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters12 = {
    parameterPath: "parameters",
    mapper: DdosCustomPolicy
};
const ddosProtectionPlanName = {
    parameterPath: "ddosProtectionPlanName",
    mapper: {
        serializedName: "ddosProtectionPlanName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters13 = {
    parameterPath: "parameters",
    mapper: DdosProtectionPlan
};
const parameters14 = {
    parameterPath: "parameters",
    mapper: DscpConfiguration
};
const dscpConfigurationName = {
    parameterPath: "dscpConfigurationName",
    mapper: {
        serializedName: "dscpConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const circuitName = {
    parameterPath: "circuitName",
    mapper: {
        serializedName: "circuitName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const authorizationName = {
    parameterPath: "authorizationName",
    mapper: {
        serializedName: "authorizationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const authorizationParameters = {
    parameterPath: "authorizationParameters",
    mapper: ExpressRouteCircuitAuthorization
};
const peeringName = {
    parameterPath: "peeringName",
    mapper: {
        serializedName: "peeringName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const peeringParameters = {
    parameterPath: "peeringParameters",
    mapper: ExpressRouteCircuitPeering
};
const expressRouteCircuitConnectionParameters = {
    parameterPath: "expressRouteCircuitConnectionParameters",
    mapper: ExpressRouteCircuitConnection
};
const parameters15 = {
    parameterPath: "parameters",
    mapper: ExpressRouteCircuit
};
const devicePath = {
    parameterPath: "devicePath",
    mapper: {
        serializedName: "devicePath",
        required: true,
        type: {
            name: "String"
        }
    }
};
const crossConnectionName = {
    parameterPath: "crossConnectionName",
    mapper: {
        serializedName: "crossConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters16 = {
    parameterPath: "parameters",
    mapper: ExpressRouteCrossConnection
};
const crossConnectionParameters = {
    parameterPath: "crossConnectionParameters",
    mapper: TagsObject
};
const peeringParameters1 = {
    parameterPath: "peeringParameters",
    mapper: ExpressRouteCrossConnectionPeering
};
const locationName = {
    parameterPath: "locationName",
    mapper: {
        serializedName: "locationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expressRoutePortName = {
    parameterPath: "expressRoutePortName",
    mapper: {
        serializedName: "expressRoutePortName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters17 = {
    parameterPath: "parameters",
    mapper: ExpressRoutePort
};
const request = {
    parameterPath: "request",
    mapper: GenerateExpressRoutePortsLOARequest
};
const linkName = {
    parameterPath: "linkName",
    mapper: {
        serializedName: "linkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const authorizationParameters1 = {
    parameterPath: "authorizationParameters",
    mapper: ExpressRoutePortAuthorization
};
const filter = {
    parameterPath: ["options", "filter"],
    mapper: {
        serializedName: "$filter",
        type: {
            name: "String"
        }
    }
};
const firewallPolicyName = {
    parameterPath: "firewallPolicyName",
    mapper: {
        serializedName: "firewallPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters18 = {
    parameterPath: "parameters",
    mapper: FirewallPolicy
};
const ruleCollectionGroupName = {
    parameterPath: "ruleCollectionGroupName",
    mapper: {
        serializedName: "ruleCollectionGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters19 = {
    parameterPath: "parameters",
    mapper: FirewallPolicyRuleCollectionGroup
};
const parameters20 = {
    parameterPath: "parameters",
    mapper: IdpsQueryObject
};
const parameters21 = {
    parameterPath: "parameters",
    mapper: SignaturesOverrides
};
const parameters22 = {
    parameterPath: "parameters",
    mapper: SignatureOverridesFilterValuesQuery
};
const ipAllocationName = {
    parameterPath: "ipAllocationName",
    mapper: {
        serializedName: "ipAllocationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters23 = {
    parameterPath: "parameters",
    mapper: IpAllocation
};
const ipGroupsName = {
    parameterPath: "ipGroupsName",
    mapper: {
        serializedName: "ipGroupsName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters24 = {
    parameterPath: "parameters",
    mapper: IpGroup
};
const loadBalancerName = {
    parameterPath: "loadBalancerName",
    mapper: {
        serializedName: "loadBalancerName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters25 = {
    parameterPath: "parameters",
    mapper: LoadBalancer
};
const parameters26 = {
    parameterPath: "parameters",
    mapper: LoadBalancerVipSwapRequest
};
const parameters27 = {
    parameterPath: "parameters",
    mapper: QueryInboundNatRulePortMappingRequest
};
const backendPoolName = {
    parameterPath: "backendPoolName",
    mapper: {
        serializedName: "backendPoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const backendAddressPoolName = {
    parameterPath: "backendAddressPoolName",
    mapper: {
        serializedName: "backendAddressPoolName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters28 = {
    parameterPath: "parameters",
    mapper: BackendAddressPool
};
const frontendIPConfigurationName = {
    parameterPath: "frontendIPConfigurationName",
    mapper: {
        serializedName: "frontendIPConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const inboundNatRuleName = {
    parameterPath: "inboundNatRuleName",
    mapper: {
        serializedName: "inboundNatRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const inboundNatRuleParameters = {
    parameterPath: "inboundNatRuleParameters",
    mapper: InboundNatRule
};
const loadBalancingRuleName = {
    parameterPath: "loadBalancingRuleName",
    mapper: {
        serializedName: "loadBalancingRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const outboundRuleName = {
    parameterPath: "outboundRuleName",
    mapper: {
        serializedName: "outboundRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const probeName = {
    parameterPath: "probeName",
    mapper: {
        serializedName: "probeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const natGatewayName = {
    parameterPath: "natGatewayName",
    mapper: {
        serializedName: "natGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters29 = {
    parameterPath: "parameters",
    mapper: NatGateway
};
const tapConfigurationName = {
    parameterPath: "tapConfigurationName",
    mapper: {
        serializedName: "tapConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const tapConfigurationParameters = {
    parameterPath: "tapConfigurationParameters",
    mapper: NetworkInterfaceTapConfiguration
};
const parameters30 = {
    parameterPath: "parameters",
    mapper: NetworkManager
};
const force = {
    parameterPath: ["options", "force"],
    mapper: {
        serializedName: "force",
        type: {
            name: "Boolean"
        }
    }
};
const parameters31 = {
    parameterPath: "parameters",
    mapper: PatchObject
};
const skipToken = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "$skipToken",
        type: {
            name: "String"
        }
    }
};
const parameters32 = {
    parameterPath: "parameters",
    mapper: NetworkManagerCommit
};
const parameters33 = {
    parameterPath: "parameters",
    mapper: NetworkManagerDeploymentStatusParameter
};
const parameters34 = {
    parameterPath: "parameters",
    mapper: NetworkManagerConnection
};
const networkManagerConnectionName = {
    parameterPath: "networkManagerConnectionName",
    mapper: {
        serializedName: "networkManagerConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const managementGroupId = {
    parameterPath: "managementGroupId",
    mapper: {
        serializedName: "managementGroupId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const configurationName = {
    parameterPath: "configurationName",
    mapper: {
        serializedName: "configurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const connectivityConfiguration = {
    parameterPath: "connectivityConfiguration",
    mapper: ConnectivityConfiguration
};
const networkGroupName = {
    parameterPath: "networkGroupName",
    mapper: {
        serializedName: "networkGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters35 = {
    parameterPath: "parameters",
    mapper: NetworkGroup
};
const ifMatch = {
    parameterPath: ["options", "ifMatch"],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const staticMemberName = {
    parameterPath: "staticMemberName",
    mapper: {
        serializedName: "staticMemberName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters36 = {
    parameterPath: "parameters",
    mapper: StaticMember
};
const parameters37 = {
    parameterPath: "parameters",
    mapper: ScopeConnection
};
const scopeConnectionName = {
    parameterPath: "scopeConnectionName",
    mapper: {
        serializedName: "scopeConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const securityAdminConfiguration = {
    parameterPath: "securityAdminConfiguration",
    mapper: SecurityAdminConfiguration
};
const ruleCollectionName = {
    parameterPath: "ruleCollectionName",
    mapper: {
        serializedName: "ruleCollectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ruleCollection = {
    parameterPath: "ruleCollection",
    mapper: AdminRuleCollection
};
const ruleName = {
    parameterPath: "ruleName",
    mapper: {
        serializedName: "ruleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const adminRule = {
    parameterPath: "adminRule",
    mapper: BaseAdminRule
};
const networkProfileName = {
    parameterPath: "networkProfileName",
    mapper: {
        serializedName: "networkProfileName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters38 = {
    parameterPath: "parameters",
    mapper: NetworkProfile
};
const networkSecurityGroupName = {
    parameterPath: "networkSecurityGroupName",
    mapper: {
        serializedName: "networkSecurityGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters39 = {
    parameterPath: "parameters",
    mapper: NetworkSecurityGroup
};
const securityRuleName = {
    parameterPath: "securityRuleName",
    mapper: {
        serializedName: "securityRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const securityRuleParameters = {
    parameterPath: "securityRuleParameters",
    mapper: SecurityRule
};
const defaultSecurityRuleName = {
    parameterPath: "defaultSecurityRuleName",
    mapper: {
        serializedName: "defaultSecurityRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const networkVirtualApplianceName = {
    parameterPath: "networkVirtualApplianceName",
    mapper: {
        serializedName: "networkVirtualApplianceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters40 = {
    parameterPath: "parameters",
    mapper: NetworkVirtualAppliance
};
const siteName = {
    parameterPath: "siteName",
    mapper: {
        serializedName: "siteName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters41 = {
    parameterPath: "parameters",
    mapper: VirtualApplianceSite
};
const skuName = {
    parameterPath: "skuName",
    mapper: {
        serializedName: "skuName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters42 = {
    parameterPath: "parameters",
    mapper: InboundSecurityRule
};
const parameters43 = {
    parameterPath: "parameters",
    mapper: NetworkWatcher
};
const networkWatcherName = {
    parameterPath: "networkWatcherName",
    mapper: {
        serializedName: "networkWatcherName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters44 = {
    parameterPath: "parameters",
    mapper: TopologyParameters
};
const parameters45 = {
    parameterPath: "parameters",
    mapper: VerificationIPFlowParameters
};
const parameters46 = {
    parameterPath: "parameters",
    mapper: NextHopParameters
};
const parameters47 = {
    parameterPath: "parameters",
    mapper: SecurityGroupViewParameters
};
const parameters48 = {
    parameterPath: "parameters",
    mapper: TroubleshootingParameters
};
const parameters49 = {
    parameterPath: "parameters",
    mapper: QueryTroubleshootingParameters
};
const parameters50 = {
    parameterPath: "parameters",
    mapper: FlowLogInformation
};
const parameters51 = {
    parameterPath: "parameters",
    mapper: FlowLogStatusParameters
};
const parameters52 = {
    parameterPath: "parameters",
    mapper: ConnectivityParameters
};
const parameters53 = {
    parameterPath: "parameters",
    mapper: AzureReachabilityReportParameters
};
const parameters54 = {
    parameterPath: "parameters",
    mapper: AvailableProvidersListParameters
};
const parameters55 = {
    parameterPath: "parameters",
    mapper: NetworkConfigurationDiagnosticParameters
};
const parameters56 = {
    parameterPath: "parameters",
    mapper: PacketCapture
};
const packetCaptureName = {
    parameterPath: "packetCaptureName",
    mapper: {
        serializedName: "packetCaptureName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters57 = {
    parameterPath: "parameters",
    mapper: ConnectionMonitor
};
const connectionMonitorName = {
    parameterPath: "connectionMonitorName",
    mapper: {
        serializedName: "connectionMonitorName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const migrate = {
    parameterPath: ["options", "migrate"],
    mapper: {
        serializedName: "migrate",
        type: {
            name: "String"
        }
    }
};
const parameters58 = {
    parameterPath: "parameters",
    mapper: FlowLog
};
const flowLogName = {
    parameterPath: "flowLogName",
    mapper: {
        serializedName: "flowLogName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const privateEndpointName = {
    parameterPath: "privateEndpointName",
    mapper: {
        serializedName: "privateEndpointName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters59 = {
    parameterPath: "parameters",
    mapper: PrivateEndpoint
};
const privateDnsZoneGroupName = {
    parameterPath: "privateDnsZoneGroupName",
    mapper: {
        serializedName: "privateDnsZoneGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters60 = {
    parameterPath: "parameters",
    mapper: PrivateDnsZoneGroup
};
const serviceName = {
    parameterPath: "serviceName",
    mapper: {
        serializedName: "serviceName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters61 = {
    parameterPath: "parameters",
    mapper: PrivateLinkService
};
const peConnectionName = {
    parameterPath: "peConnectionName",
    mapper: {
        serializedName: "peConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters62 = {
    parameterPath: "parameters",
    mapper: PrivateEndpointConnection
};
const parameters63 = {
    parameterPath: "parameters",
    mapper: CheckPrivateLinkServiceVisibilityRequest
};
const publicIpPrefixName = {
    parameterPath: "publicIpPrefixName",
    mapper: {
        serializedName: "publicIpPrefixName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters64 = {
    parameterPath: "parameters",
    mapper: PublicIPPrefix
};
const routeFilterName = {
    parameterPath: "routeFilterName",
    mapper: {
        serializedName: "routeFilterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const routeFilterParameters = {
    parameterPath: "routeFilterParameters",
    mapper: RouteFilter
};
const routeFilterRuleParameters = {
    parameterPath: "routeFilterRuleParameters",
    mapper: RouteFilterRule
};
const routeTableName = {
    parameterPath: "routeTableName",
    mapper: {
        serializedName: "routeTableName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters65 = {
    parameterPath: "parameters",
    mapper: RouteTable
};
const routeName = {
    parameterPath: "routeName",
    mapper: {
        serializedName: "routeName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const routeParameters = {
    parameterPath: "routeParameters",
    mapper: Route
};
const securityPartnerProviderName = {
    parameterPath: "securityPartnerProviderName",
    mapper: {
        serializedName: "securityPartnerProviderName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters66 = {
    parameterPath: "parameters",
    mapper: SecurityPartnerProvider
};
const serviceEndpointPolicyName = {
    parameterPath: "serviceEndpointPolicyName",
    mapper: {
        serializedName: "serviceEndpointPolicyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters67 = {
    parameterPath: "parameters",
    mapper: ServiceEndpointPolicy
};
const serviceEndpointPolicyDefinitionName = {
    parameterPath: "serviceEndpointPolicyDefinitionName",
    mapper: {
        serializedName: "serviceEndpointPolicyDefinitionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const serviceEndpointPolicyDefinitions = {
    parameterPath: "serviceEndpointPolicyDefinitions",
    mapper: ServiceEndpointPolicyDefinition
};
const noAddressPrefixes = {
    parameterPath: ["options", "noAddressPrefixes"],
    mapper: {
        serializedName: "noAddressPrefixes",
        type: {
            name: "Boolean"
        }
    }
};
const tagName = {
    parameterPath: ["options", "tagName"],
    mapper: {
        serializedName: "tagName",
        type: {
            name: "String"
        }
    }
};
const location1 = {
    parameterPath: "location",
    mapper: {
        constraints: {
            Pattern: new RegExp("^[-\\w\\._ ]+$")
        },
        serializedName: "location",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters68 = {
    parameterPath: "parameters",
    mapper: VirtualNetwork
};
const ipAddress = {
    parameterPath: "ipAddress",
    mapper: {
        serializedName: "ipAddress",
        required: true,
        type: {
            name: "String"
        }
    }
};
const top1 = {
    parameterPath: ["options", "top"],
    mapper: {
        serializedName: "top",
        type: {
            name: "Number"
        }
    }
};
const skipToken1 = {
    parameterPath: ["options", "skipToken"],
    mapper: {
        serializedName: "skipToken",
        type: {
            name: "String"
        }
    }
};
const subnetName = {
    parameterPath: "subnetName",
    mapper: {
        serializedName: "subnetName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const subnetParameters = {
    parameterPath: "subnetParameters",
    mapper: Subnet
};
const prepareNetworkPoliciesRequestParameters = {
    parameterPath: "prepareNetworkPoliciesRequestParameters",
    mapper: PrepareNetworkPoliciesRequest
};
const unprepareNetworkPoliciesRequestParameters = {
    parameterPath: "unprepareNetworkPoliciesRequestParameters",
    mapper: UnprepareNetworkPoliciesRequest
};
const virtualNetworkPeeringName = {
    parameterPath: "virtualNetworkPeeringName",
    mapper: {
        serializedName: "virtualNetworkPeeringName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualNetworkPeeringParameters = {
    parameterPath: "virtualNetworkPeeringParameters",
    mapper: VirtualNetworkPeering
};
const syncRemoteAddressSpace = {
    parameterPath: ["options", "syncRemoteAddressSpace"],
    mapper: {
        serializedName: "syncRemoteAddressSpace",
        type: {
            name: "String"
        }
    }
};
const parameters69 = {
    parameterPath: "parameters",
    mapper: VirtualNetworkGateway
};
const virtualNetworkGatewayName = {
    parameterPath: "virtualNetworkGatewayName",
    mapper: {
        serializedName: "virtualNetworkGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const gatewayVip = {
    parameterPath: ["options", "gatewayVip"],
    mapper: {
        serializedName: "gatewayVip",
        type: {
            name: "String"
        }
    }
};
const parameters70 = {
    parameterPath: "parameters",
    mapper: VpnClientParameters
};
const peer = {
    parameterPath: ["options", "peer"],
    mapper: {
        serializedName: "peer",
        type: {
            name: "String"
        }
    }
};
const peer1 = {
    parameterPath: "peer",
    mapper: {
        serializedName: "peer",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnclientIpsecParams = {
    parameterPath: "vpnclientIpsecParams",
    mapper: VpnClientIPsecParameters
};
const parameters71 = {
    parameterPath: "parameters",
    mapper: VpnDeviceScriptParameters
};
const virtualNetworkGatewayConnectionName = {
    parameterPath: "virtualNetworkGatewayConnectionName",
    mapper: {
        serializedName: "virtualNetworkGatewayConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters72 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnPacketCaptureStartParameters
};
const parameters73 = {
    parameterPath: "parameters",
    mapper: VpnPacketCaptureStopParameters
};
const request1 = {
    parameterPath: "request",
    mapper: P2SVpnConnectionRequest
};
const parameters74 = {
    parameterPath: "parameters",
    mapper: VirtualNetworkGatewayConnection
};
const parameters75 = {
    parameterPath: "parameters",
    mapper: ConnectionSharedKey
};
const parameters76 = {
    parameterPath: "parameters",
    mapper: ConnectionResetSharedKey
};
const parameters77 = {
    parameterPath: "parameters",
    mapper: LocalNetworkGateway
};
const localNetworkGatewayName = {
    parameterPath: "localNetworkGatewayName",
    mapper: {
        constraints: {
            MinLength: 1
        },
        serializedName: "localNetworkGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const natRuleName = {
    parameterPath: "natRuleName",
    mapper: {
        serializedName: "natRuleName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const natRuleParameters = {
    parameterPath: "natRuleParameters",
    mapper: VirtualNetworkGatewayNatRule
};
const tapName = {
    parameterPath: "tapName",
    mapper: {
        serializedName: "tapName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters78 = {
    parameterPath: "parameters",
    mapper: VirtualNetworkTap
};
const tapParameters = {
    parameterPath: "tapParameters",
    mapper: TagsObject
};
const virtualRouterName = {
    parameterPath: "virtualRouterName",
    mapper: {
        serializedName: "virtualRouterName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters79 = {
    parameterPath: "parameters",
    mapper: VirtualRouter
};
const parameters80 = {
    parameterPath: "parameters",
    mapper: VirtualRouterPeering
};
const virtualWANName1 = {
    parameterPath: "virtualWANName",
    mapper: {
        serializedName: "VirtualWANName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const wANParameters = {
    parameterPath: "wANParameters",
    mapper: VirtualWAN
};
const wANParameters1 = {
    parameterPath: "wANParameters",
    mapper: TagsObject
};
const vpnSiteName = {
    parameterPath: "vpnSiteName",
    mapper: {
        serializedName: "vpnSiteName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnSiteParameters = {
    parameterPath: "vpnSiteParameters",
    mapper: VpnSite
};
const vpnSiteParameters1 = {
    parameterPath: "vpnSiteParameters",
    mapper: TagsObject
};
const vpnSiteLinkName = {
    parameterPath: "vpnSiteLinkName",
    mapper: {
        serializedName: "vpnSiteLinkName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const request2 = {
    parameterPath: "request",
    mapper: GetVpnSitesConfigurationRequest
};
const vpnServerConfigurationName = {
    parameterPath: "vpnServerConfigurationName",
    mapper: {
        serializedName: "vpnServerConfigurationName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnServerConfigurationParameters = {
    parameterPath: "vpnServerConfigurationParameters",
    mapper: VpnServerConfiguration
};
const vpnServerConfigurationParameters1 = {
    parameterPath: "vpnServerConfigurationParameters",
    mapper: TagsObject
};
const vpnServerConfigurationPolicyGroupParameters = {
    parameterPath: "vpnServerConfigurationPolicyGroupParameters",
    mapper: VpnServerConfigurationPolicyGroup
};
const configurationPolicyGroupName = {
    parameterPath: "configurationPolicyGroupName",
    mapper: {
        serializedName: "configurationPolicyGroupName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualHubName = {
    parameterPath: "virtualHubName",
    mapper: {
        serializedName: "virtualHubName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualHubParameters = {
    parameterPath: "virtualHubParameters",
    mapper: VirtualHub
};
const virtualHubParameters1 = {
    parameterPath: "virtualHubParameters",
    mapper: TagsObject
};
const effectiveRoutesParameters = {
    parameterPath: ["options", "effectiveRoutesParameters"],
    mapper: EffectiveRoutesParameters
};
const getInboundRoutesParameters = {
    parameterPath: "getInboundRoutesParameters",
    mapper: GetInboundRoutesParameters
};
const getOutboundRoutesParameters = {
    parameterPath: "getOutboundRoutesParameters",
    mapper: GetOutboundRoutesParameters
};
const routeMapName = {
    parameterPath: "routeMapName",
    mapper: {
        serializedName: "routeMapName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const routeMapParameters = {
    parameterPath: "routeMapParameters",
    mapper: RouteMap
};
const hubVirtualNetworkConnectionParameters = {
    parameterPath: "hubVirtualNetworkConnectionParameters",
    mapper: HubVirtualNetworkConnection
};
const gatewayName = {
    parameterPath: "gatewayName",
    mapper: {
        serializedName: "gatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnGatewayParameters = {
    parameterPath: "vpnGatewayParameters",
    mapper: VpnGateway
};
const vpnGatewayParameters1 = {
    parameterPath: "vpnGatewayParameters",
    mapper: TagsObject
};
const ipConfigurationId = {
    parameterPath: ["options", "ipConfigurationId"],
    mapper: {
        serializedName: "ipConfigurationId",
        type: {
            name: "String"
        }
    }
};
const parameters81 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnGatewayPacketCaptureStartParameters
};
const parameters82 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnGatewayPacketCaptureStopParameters
};
const linkConnectionName = {
    parameterPath: "linkConnectionName",
    mapper: {
        serializedName: "linkConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const vpnConnectionParameters = {
    parameterPath: "vpnConnectionParameters",
    mapper: VpnConnection
};
const parameters83 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnConnectionPacketCaptureStartParameters
};
const vpnConnectionName = {
    parameterPath: "vpnConnectionName",
    mapper: {
        serializedName: "vpnConnectionName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters84 = {
    parameterPath: ["options", "parameters"],
    mapper: VpnConnectionPacketCaptureStopParameters
};
const natRuleParameters1 = {
    parameterPath: "natRuleParameters",
    mapper: VpnGatewayNatRule
};
const p2SVpnGatewayParameters = {
    parameterPath: "p2SVpnGatewayParameters",
    mapper: P2SVpnGateway
};
const p2SVpnGatewayParameters1 = {
    parameterPath: "p2SVpnGatewayParameters",
    mapper: TagsObject
};
const parameters85 = {
    parameterPath: "parameters",
    mapper: P2SVpnProfileParameters
};
const request3 = {
    parameterPath: "request",
    mapper: P2SVpnConnectionHealthRequest
};
const p2SVpnGatewayName = {
    parameterPath: "p2SVpnGatewayName",
    mapper: {
        serializedName: "p2sVpnGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const virtualHubRouteTableV2Parameters = {
    parameterPath: "virtualHubRouteTableV2Parameters",
    mapper: VirtualHubRouteTableV2
};
const putExpressRouteGatewayParameters = {
    parameterPath: "putExpressRouteGatewayParameters",
    mapper: ExpressRouteGateway
};
const expressRouteGatewayName = {
    parameterPath: "expressRouteGatewayName",
    mapper: {
        serializedName: "expressRouteGatewayName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const expressRouteGatewayParameters = {
    parameterPath: "expressRouteGatewayParameters",
    mapper: TagsObject
};
const putExpressRouteConnectionParameters = {
    parameterPath: "putExpressRouteConnectionParameters",
    mapper: ExpressRouteConnection
};
const parameters86 = {
    parameterPath: "parameters",
    mapper: BgpConnection
};
const hubName = {
    parameterPath: "hubName",
    mapper: {
        serializedName: "hubName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const ipConfigName = {
    parameterPath: "ipConfigName",
    mapper: {
        serializedName: "ipConfigName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters87 = {
    parameterPath: "parameters",
    mapper: HubIpConfiguration
};
const routeTableParameters = {
    parameterPath: "routeTableParameters",
    mapper: HubRouteTable
};
const routingIntentParameters = {
    parameterPath: "routingIntentParameters",
    mapper: RoutingIntent
};
const routingIntentName = {
    parameterPath: "routingIntentName",
    mapper: {
        serializedName: "routingIntentName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const policyName = {
    parameterPath: "policyName",
    mapper: {
        constraints: {
            MaxLength: 128
        },
        serializedName: "policyName",
        required: true,
        type: {
            name: "String"
        }
    }
};
const parameters88 = {
    parameterPath: "parameters",
    mapper: WebApplicationFirewallPolicy
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationGateways operations. */
class ApplicationGatewaysImpl {
    /**
     * Initialize a new instance of the class ApplicationGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all application gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the application gateways in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all SSL predefined policies for configuring Ssl policy.
     * @param options The options parameters.
     */
    listAvailableSslPredefinedPolicies(options) {
        const iter = this.listAvailableSslPredefinedPoliciesPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAvailableSslPredefinedPoliciesPagingPage(options, settings);
            }
        };
    }
    listAvailableSslPredefinedPoliciesPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableSslPredefinedPoliciesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAvailableSslPredefinedPolicies(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAvailableSslPredefinedPoliciesNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAvailableSslPredefinedPoliciesPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAvailableSslPredefinedPoliciesPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAvailableSslPredefinedPoliciesPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Deletes the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, applicationGatewayName, options },
                spec: deleteOperationSpec$1l
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, applicationGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, applicationGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, options }, getOperationSpec$1D);
    }
    /**
     * Creates or updates the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param parameters Parameters supplied to the create or update application gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, applicationGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, applicationGatewayName, parameters, options },
                spec: createOrUpdateOperationSpec$1l
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param parameters Parameters supplied to the create or update application gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, applicationGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, applicationGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the specified application gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param parameters Parameters supplied to update application gateway tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, applicationGatewayName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, parameters, options }, updateTagsOperationSpec$C);
    }
    /**
     * Lists all application gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1K);
    }
    /**
     * Gets all the application gateways in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$j);
    }
    /**
     * Starts the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, applicationGatewayName, options },
                spec: startOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts the specified application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, applicationGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops the specified application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, applicationGatewayName, options },
                spec: stopOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stops the specified application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, applicationGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the backend health of the specified application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginBackendHealth(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, applicationGatewayName, options },
                spec: backendHealthOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the backend health of the specified application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    beginBackendHealthAndWait(resourceGroupName, applicationGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBackendHealth(resourceGroupName, applicationGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the backend health for given combination of backend pool and http setting of the specified
     * application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param probeRequest Request body for on-demand test probe operation.
     * @param options The options parameters.
     */
    beginBackendHealthOnDemand(resourceGroupName, applicationGatewayName, probeRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    applicationGatewayName,
                    probeRequest,
                    options
                },
                spec: backendHealthOnDemandOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the backend health for given combination of backend pool and http setting of the specified
     * application gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param probeRequest Request body for on-demand test probe operation.
     * @param options The options parameters.
     */
    beginBackendHealthOnDemandAndWait(resourceGroupName, applicationGatewayName, probeRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginBackendHealthOnDemand(resourceGroupName, applicationGatewayName, probeRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all available server variables.
     * @param options The options parameters.
     */
    listAvailableServerVariables(options) {
        return this.client.sendOperationRequest({ options }, listAvailableServerVariablesOperationSpec);
    }
    /**
     * Lists all available request headers.
     * @param options The options parameters.
     */
    listAvailableRequestHeaders(options) {
        return this.client.sendOperationRequest({ options }, listAvailableRequestHeadersOperationSpec);
    }
    /**
     * Lists all available response headers.
     * @param options The options parameters.
     */
    listAvailableResponseHeaders(options) {
        return this.client.sendOperationRequest({ options }, listAvailableResponseHeadersOperationSpec);
    }
    /**
     * Lists all available web application firewall rule sets.
     * @param options The options parameters.
     */
    listAvailableWafRuleSets(options) {
        return this.client.sendOperationRequest({ options }, listAvailableWafRuleSetsOperationSpec);
    }
    /**
     * Lists available Ssl options for configuring Ssl policy.
     * @param options The options parameters.
     */
    listAvailableSslOptions(options) {
        return this.client.sendOperationRequest({ options }, listAvailableSslOptionsOperationSpec);
    }
    /**
     * Lists all SSL predefined policies for configuring Ssl policy.
     * @param options The options parameters.
     */
    _listAvailableSslPredefinedPolicies(options) {
        return this.client.sendOperationRequest({ options }, listAvailableSslPredefinedPoliciesOperationSpec);
    }
    /**
     * Gets Ssl predefined policy with the specified policy name.
     * @param predefinedPolicyName Name of Ssl predefined policy.
     * @param options The options parameters.
     */
    getSslPredefinedPolicy(predefinedPolicyName, options) {
        return this.client.sendOperationRequest({ predefinedPolicyName, options }, getSslPredefinedPolicyOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1w);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$i);
    }
    /**
     * ListAvailableSslPredefinedPoliciesNext
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListAvailableSslPredefinedPolicies method.
     * @param options The options parameters.
     */
    _listAvailableSslPredefinedPoliciesNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAvailableSslPredefinedPoliciesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$23 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$23
};
const getOperationSpec$1D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$23
};
const createOrUpdateOperationSpec$1l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationGateway
        },
        201: {
            bodyMapper: ApplicationGateway
        },
        202: {
            bodyMapper: ApplicationGateway
        },
        204: {
            bodyMapper: ApplicationGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$23
};
const updateTagsOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ApplicationGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$23
};
const listOperationSpec$1K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$23
};
const listAllOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$23
};
const startOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$23
};
const stopOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$23
};
const backendHealthOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/backendhealth",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayBackendHealth
        },
        201: {
            bodyMapper: ApplicationGatewayBackendHealth
        },
        202: {
            bodyMapper: ApplicationGatewayBackendHealth
        },
        204: {
            bodyMapper: ApplicationGatewayBackendHealth
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$23
};
const backendHealthOnDemandOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/getBackendHealthOnDemand",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayBackendHealthOnDemand
        },
        201: {
            bodyMapper: ApplicationGatewayBackendHealthOnDemand
        },
        202: {
            bodyMapper: ApplicationGatewayBackendHealthOnDemand
        },
        204: {
            bodyMapper: ApplicationGatewayBackendHealthOnDemand
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: probeRequest,
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$23
};
const listAvailableServerVariablesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableServerVariables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Sequence", element: { type: { name: "String" } } }
            }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$23
};
const listAvailableRequestHeadersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableRequestHeaders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Sequence", element: { type: { name: "String" } } }
            }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$23
};
const listAvailableResponseHeadersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableResponseHeaders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Sequence", element: { type: { name: "String" } } }
            }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$23
};
const listAvailableWafRuleSetsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableWafRuleSets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayAvailableWafRuleSetsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$23
};
const listAvailableSslOptionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableSslOptions/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayAvailableSslOptions
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$23
};
const listAvailableSslPredefinedPoliciesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableSslOptions/default/predefinedPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayAvailableSslPredefinedPolicies
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$23
};
const getSslPredefinedPolicyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationGatewayAvailableSslOptions/default/predefinedPolicies/{predefinedPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewaySslPredefinedPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        predefinedPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$23
};
const listNextOperationSpec$1w = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$23
};
const listAllNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$23
};
const listAvailableSslPredefinedPoliciesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayAvailableSslPredefinedPolicies
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$23
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationGatewayPrivateLinkResources operations. */
class ApplicationGatewayPrivateLinkResourcesImpl {
    /**
     * Initialize a new instance of the class ApplicationGatewayPrivateLinkResources class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all private link resources on an application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    list(resourceGroupName, applicationGatewayName, options) {
        const iter = this.listPagingAll(resourceGroupName, applicationGatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, applicationGatewayName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, applicationGatewayName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, applicationGatewayName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, applicationGatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, applicationGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, applicationGatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all private link resources on an application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    _list(resourceGroupName, applicationGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, options }, listOperationSpec$1J);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, applicationGatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, nextLink, options }, listNextOperationSpec$1v);
    }
}
// Operation Specifications
const serializer$22 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateLinkResources",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$22
};
const listNextOperationSpec$1v = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateLinkResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$22
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationGatewayPrivateEndpointConnections operations. */
class ApplicationGatewayPrivateEndpointConnectionsImpl {
    /**
     * Initialize a new instance of the class ApplicationGatewayPrivateEndpointConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all private endpoint connections on an application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    list(resourceGroupName, applicationGatewayName, options) {
        const iter = this.listPagingAll(resourceGroupName, applicationGatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, applicationGatewayName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, applicationGatewayName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, applicationGatewayName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, applicationGatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, applicationGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, applicationGatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, applicationGatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    applicationGatewayName,
                    connectionName,
                    options
                },
                spec: deleteOperationSpec$1k
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, applicationGatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, applicationGatewayName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param parameters Parameters supplied to update application gateway private endpoint connection
     *                   operation.
     * @param options The options parameters.
     */
    beginUpdate(resourceGroupName, applicationGatewayName, connectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    applicationGatewayName,
                    connectionName,
                    parameters,
                    options
                },
                spec: updateOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param parameters Parameters supplied to update application gateway private endpoint connection
     *                   operation.
     * @param options The options parameters.
     */
    beginUpdateAndWait(resourceGroupName, applicationGatewayName, connectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdate(resourceGroupName, applicationGatewayName, connectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified private endpoint connection on application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param connectionName The name of the application gateway private endpoint connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, applicationGatewayName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, connectionName, options }, getOperationSpec$1C);
    }
    /**
     * Lists all private endpoint connections on an application gateway.
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param options The options parameters.
     */
    _list(resourceGroupName, applicationGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, options }, listOperationSpec$1I);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param applicationGatewayName The name of the application gateway.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, applicationGatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationGatewayName, nextLink, options }, listNextOperationSpec$1u);
    }
}
// Operation Specifications
const serializer$21 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateEndpointConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        connectionName
    ],
    headerParameters: [accept],
    serializer: serializer$21
};
const updateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateEndpointConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        201: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        202: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        204: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        connectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$21
};
const getOperationSpec$1C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateEndpointConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        connectionName
    ],
    headerParameters: [accept],
    serializer: serializer$21
};
const listOperationSpec$1I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationGateways/{applicationGatewayName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$21
};
const listNextOperationSpec$1u = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayPrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        applicationGatewayName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$21
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ApplicationGatewayWafDynamicManifestsDefault operations. */
class ApplicationGatewayWafDynamicManifestsDefaultImpl {
    /**
     * Initialize a new instance of the class ApplicationGatewayWafDynamicManifestsDefault class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the regional application gateway waf manifest.
     * @param location The region where the nrp are located at.
     * @param options The options parameters.
     */
    get(location, options) {
        return this.client.sendOperationRequest({ location, options }, getOperationSpec$1B);
    }
}
// Operation Specifications
const serializer$20 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1B = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/applicationGatewayWafDynamicManifests/dafault",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayWafDynamicManifestResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$20
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationGatewayWafDynamicManifests operations. */
class ApplicationGatewayWafDynamicManifestsImpl {
    /**
     * Initialize a new instance of the class ApplicationGatewayWafDynamicManifests class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the regional application gateway waf manifest.
     * @param location The region where the nrp are located at.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.getPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getPagingPage(location, options, settings);
            }
        };
    }
    getPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._get(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* getPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the regional application gateway waf manifest.
     * @param location The region where the nrp are located at.
     * @param options The options parameters.
     */
    _get(location, options) {
        return this.client.sendOperationRequest({ location, options }, getOperationSpec$1A);
    }
    /**
     * GetNext
     * @param location The region where the nrp are located at.
     * @param nextLink The nextLink from the previous successful call to the Get method.
     * @param options The options parameters.
     */
    _getNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, getNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1$ = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1A = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/applicationGatewayWafDynamicManifests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayWafDynamicManifestResultList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1$
};
const getNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationGatewayWafDynamicManifestResultList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1$
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ApplicationSecurityGroups operations. */
class ApplicationSecurityGroupsImpl {
    /**
     * Initialize a new instance of the class ApplicationSecurityGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all application security groups in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the application security groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, applicationSecurityGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, applicationSecurityGroupName, options },
                spec: deleteOperationSpec$1j
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, applicationSecurityGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, applicationSecurityGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param options The options parameters.
     */
    get(resourceGroupName, applicationSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationSecurityGroupName, options }, getOperationSpec$1z);
    }
    /**
     * Creates or updates an application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param parameters Parameters supplied to the create or update ApplicationSecurityGroup operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, applicationSecurityGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    applicationSecurityGroupName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$1k
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an application security group.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param parameters Parameters supplied to the create or update ApplicationSecurityGroup operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, applicationSecurityGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, applicationSecurityGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an application security group's tags.
     * @param resourceGroupName The name of the resource group.
     * @param applicationSecurityGroupName The name of the application security group.
     * @param parameters Parameters supplied to update application security group tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, applicationSecurityGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, applicationSecurityGroupName, parameters, options }, updateTagsOperationSpec$B);
    }
    /**
     * Gets all application security groups in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$i);
    }
    /**
     * Gets all the application security groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1H);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$h);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1t);
    }
}
// Operation Specifications
const serializer$1_ = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups/{applicationSecurityGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        applicationSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1_
};
const getOperationSpec$1z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups/{applicationSecurityGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        applicationSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1_
};
const createOrUpdateOperationSpec$1k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups/{applicationSecurityGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroup
        },
        201: {
            bodyMapper: ApplicationSecurityGroup
        },
        202: {
            bodyMapper: ApplicationSecurityGroup
        },
        204: {
            bodyMapper: ApplicationSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        applicationSecurityGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1_
};
const updateTagsOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups/{applicationSecurityGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        applicationSecurityGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1_
};
const listAllOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/applicationSecurityGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1_
};
const listOperationSpec$1H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/applicationSecurityGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1_
};
const listAllNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1_
};
const listNextOperationSpec$1t = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ApplicationSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1_
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableDelegations operations. */
class AvailableDelegationsImpl {
    /**
     * Initialize a new instance of the class AvailableDelegations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all of the available subnet delegations for this subscription in this region.
     * @param location The location of the subnet.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all of the available subnet delegations for this subscription in this region.
     * @param location The location of the subnet.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$1G);
    }
    /**
     * ListNext
     * @param location The location of the subnet.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$1s);
    }
}
// Operation Specifications
const serializer$1Z = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1G = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/availableDelegations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableDelegationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1Z
};
const listNextOperationSpec$1s = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableDelegationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1Z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableResourceGroupDelegations operations. */
class AvailableResourceGroupDelegationsImpl {
    /**
     * Initialize a new instance of the class AvailableResourceGroupDelegations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all of the available subnet delegations for this resource group in this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(location, resourceGroupName, options) {
        const iter = this.listPagingAll(location, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(location, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all of the available subnet delegations for this resource group in this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(location, resourceGroupName, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, options }, listOperationSpec$1F);
    }
    /**
     * ListNext
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, nextLink, options }, listNextOperationSpec$1r);
    }
}
// Operation Specifications
const serializer$1Y = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/availableDelegations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableDelegationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1Y
};
const listNextOperationSpec$1r = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableDelegationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1Y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableServiceAliases operations. */
class AvailableServiceAliasesImpl {
    /**
     * Initialize a new instance of the class AvailableServiceAliases class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all available service aliases for this subscription in this region.
     * @param location The location.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all available service aliases for this resource group in this region.
     * @param resourceGroupName The name of the resource group.
     * @param location The location.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, location, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, location, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all available service aliases for this subscription in this region.
     * @param location The location.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$1E);
    }
    /**
     * Gets all available service aliases for this resource group in this region.
     * @param resourceGroupName The name of the resource group.
     * @param location The location.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, location, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, options }, listByResourceGroupOperationSpec$l);
    }
    /**
     * ListNext
     * @param location The location.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$1q);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param location The location.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, location, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, location, nextLink, options }, listByResourceGroupNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$1X = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1E = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/availableServiceAliases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableServiceAliasesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1X
};
const listByResourceGroupOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/availableServiceAliases",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableServiceAliasesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1X
};
const listNextOperationSpec$1q = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableServiceAliasesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1X
};
const listByResourceGroupNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailableServiceAliasesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1X
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AzureFirewalls operations. */
class AzureFirewallsImpl {
    /**
     * Initialize a new instance of the class AzureFirewalls class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Azure Firewalls in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Azure Firewalls in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, azureFirewallName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, azureFirewallName, options },
                spec: deleteOperationSpec$1i
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, azureFirewallName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, azureFirewallName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param options The options parameters.
     */
    get(resourceGroupName, azureFirewallName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, azureFirewallName, options }, getOperationSpec$1y);
    }
    /**
     * Creates or updates the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param parameters Parameters supplied to the create or update Azure Firewall operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, azureFirewallName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, azureFirewallName, parameters, options },
                spec: createOrUpdateOperationSpec$1j
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified Azure Firewall.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param parameters Parameters supplied to the create or update Azure Firewall operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, azureFirewallName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, azureFirewallName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of an Azure Firewall resource.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param parameters Parameters supplied to update azure firewall tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, azureFirewallName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, azureFirewallName, parameters, options },
                spec: updateTagsOperationSpec$A
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates tags of an Azure Firewall resource.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the Azure Firewall.
     * @param parameters Parameters supplied to update azure firewall tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, azureFirewallName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, azureFirewallName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Azure Firewalls in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1D);
    }
    /**
     * Gets all the Azure Firewalls in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$h);
    }
    /**
     * Retrieves a list of all IP prefixes that azure firewall has learned to not SNAT.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the azure firewall.
     * @param options The options parameters.
     */
    beginListLearnedPrefixes(resourceGroupName, azureFirewallName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, azureFirewallName, options },
                spec: listLearnedPrefixesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves a list of all IP prefixes that azure firewall has learned to not SNAT.
     * @param resourceGroupName The name of the resource group.
     * @param azureFirewallName The name of the azure firewall.
     * @param options The options parameters.
     */
    beginListLearnedPrefixesAndWait(resourceGroupName, azureFirewallName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListLearnedPrefixes(resourceGroupName, azureFirewallName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1p);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$1W = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        azureFirewallName
    ],
    headerParameters: [accept],
    serializer: serializer$1W
};
const getOperationSpec$1y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewall
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        azureFirewallName
    ],
    headerParameters: [accept],
    serializer: serializer$1W
};
const createOrUpdateOperationSpec$1j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AzureFirewall
        },
        201: {
            bodyMapper: AzureFirewall
        },
        202: {
            bodyMapper: AzureFirewall
        },
        204: {
            bodyMapper: AzureFirewall
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters4,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        azureFirewallName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1W
};
const updateTagsOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: AzureFirewall
        },
        201: {
            bodyMapper: AzureFirewall
        },
        202: {
            bodyMapper: AzureFirewall
        },
        204: {
            bodyMapper: AzureFirewall
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        azureFirewallName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1W
};
const listOperationSpec$1D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1W
};
const listAllOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/azureFirewalls",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1W
};
const listLearnedPrefixesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/azureFirewalls/{azureFirewallName}/learnedIPPrefixes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: IPPrefixesList
        },
        201: {
            bodyMapper: IPPrefixesList
        },
        202: {
            bodyMapper: IPPrefixesList
        },
        204: {
            bodyMapper: IPPrefixesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        azureFirewallName
    ],
    headerParameters: [accept],
    serializer: serializer$1W
};
const listNextOperationSpec$1p = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1W
};
const listAllNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1W
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AzureFirewallFqdnTags operations. */
class AzureFirewallFqdnTagsImpl {
    /**
     * Initialize a new instance of the class AzureFirewallFqdnTags class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the Azure Firewall FQDN Tags in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Azure Firewall FQDN Tags in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$g);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$1V = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listAllOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/azureFirewallFqdnTags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallFqdnTagListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1V
};
const listAllNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureFirewallFqdnTagListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1V
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WebCategories operations. */
class WebCategoriesImpl {
    /**
     * Initialize a new instance of the class WebCategories class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the Azure Web Categories in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the specified Azure Web Category.
     * @param name The name of the azureWebCategory.
     * @param options The options parameters.
     */
    get(name, options) {
        return this.client.sendOperationRequest({ name, options }, getOperationSpec$1x);
    }
    /**
     * Gets all the Azure Web Categories in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$4);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$1U = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1x = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/azureWebCategories/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureWebCategory
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [$host, subscriptionId, name],
    headerParameters: [accept],
    serializer: serializer$1U
};
const listBySubscriptionOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/azureWebCategories",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureWebCategoryListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1U
};
const listBySubscriptionNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AzureWebCategoryListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1U
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BastionHosts operations. */
class BastionHostsImpl {
    /**
     * Initialize a new instance of the class BastionHosts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Bastion Hosts in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all Bastion Hosts in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, bastionHostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, bastionHostName, options },
                spec: deleteOperationSpec$1h
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, bastionHostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, bastionHostName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    get(resourceGroupName, bastionHostName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, bastionHostName, options }, getOperationSpec$1w);
    }
    /**
     * Creates or updates the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param parameters Parameters supplied to the create or update Bastion Host operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, bastionHostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, bastionHostName, parameters, options },
                spec: createOrUpdateOperationSpec$1i
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified Bastion Host.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param parameters Parameters supplied to the create or update Bastion Host operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, bastionHostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, bastionHostName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates Tags for BastionHost resource
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param parameters Parameters supplied to update BastionHost tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, bastionHostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, bastionHostName, parameters, options },
                spec: updateTagsOperationSpec$z
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates Tags for BastionHost resource
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param parameters Parameters supplied to update BastionHost tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, bastionHostName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, bastionHostName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Bastion Hosts in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1C);
    }
    /**
     * Lists all Bastion Hosts in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$k);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1o);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$j);
    }
}
// Operation Specifications
const serializer$1T = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept],
    serializer: serializer$1T
};
const getOperationSpec$1w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept],
    serializer: serializer$1T
};
const createOrUpdateOperationSpec$1i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BastionHost
        },
        201: {
            bodyMapper: BastionHost
        },
        202: {
            bodyMapper: BastionHost
        },
        204: {
            bodyMapper: BastionHost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters5,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1T
};
const updateTagsOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: BastionHost
        },
        201: {
            bodyMapper: BastionHost
        },
        202: {
            bodyMapper: BastionHost
        },
        204: {
            bodyMapper: BastionHost
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1T
};
const listOperationSpec$1C = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/bastionHosts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1T
};
const listByResourceGroupOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1T
};
const listNextOperationSpec$1o = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1T
};
const listByResourceGroupNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionHostListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1T
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkInterfaces operations. */
class NetworkInterfacesImpl {
    /**
     * Initialize a new instance of the class NetworkInterfaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets information about all network interfaces in a role instance in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param options The options parameters.
     */
    listCloudServiceRoleInstanceNetworkInterfaces(resourceGroupName, cloudServiceName, roleInstanceName, options) {
        const iter = this.listCloudServiceRoleInstanceNetworkInterfacesPagingAll(resourceGroupName, cloudServiceName, roleInstanceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCloudServiceRoleInstanceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, options, settings);
            }
        };
    }
    listCloudServiceRoleInstanceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceRoleInstanceNetworkInterfacesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listCloudServiceRoleInstanceNetworkInterfaces(resourceGroupName, cloudServiceName, roleInstanceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listCloudServiceRoleInstanceNetworkInterfacesNext(resourceGroupName, cloudServiceName, roleInstanceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listCloudServiceRoleInstanceNetworkInterfacesPagingAll(resourceGroupName, cloudServiceName, roleInstanceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceRoleInstanceNetworkInterfacesPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCloudServiceRoleInstanceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all network interfaces in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param options The options parameters.
     */
    listCloudServiceNetworkInterfaces(resourceGroupName, cloudServiceName, options) {
        const iter = this.listCloudServiceNetworkInterfacesPagingAll(resourceGroupName, cloudServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCloudServiceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, options, settings);
            }
        };
    }
    listCloudServiceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceNetworkInterfacesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listCloudServiceNetworkInterfaces(resourceGroupName, cloudServiceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listCloudServiceNetworkInterfacesNext(resourceGroupName, cloudServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listCloudServiceNetworkInterfacesPagingAll(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceNetworkInterfacesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCloudServiceNetworkInterfacesPagingPage(resourceGroupName, cloudServiceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all network interfaces in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets all network interfaces in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets information about all network interfaces in a virtual machine in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetVMNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options) {
        const iter = this.listVirtualMachineScaleSetVMNetworkInterfacesPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVirtualMachineScaleSetVMNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options, settings);
            }
        };
    }
    listVirtualMachineScaleSetVMNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetVMNetworkInterfacesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetVMNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetVMNetworkInterfacesNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVirtualMachineScaleSetVMNetworkInterfacesPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetVMNetworkInterfacesPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetVMNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Gets all network interfaces in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, options) {
        const iter = this.listVirtualMachineScaleSetNetworkInterfacesPagingAll(resourceGroupName, virtualMachineScaleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVirtualMachineScaleSetNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, options, settings);
            }
        };
    }
    listVirtualMachineScaleSetNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetNetworkInterfacesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetNetworkInterfacesNext(resourceGroupName, virtualMachineScaleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVirtualMachineScaleSetNetworkInterfacesPagingAll(resourceGroupName, virtualMachineScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetNetworkInterfacesPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetNetworkInterfacesPagingPage(resourceGroupName, virtualMachineScaleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Get the specified network interface ip configuration in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetIpConfigurations(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options) {
        const iter = this.listVirtualMachineScaleSetIpConfigurationsPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVirtualMachineScaleSetIpConfigurationsPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options, settings);
            }
        };
    }
    listVirtualMachineScaleSetIpConfigurationsPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetIpConfigurationsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetIpConfigurations(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetIpConfigurationsNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVirtualMachineScaleSetIpConfigurationsPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetIpConfigurationsPagingAll_1() {
            var e_7, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetIpConfigurationsPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
    /**
     * Gets information about all network interfaces in a role instance in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param options The options parameters.
     */
    _listCloudServiceRoleInstanceNetworkInterfaces(resourceGroupName, cloudServiceName, roleInstanceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, roleInstanceName, options }, listCloudServiceRoleInstanceNetworkInterfacesOperationSpec);
    }
    /**
     * Gets all network interfaces in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param options The options parameters.
     */
    _listCloudServiceNetworkInterfaces(resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, options }, listCloudServiceNetworkInterfacesOperationSpec);
    }
    /**
     * Get the specified network interface in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    getCloudServiceNetworkInterface(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            networkInterfaceName,
            options
        }, getCloudServiceNetworkInterfaceOperationSpec);
    }
    /**
     * Deletes the specified network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkInterfaceName, options },
                spec: deleteOperationSpec$1g
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkInterfaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, options }, getOperationSpec$1v);
    }
    /**
     * Creates or updates a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param parameters Parameters supplied to the create or update network interface operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkInterfaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkInterfaceName, parameters, options },
                spec: createOrUpdateOperationSpec$1h
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param parameters Parameters supplied to the create or update network interface operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkInterfaceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkInterfaceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a network interface tags.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param parameters Parameters supplied to update network interface tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkInterfaceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, parameters, options }, updateTagsOperationSpec$y);
    }
    /**
     * Gets all network interfaces in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$f);
    }
    /**
     * Gets all network interfaces in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1B);
    }
    /**
     * Gets all route tables applied to a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginGetEffectiveRouteTable(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkInterfaceName, options },
                spec: getEffectiveRouteTableOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets all route tables applied to a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginGetEffectiveRouteTableAndWait(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetEffectiveRouteTable(resourceGroupName, networkInterfaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all network security groups applied to a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginListEffectiveNetworkSecurityGroups(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkInterfaceName, options },
                spec: listEffectiveNetworkSecurityGroupsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets all network security groups applied to a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    beginListEffectiveNetworkSecurityGroupsAndWait(resourceGroupName, networkInterfaceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListEffectiveNetworkSecurityGroups(resourceGroupName, networkInterfaceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about all network interfaces in a virtual machine in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetVMNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            options
        }, listVirtualMachineScaleSetVMNetworkInterfacesOperationSpec);
    }
    /**
     * Gets all network interfaces in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetNetworkInterfaces(resourceGroupName, virtualMachineScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, options }, listVirtualMachineScaleSetNetworkInterfacesOperationSpec);
    }
    /**
     * Get the specified network interface in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    getVirtualMachineScaleSetNetworkInterface(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            options
        }, getVirtualMachineScaleSetNetworkInterfaceOperationSpec);
    }
    /**
     * Get the specified network interface ip configuration in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetIpConfigurations(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            options
        }, listVirtualMachineScaleSetIpConfigurationsOperationSpec);
    }
    /**
     * Get the specified network interface ip configuration in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param ipConfigurationName The name of the ip configuration.
     * @param options The options parameters.
     */
    getVirtualMachineScaleSetIpConfiguration(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            ipConfigurationName,
            options
        }, getVirtualMachineScaleSetIpConfigurationOperationSpec);
    }
    /**
     * ListCloudServiceRoleInstanceNetworkInterfacesNext
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListCloudServiceRoleInstanceNetworkInterfaces method.
     * @param options The options parameters.
     */
    _listCloudServiceRoleInstanceNetworkInterfacesNext(resourceGroupName, cloudServiceName, roleInstanceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            nextLink,
            options
        }, listCloudServiceRoleInstanceNetworkInterfacesNextOperationSpec);
    }
    /**
     * ListCloudServiceNetworkInterfacesNext
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListCloudServiceNetworkInterfaces method.
     * @param options The options parameters.
     */
    _listCloudServiceNetworkInterfacesNext(resourceGroupName, cloudServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, nextLink, options }, listCloudServiceNetworkInterfacesNextOperationSpec);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$e);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1n);
    }
    /**
     * ListVirtualMachineScaleSetVMNetworkInterfacesNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetVMNetworkInterfaces method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetVMNetworkInterfacesNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            nextLink,
            options
        }, listVirtualMachineScaleSetVMNetworkInterfacesNextOperationSpec);
    }
    /**
     * ListVirtualMachineScaleSetNetworkInterfacesNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetNetworkInterfaces method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetNetworkInterfacesNext(resourceGroupName, virtualMachineScaleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, nextLink, options }, listVirtualMachineScaleSetNetworkInterfacesNextOperationSpec);
    }
    /**
     * ListVirtualMachineScaleSetIpConfigurationsNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetIpConfigurations method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetIpConfigurationsNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            nextLink,
            options
        }, listVirtualMachineScaleSetIpConfigurationsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1S = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listCloudServiceRoleInstanceNetworkInterfacesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName,
        roleInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listCloudServiceNetworkInterfacesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const getCloudServiceNetworkInterfaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/networkInterfaces/{networkInterfaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName,
        roleInstanceName,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const deleteOperationSpec$1g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const getOperationSpec$1v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const createOrUpdateOperationSpec$1h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        201: {
            bodyMapper: NetworkInterface
        },
        202: {
            bodyMapper: NetworkInterface
        },
        204: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters8,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1S
};
const updateTagsOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1S
};
const listAllOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listOperationSpec$1B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const getEffectiveRouteTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/effectiveRouteTable",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EffectiveRouteListResult
        },
        201: {
            bodyMapper: EffectiveRouteListResult
        },
        202: {
            bodyMapper: EffectiveRouteListResult
        },
        204: {
            bodyMapper: EffectiveRouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listEffectiveNetworkSecurityGroupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/effectiveNetworkSecurityGroups",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: EffectiveNetworkSecurityGroupListResult
        },
        201: {
            bodyMapper: EffectiveNetworkSecurityGroupListResult
        },
        202: {
            bodyMapper: EffectiveNetworkSecurityGroupListResult
        },
        204: {
            bodyMapper: EffectiveNetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listVirtualMachineScaleSetVMNetworkInterfacesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listVirtualMachineScaleSetNetworkInterfacesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const getVirtualMachineScaleSetNetworkInterfaceOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterface
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand, apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listVirtualMachineScaleSetIpConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}/ipConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand, apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const getVirtualMachineScaleSetIpConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}/ipConfigurations/{ipConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand, apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listCloudServiceRoleInstanceNetworkInterfacesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        cloudServiceName,
        roleInstanceName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listCloudServiceNetworkInterfacesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listAllNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listNextOperationSpec$1n = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listVirtualMachineScaleSetVMNetworkInterfacesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listVirtualMachineScaleSetNetworkInterfacesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};
const listVirtualMachineScaleSetIpConfigurationsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex
    ],
    headerParameters: [accept],
    serializer: serializer$1S
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PublicIPAddresses operations. */
class PublicIPAddressesImpl {
    /**
     * Initialize a new instance of the class PublicIPAddresses class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets information about all public IP addresses on a cloud service level.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param options The options parameters.
     */
    listCloudServicePublicIPAddresses(resourceGroupName, cloudServiceName, options) {
        const iter = this.listCloudServicePublicIPAddressesPagingAll(resourceGroupName, cloudServiceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCloudServicePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, options, settings);
            }
        };
    }
    listCloudServicePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServicePublicIPAddressesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listCloudServicePublicIPAddresses(resourceGroupName, cloudServiceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listCloudServicePublicIPAddressesNext(resourceGroupName, cloudServiceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listCloudServicePublicIPAddressesPagingAll(resourceGroupName, cloudServiceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServicePublicIPAddressesPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCloudServicePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets information about all public IP addresses in a role instance IP configuration in a cloud
     * service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param options The options parameters.
     */
    listCloudServiceRoleInstancePublicIPAddresses(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options) {
        const iter = this.listCloudServiceRoleInstancePublicIPAddressesPagingAll(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listCloudServiceRoleInstancePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options, settings);
            }
        };
    }
    listCloudServiceRoleInstancePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceRoleInstancePublicIPAddressesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listCloudServiceRoleInstancePublicIPAddresses(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listCloudServiceRoleInstancePublicIPAddressesNext(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listCloudServiceRoleInstancePublicIPAddressesPagingAll(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listCloudServiceRoleInstancePublicIPAddressesPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listCloudServiceRoleInstancePublicIPAddressesPagingPage(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all the public IP addresses in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets all public IP addresses in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Gets information about all public IP addresses on a virtual machine scale set level.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, options) {
        const iter = this.listVirtualMachineScaleSetPublicIPAddressesPagingAll(resourceGroupName, virtualMachineScaleSetName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVirtualMachineScaleSetPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, options, settings);
            }
        };
    }
    listVirtualMachineScaleSetPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetPublicIPAddressesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetPublicIPAddressesNext(resourceGroupName, virtualMachineScaleSetName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVirtualMachineScaleSetPublicIPAddressesPagingAll(resourceGroupName, virtualMachineScaleSetName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetPublicIPAddressesPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Gets information about all public IP addresses in a virtual machine IP configuration in a virtual
     * machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param options The options parameters.
     */
    listVirtualMachineScaleSetVMPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options) {
        const iter = this.listVirtualMachineScaleSetVMPublicIPAddressesPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listVirtualMachineScaleSetVMPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options, settings);
            }
        };
    }
    listVirtualMachineScaleSetVMPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetVMPublicIPAddressesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetVMPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listVirtualMachineScaleSetVMPublicIPAddressesNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listVirtualMachineScaleSetVMPublicIPAddressesPagingAll(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listVirtualMachineScaleSetVMPublicIPAddressesPagingAll_1() {
            var e_6, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listVirtualMachineScaleSetVMPublicIPAddressesPagingPage(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_6) throw e_6.error; }
            }
        });
    }
    /**
     * Gets information about all public IP addresses on a cloud service level.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param options The options parameters.
     */
    _listCloudServicePublicIPAddresses(resourceGroupName, cloudServiceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, options }, listCloudServicePublicIPAddressesOperationSpec);
    }
    /**
     * Gets information about all public IP addresses in a role instance IP configuration in a cloud
     * service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param options The options parameters.
     */
    _listCloudServiceRoleInstancePublicIPAddresses(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            networkInterfaceName,
            ipConfigurationName,
            options
        }, listCloudServiceRoleInstancePublicIPAddressesOperationSpec);
    }
    /**
     * Get the specified public IP address in a cloud service.
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The role instance name.
     * @param networkInterfaceName The name of the network interface.
     * @param ipConfigurationName The name of the IP configuration.
     * @param publicIpAddressName The name of the public IP Address.
     * @param options The options parameters.
     */
    getCloudServicePublicIPAddress(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, publicIpAddressName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            networkInterfaceName,
            ipConfigurationName,
            publicIpAddressName,
            options
        }, getCloudServicePublicIPAddressOperationSpec);
    }
    /**
     * Deletes the specified public IP address.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, publicIpAddressName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, publicIpAddressName, options },
                spec: deleteOperationSpec$1f
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified public IP address.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, publicIpAddressName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, publicIpAddressName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified public IP address in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param options The options parameters.
     */
    get(resourceGroupName, publicIpAddressName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, publicIpAddressName, options }, getOperationSpec$1u);
    }
    /**
     * Creates or updates a static or dynamic public IP address.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param parameters Parameters supplied to the create or update public IP address operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, publicIpAddressName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, publicIpAddressName, parameters, options },
                spec: createOrUpdateOperationSpec$1g
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a static or dynamic public IP address.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param parameters Parameters supplied to the create or update public IP address operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, publicIpAddressName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, publicIpAddressName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates public IP address tags.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param parameters Parameters supplied to update public IP address tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, publicIpAddressName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, publicIpAddressName, parameters, options }, updateTagsOperationSpec$x);
    }
    /**
     * Gets all the public IP addresses in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$e);
    }
    /**
     * Gets all public IP addresses in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1A);
    }
    /**
     * Gets the Ddos Protection Status of a Public IP Address
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param options The options parameters.
     */
    beginDdosProtectionStatus(resourceGroupName, publicIpAddressName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, publicIpAddressName, options },
                spec: ddosProtectionStatusOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the Ddos Protection Status of a Public IP Address
     * @param resourceGroupName The name of the resource group.
     * @param publicIpAddressName The name of the public IP address.
     * @param options The options parameters.
     */
    beginDdosProtectionStatusAndWait(resourceGroupName, publicIpAddressName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDdosProtectionStatus(resourceGroupName, publicIpAddressName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about all public IP addresses on a virtual machine scale set level.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, options }, listVirtualMachineScaleSetPublicIPAddressesOperationSpec);
    }
    /**
     * Gets information about all public IP addresses in a virtual machine IP configuration in a virtual
     * machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetVMPublicIPAddresses(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            ipConfigurationName,
            options
        }, listVirtualMachineScaleSetVMPublicIPAddressesOperationSpec);
    }
    /**
     * Get the specified public IP address in a virtual machine scale set.
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The name of the network interface.
     * @param ipConfigurationName The name of the IP configuration.
     * @param publicIpAddressName The name of the public IP Address.
     * @param options The options parameters.
     */
    getVirtualMachineScaleSetPublicIPAddress(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, publicIpAddressName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            ipConfigurationName,
            publicIpAddressName,
            options
        }, getVirtualMachineScaleSetPublicIPAddressOperationSpec);
    }
    /**
     * ListCloudServicePublicIPAddressesNext
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListCloudServicePublicIPAddresses method.
     * @param options The options parameters.
     */
    _listCloudServicePublicIPAddressesNext(resourceGroupName, cloudServiceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, cloudServiceName, nextLink, options }, listCloudServicePublicIPAddressesNextOperationSpec);
    }
    /**
     * ListCloudServiceRoleInstancePublicIPAddressesNext
     * @param resourceGroupName The name of the resource group.
     * @param cloudServiceName The name of the cloud service.
     * @param roleInstanceName The name of role instance.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListCloudServiceRoleInstancePublicIPAddresses method.
     * @param options The options parameters.
     */
    _listCloudServiceRoleInstancePublicIPAddressesNext(resourceGroupName, cloudServiceName, roleInstanceName, networkInterfaceName, ipConfigurationName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            cloudServiceName,
            roleInstanceName,
            networkInterfaceName,
            ipConfigurationName,
            nextLink,
            options
        }, listCloudServiceRoleInstancePublicIPAddressesNextOperationSpec);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$d);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1m);
    }
    /**
     * ListVirtualMachineScaleSetPublicIPAddressesNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetPublicIPAddresses method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetPublicIPAddressesNext(resourceGroupName, virtualMachineScaleSetName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualMachineScaleSetName, nextLink, options }, listVirtualMachineScaleSetPublicIPAddressesNextOperationSpec);
    }
    /**
     * ListVirtualMachineScaleSetVMPublicIPAddressesNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualMachineScaleSetName The name of the virtual machine scale set.
     * @param virtualmachineIndex The virtual machine index.
     * @param networkInterfaceName The network interface name.
     * @param ipConfigurationName The IP configuration name.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListVirtualMachineScaleSetVMPublicIPAddresses method.
     * @param options The options parameters.
     */
    _listVirtualMachineScaleSetVMPublicIPAddressesNext(resourceGroupName, virtualMachineScaleSetName, virtualmachineIndex, networkInterfaceName, ipConfigurationName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualMachineScaleSetName,
            virtualmachineIndex,
            networkInterfaceName,
            ipConfigurationName,
            nextLink,
            options
        }, listVirtualMachineScaleSetVMPublicIPAddressesNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1R = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listCloudServicePublicIPAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/publicipaddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listCloudServiceRoleInstancePublicIPAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/networkInterfaces/{networkInterfaceName}/ipconfigurations/{ipConfigurationName}/publicipaddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName,
        roleInstanceName,
        networkInterfaceName,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const getCloudServicePublicIPAddressOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/cloudServices/{cloudServiceName}/roleInstances/{roleInstanceName}/networkInterfaces/{networkInterfaceName}/ipconfigurations/{ipConfigurationName}/publicipaddresses/{publicIpAddressName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        cloudServiceName,
        roleInstanceName,
        networkInterfaceName,
        ipConfigurationName,
        publicIpAddressName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const deleteOperationSpec$1f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{publicIpAddressName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpAddressName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const getOperationSpec$1u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{publicIpAddressName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpAddressName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const createOrUpdateOperationSpec$1g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{publicIpAddressName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        201: {
            bodyMapper: PublicIPAddress
        },
        202: {
            bodyMapper: PublicIPAddress
        },
        204: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters9,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpAddressName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1R
};
const updateTagsOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{publicIpAddressName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpAddressName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1R
};
const listAllOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/publicIPAddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listOperationSpec$1A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const ddosProtectionStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPAddresses/{publicIpAddressName}/ddosProtectionStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PublicIpDdosProtectionStatusResult
        },
        201: {
            bodyMapper: PublicIpDdosProtectionStatusResult
        },
        202: {
            bodyMapper: PublicIpDdosProtectionStatusResult
        },
        204: {
            bodyMapper: PublicIpDdosProtectionStatusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpAddressName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listVirtualMachineScaleSetPublicIPAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/publicipaddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listVirtualMachineScaleSetVMPublicIPAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}/ipconfigurations/{ipConfigurationName}/publicipaddresses",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const getVirtualMachineScaleSetPublicIPAddressOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{virtualMachineScaleSetName}/virtualMachines/{virtualmachineIndex}/networkInterfaces/{networkInterfaceName}/ipconfigurations/{ipConfigurationName}/publicipaddresses/{publicIpAddressName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddress
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [expand, apiVersion1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex,
        ipConfigurationName,
        publicIpAddressName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listCloudServicePublicIPAddressesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        cloudServiceName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listCloudServiceRoleInstancePublicIPAddressesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        cloudServiceName,
        roleInstanceName,
        networkInterfaceName,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listAllNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listNextOperationSpec$1m = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listVirtualMachineScaleSetPublicIPAddressesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualMachineScaleSetName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};
const listVirtualMachineScaleSetVMPublicIPAddressesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPAddressListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName,
        virtualMachineScaleSetName,
        virtualmachineIndex,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1R
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VipSwap operations. */
class VipSwapImpl {
    /**
     * Initialize a new instance of the class VipSwap class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets the SwapResource which identifies the slot type for the specified cloud service. The slot type
     * on a cloud service can either be Staging or Production
     * @param groupName The name of the resource group.
     * @param resourceName The name of the cloud service.
     * @param options The options parameters.
     */
    get(groupName, resourceName, options) {
        return this.client.sendOperationRequest({ groupName, resourceName, options }, getOperationSpec$1t);
    }
    /**
     * Performs vip swap operation on swappable cloud services.
     * @param groupName The name of the resource group.
     * @param resourceName The name of the cloud service.
     * @param parameters SwapResource object where slot type should be the target slot after vip swap for
     *                   the specified cloud service.
     * @param options The options parameters.
     */
    beginCreate(groupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { groupName, resourceName, parameters, options },
                spec: createOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Performs vip swap operation on swappable cloud services.
     * @param groupName The name of the resource group.
     * @param resourceName The name of the cloud service.
     * @param parameters SwapResource object where slot type should be the target slot after vip swap for
     *                   the specified cloud service.
     * @param options The options parameters.
     */
    beginCreateAndWait(groupName, resourceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(groupName, resourceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the list of SwapResource which identifies the slot type for the specified cloud service. The
     * slot type on a cloud service can either be Staging or Production
     * @param groupName The name of the resource group.
     * @param resourceName The name of the cloud service.
     * @param options The options parameters.
     */
    list(groupName, resourceName, options) {
        return this.client.sendOperationRequest({ groupName, resourceName, options }, listOperationSpec$1z);
    }
}
// Operation Specifications
const serializer$1Q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Compute/cloudServices/{resourceName}/providers/Microsoft.Network/cloudServiceSlots/{singletonResource}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SwapResource
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        groupName,
        resourceName,
        singletonResource
    ],
    headerParameters: [accept],
    serializer: serializer$1Q
};
const createOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Compute/cloudServices/{resourceName}/providers/Microsoft.Network/cloudServiceSlots/{singletonResource}",
    httpMethod: "PUT",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters10,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        groupName,
        resourceName,
        singletonResource
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1Q
};
const listOperationSpec$1z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Compute/cloudServices/{resourceName}/providers/Microsoft.Network/cloudServiceSlots",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SwapResourceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        groupName,
        resourceName
    ],
    headerParameters: [accept],
    serializer: serializer$1Q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing CustomIPPrefixes operations. */
class CustomIPPrefixesImpl {
    /**
     * Initialize a new instance of the class CustomIPPrefixes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the custom IP prefixes in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all custom IP prefixes in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified custom IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the CustomIpPrefix.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, customIpPrefixName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, customIpPrefixName, options },
                spec: deleteOperationSpec$1e
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified custom IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the CustomIpPrefix.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, customIpPrefixName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, customIpPrefixName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified custom IP prefix in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the custom IP prefix.
     * @param options The options parameters.
     */
    get(resourceGroupName, customIpPrefixName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, customIpPrefixName, options }, getOperationSpec$1s);
    }
    /**
     * Creates or updates a custom IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the custom IP prefix.
     * @param parameters Parameters supplied to the create or update custom IP prefix operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, customIpPrefixName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, customIpPrefixName, parameters, options },
                spec: createOrUpdateOperationSpec$1f
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a custom IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the custom IP prefix.
     * @param parameters Parameters supplied to the create or update custom IP prefix operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, customIpPrefixName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, customIpPrefixName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates custom IP prefix tags.
     * @param resourceGroupName The name of the resource group.
     * @param customIpPrefixName The name of the custom IP prefix.
     * @param parameters Parameters supplied to update custom IP prefix tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, customIpPrefixName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, customIpPrefixName, parameters, options }, updateTagsOperationSpec$w);
    }
    /**
     * Gets all the custom IP prefixes in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$d);
    }
    /**
     * Gets all custom IP prefixes in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1y);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$c);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1l);
    }
}
// Operation Specifications
const serializer$1P = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes/{customIpPrefixName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        customIpPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const getOperationSpec$1s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes/{customIpPrefixName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        customIpPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const createOrUpdateOperationSpec$1f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes/{customIpPrefixName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: CustomIpPrefix
        },
        201: {
            bodyMapper: CustomIpPrefix
        },
        202: {
            bodyMapper: CustomIpPrefix
        },
        204: {
            bodyMapper: CustomIpPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters11,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        customIpPrefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1P
};
const updateTagsOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes/{customIpPrefixName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: CustomIpPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        customIpPrefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1P
};
const listAllOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/customIpPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1P
};
const listOperationSpec$1y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/customIpPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const listAllNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};
const listNextOperationSpec$1l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: CustomIpPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1P
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing DdosCustomPolicies operations. */
class DdosCustomPoliciesImpl {
    /**
     * Initialize a new instance of the class DdosCustomPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Deletes the specified DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, ddosCustomPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, ddosCustomPolicyName, options },
                spec: deleteOperationSpec$1d
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, ddosCustomPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, ddosCustomPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, ddosCustomPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ddosCustomPolicyName, options }, getOperationSpec$1r);
    }
    /**
     * Creates or updates a DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param parameters Parameters supplied to the create or update operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, ddosCustomPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, ddosCustomPolicyName, parameters, options },
                spec: createOrUpdateOperationSpec$1e
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a DDoS custom policy.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param parameters Parameters supplied to the create or update operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, ddosCustomPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, ddosCustomPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a DDoS custom policy tags.
     * @param resourceGroupName The name of the resource group.
     * @param ddosCustomPolicyName The name of the DDoS custom policy.
     * @param parameters Parameters supplied to update DDoS custom policy resource tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, ddosCustomPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ddosCustomPolicyName, parameters, options }, updateTagsOperationSpec$v);
    }
}
// Operation Specifications
const serializer$1O = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosCustomPolicies/{ddosCustomPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosCustomPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const getOperationSpec$1r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosCustomPolicies/{ddosCustomPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosCustomPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosCustomPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1O
};
const createOrUpdateOperationSpec$1e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosCustomPolicies/{ddosCustomPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DdosCustomPolicy
        },
        201: {
            bodyMapper: DdosCustomPolicy
        },
        202: {
            bodyMapper: DdosCustomPolicy
        },
        204: {
            bodyMapper: DdosCustomPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters12,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosCustomPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1O
};
const updateTagsOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosCustomPolicies/{ddosCustomPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DdosCustomPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosCustomPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1O
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DdosProtectionPlans operations. */
class DdosProtectionPlansImpl {
    /**
     * Initialize a new instance of the class DdosProtectionPlans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all DDoS protection plans in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the DDoS protection plans in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, ddosProtectionPlanName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, ddosProtectionPlanName, options },
                spec: deleteOperationSpec$1c
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, ddosProtectionPlanName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, ddosProtectionPlanName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param options The options parameters.
     */
    get(resourceGroupName, ddosProtectionPlanName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ddosProtectionPlanName, options }, getOperationSpec$1q);
    }
    /**
     * Creates or updates a DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param parameters Parameters supplied to the create or update operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, ddosProtectionPlanName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, ddosProtectionPlanName, parameters, options },
                spec: createOrUpdateOperationSpec$1d
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a DDoS protection plan.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param parameters Parameters supplied to the create or update operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, ddosProtectionPlanName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, ddosProtectionPlanName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update a DDoS protection plan tags.
     * @param resourceGroupName The name of the resource group.
     * @param ddosProtectionPlanName The name of the DDoS protection plan.
     * @param parameters Parameters supplied to the update DDoS protection plan resource tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, ddosProtectionPlanName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ddosProtectionPlanName, parameters, options }, updateTagsOperationSpec$u);
    }
    /**
     * Gets all DDoS protection plans in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1x);
    }
    /**
     * Gets all the DDoS protection plans in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$j);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1k);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$i);
    }
}
// Operation Specifications
const serializer$1N = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans/{ddosProtectionPlanName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosProtectionPlanName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const getOperationSpec$1q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans/{ddosProtectionPlanName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlan
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosProtectionPlanName
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const createOrUpdateOperationSpec$1d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans/{ddosProtectionPlanName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlan
        },
        201: {
            bodyMapper: DdosProtectionPlan
        },
        202: {
            bodyMapper: DdosProtectionPlan
        },
        204: {
            bodyMapper: DdosProtectionPlan
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters13,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosProtectionPlanName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1N
};
const updateTagsOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans/{ddosProtectionPlanName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlan
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ddosProtectionPlanName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1N
};
const listOperationSpec$1x = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ddosProtectionPlans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlanListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByResourceGroupOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ddosProtectionPlans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlanListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listNextOperationSpec$1k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlanListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};
const listByResourceGroupNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DdosProtectionPlanListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1N
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DscpConfigurationOperations operations. */
class DscpConfigurationOperationsImpl {
    /**
     * Initialize a new instance of the class DscpConfigurationOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all dscp configurations in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates or updates a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param parameters Parameters supplied to the create or update dscp configuration operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, dscpConfigurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, dscpConfigurationName, parameters, options },
                spec: createOrUpdateOperationSpec$1c
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param parameters Parameters supplied to the create or update dscp configuration operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, dscpConfigurationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, dscpConfigurationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, dscpConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, dscpConfigurationName, options },
                spec: deleteOperationSpec$1b
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, dscpConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, dscpConfigurationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param dscpConfigurationName The name of the resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, dscpConfigurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, dscpConfigurationName, options }, getOperationSpec$1p);
    }
    /**
     * Gets a DSCP Configuration.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1w);
    }
    /**
     * Gets all dscp configurations in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$c);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1j);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$1M = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dscpConfigurations/{dscpConfigurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: DscpConfiguration
        },
        201: {
            bodyMapper: DscpConfiguration
        },
        202: {
            bodyMapper: DscpConfiguration
        },
        204: {
            bodyMapper: DscpConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters14,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        dscpConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1M
};
const deleteOperationSpec$1b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dscpConfigurations/{dscpConfigurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        dscpConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};
const getOperationSpec$1p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dscpConfigurations/{dscpConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        dscpConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};
const listOperationSpec$1w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/dscpConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};
const listAllOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/dscpConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1M
};
const listNextOperationSpec$1j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};
const listAllNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DscpConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1M
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailableEndpointServices operations. */
class AvailableEndpointServicesImpl {
    /**
     * Initialize a new instance of the class AvailableEndpointServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List what values of endpoint services are available for use.
     * @param location The location to check available endpoint services.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List what values of endpoint services are available for use.
     * @param location The location to check available endpoint services.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$1v);
    }
    /**
     * ListNext
     * @param location The location to check available endpoint services.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$1i);
    }
}
// Operation Specifications
const serializer$1L = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1v = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/virtualNetworkAvailableEndpointServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EndpointServicesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};
const listNextOperationSpec$1i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: EndpointServicesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$1L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCircuitAuthorizations operations. */
class ExpressRouteCircuitAuthorizationsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCircuitAuthorizations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all authorizations in an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param options The options parameters.
     */
    list(resourceGroupName, circuitName, options) {
        const iter = this.listPagingAll(resourceGroupName, circuitName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, circuitName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, circuitName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, circuitName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, circuitName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, circuitName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, circuitName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified authorization from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, circuitName, authorizationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, circuitName, authorizationName, options },
                spec: deleteOperationSpec$1a
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified authorization from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, circuitName, authorizationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, circuitName, authorizationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified authorization from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, authorizationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, authorizationName, options }, getOperationSpec$1o);
    }
    /**
     * Creates or updates an authorization in the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param authorizationParameters Parameters supplied to the create or update express route circuit
     *                                authorization operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, circuitName, authorizationName, authorizationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    circuitName,
                    authorizationName,
                    authorizationParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$1b
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an authorization in the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param authorizationName The name of the authorization.
     * @param authorizationParameters Parameters supplied to the create or update express route circuit
     *                                authorization operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, circuitName, authorizationName, authorizationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, circuitName, authorizationName, authorizationParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all authorizations in an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param options The options parameters.
     */
    _list(resourceGroupName, circuitName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, options }, listOperationSpec$1u);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, circuitName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, nextLink, options }, listNextOperationSpec$1h);
    }
}
// Operation Specifications
const serializer$1K = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$1a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/authorizations/{authorizationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        authorizationName
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};
const getOperationSpec$1o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/authorizations/{authorizationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        authorizationName
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};
const createOrUpdateOperationSpec$1b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/authorizations/{authorizationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        201: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        202: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        204: {
            bodyMapper: ExpressRouteCircuitAuthorization
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: authorizationParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        authorizationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1K
};
const listOperationSpec$1u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/authorizations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};
const listNextOperationSpec$1h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AuthorizationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$1K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCircuitPeerings operations. */
class ExpressRouteCircuitPeeringsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCircuitPeerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all peerings in a specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    list(resourceGroupName, circuitName, options) {
        const iter = this.listPagingAll(resourceGroupName, circuitName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, circuitName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, circuitName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, circuitName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, circuitName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, circuitName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, circuitName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified peering from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, circuitName, peeringName, options },
                spec: deleteOperationSpec$19
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified peering from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, circuitName, peeringName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified peering for the express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, options }, getOperationSpec$1n);
    }
    /**
     * Creates or updates a peering in the specified express route circuits.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param peeringParameters Parameters supplied to the create or update express route circuit peering
     *                          operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, circuitName, peeringName, peeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    circuitName,
                    peeringName,
                    peeringParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$1a
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a peering in the specified express route circuits.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param peeringParameters Parameters supplied to the create or update express route circuit peering
     *                          operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, circuitName, peeringName, peeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, circuitName, peeringName, peeringParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all peerings in a specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    _list(resourceGroupName, circuitName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, options }, listOperationSpec$1t);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, circuitName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, nextLink, options }, listNextOperationSpec$1g);
    }
}
// Operation Specifications
const serializer$1J = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$19 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};
const getOperationSpec$1n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};
const createOrUpdateOperationSpec$1a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        201: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        202: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        204: {
            bodyMapper: ExpressRouteCircuitPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: peeringParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1J
};
const listOperationSpec$1t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitPeeringListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};
const listNextOperationSpec$1g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitPeeringListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$1J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCircuitConnections operations. */
class ExpressRouteCircuitConnectionsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCircuitConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all global reach connections associated with a private peering in an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    list(resourceGroupName, circuitName, peeringName, options) {
        const iter = this.listPagingAll(resourceGroupName, circuitName, peeringName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, circuitName, peeringName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, circuitName, peeringName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, circuitName, peeringName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, circuitName, peeringName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, circuitName, peeringName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified Express Route Circuit Connection from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, circuitName, peeringName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    circuitName,
                    peeringName,
                    connectionName,
                    options
                },
                spec: deleteOperationSpec$18
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified Express Route Circuit Connection from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, circuitName, peeringName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, circuitName, peeringName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Express Route Circuit Connection from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, peeringName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, connectionName, options }, getOperationSpec$1m);
    }
    /**
     * Creates or updates a Express Route Circuit Connection in the specified express route circuits.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param expressRouteCircuitConnectionParameters Parameters supplied to the create or update express
     *                                                route circuit connection operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, circuitName, peeringName, connectionName, expressRouteCircuitConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    circuitName,
                    peeringName,
                    connectionName,
                    expressRouteCircuitConnectionParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$19
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a Express Route Circuit Connection in the specified express route circuits.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the express route circuit connection.
     * @param expressRouteCircuitConnectionParameters Parameters supplied to the create or update express
     *                                                route circuit connection operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, circuitName, peeringName, connectionName, expressRouteCircuitConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, circuitName, peeringName, connectionName, expressRouteCircuitConnectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all global reach connections associated with a private peering in an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    _list(resourceGroupName, circuitName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, options }, listOperationSpec$1s);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, circuitName, peeringName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, nextLink, options }, listNextOperationSpec$1f);
    }
}
// Operation Specifications
const serializer$1I = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$18 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/connections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};
const getOperationSpec$1m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/connections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};
const createOrUpdateOperationSpec$19 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/connections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        201: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        202: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        204: {
            bodyMapper: ExpressRouteCircuitConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: expressRouteCircuitConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        circuitName,
        peeringName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1I
};
const listOperationSpec$1s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/connections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};
const listNextOperationSpec$1f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PeerExpressRouteCircuitConnections operations. */
class PeerExpressRouteCircuitConnectionsImpl {
    /**
     * Initialize a new instance of the class PeerExpressRouteCircuitConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all global reach peer connections associated with a private peering in an express route
     * circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    list(resourceGroupName, circuitName, peeringName, options) {
        const iter = this.listPagingAll(resourceGroupName, circuitName, peeringName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, circuitName, peeringName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, circuitName, peeringName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, circuitName, peeringName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, circuitName, peeringName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, circuitName, peeringName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, circuitName, peeringName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the specified Peer Express Route Circuit Connection from the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param connectionName The name of the peer express route circuit connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, peeringName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, connectionName, options }, getOperationSpec$1l);
    }
    /**
     * Gets all global reach peer connections associated with a private peering in an express route
     * circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    _list(resourceGroupName, circuitName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, options }, listOperationSpec$1r);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param peeringName The name of the peering.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, circuitName, peeringName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, nextLink, options }, listNextOperationSpec$1e);
    }
}
// Operation Specifications
const serializer$1H = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/peerConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeerExpressRouteCircuitConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1H
};
const listOperationSpec$1r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/peerConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeerExpressRouteCircuitConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1H
};
const listNextOperationSpec$1e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PeerExpressRouteCircuitConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCircuits operations. */
class ExpressRouteCircuitsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCircuits class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the express route circuits in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the express route circuits in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, circuitName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, circuitName, options },
                spec: deleteOperationSpec$17
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, circuitName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, circuitName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of express route circuit.
     * @param options The options parameters.
     */
    get(resourceGroupName, circuitName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, options }, getOperationSpec$1k);
    }
    /**
     * Creates or updates an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param parameters Parameters supplied to the create or update express route circuit operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, circuitName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, circuitName, parameters, options },
                spec: createOrUpdateOperationSpec$18
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an express route circuit.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param parameters Parameters supplied to the create or update express route circuit operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, circuitName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, circuitName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an express route circuit tags.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the circuit.
     * @param parameters Parameters supplied to update express route circuit tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, circuitName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, parameters, options }, updateTagsOperationSpec$t);
    }
    /**
     * Gets the currently advertised ARP table associated with the express route circuit in a resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListArpTable(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    circuitName,
                    peeringName,
                    devicePath,
                    options
                },
                spec: listArpTableOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the currently advertised ARP table associated with the express route circuit in a resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListArpTableAndWait(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListArpTable(resourceGroupName, circuitName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the currently advertised routes table associated with the express route circuit in a resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTable(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    circuitName,
                    peeringName,
                    devicePath,
                    options
                },
                spec: listRoutesTableOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the currently advertised routes table associated with the express route circuit in a resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableAndWait(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListRoutesTable(resourceGroupName, circuitName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the currently advertised routes table summary associated with the express route circuit in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableSummary(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    circuitName,
                    peeringName,
                    devicePath,
                    options
                },
                spec: listRoutesTableSummaryOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the currently advertised routes table summary associated with the express route circuit in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableSummaryAndWait(resourceGroupName, circuitName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListRoutesTableSummary(resourceGroupName, circuitName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all the stats from an express route circuit in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param options The options parameters.
     */
    getStats(resourceGroupName, circuitName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, options }, getStatsOperationSpec);
    }
    /**
     * Gets all stats from an express route circuit in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param circuitName The name of the express route circuit.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    getPeeringStats(resourceGroupName, circuitName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, circuitName, peeringName, options }, getPeeringStatsOperationSpec);
    }
    /**
     * Gets all the express route circuits in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1q);
    }
    /**
     * Gets all the express route circuits in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$b);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$1d);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$1G = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$17 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const getOperationSpec$1k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuit
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const createOrUpdateOperationSpec$18 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuit
        },
        201: {
            bodyMapper: ExpressRouteCircuit
        },
        202: {
            bodyMapper: ExpressRouteCircuit
        },
        204: {
            bodyMapper: ExpressRouteCircuit
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters15,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1G
};
const updateTagsOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuit
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1G
};
const listArpTableOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/arpTables/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName,
        devicePath
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const listRoutesTableOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/routeTables/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName,
        devicePath
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const listRoutesTableSummaryOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/routeTablesSummary/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsRoutesTableSummaryListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsRoutesTableSummaryListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsRoutesTableSummaryListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsRoutesTableSummaryListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName,
        devicePath
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const getStatsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/stats",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitStats
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const getPeeringStatsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits/{circuitName}/peerings/{peeringName}/stats",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitStats
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        circuitName,
        peeringName
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const listOperationSpec$1q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCircuits",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const listAllOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteCircuits",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1G
};
const listNextOperationSpec$1d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};
const listAllNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteServiceProviders operations. */
class ExpressRouteServiceProvidersImpl {
    /**
     * Initialize a new instance of the class ExpressRouteServiceProviders class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the available express route service providers.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the available express route service providers.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1p);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1c);
    }
}
// Operation Specifications
const serializer$1F = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1p = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteServiceProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteServiceProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1F
};
const listNextOperationSpec$1c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteServiceProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCrossConnections operations. */
class ExpressRouteCrossConnectionsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCrossConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all the ExpressRouteCrossConnections in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves all the ExpressRouteCrossConnections in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves all the ExpressRouteCrossConnections in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1o);
    }
    /**
     * Retrieves all the ExpressRouteCrossConnections in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$i);
    }
    /**
     * Gets details about the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group (peering location of the circuit).
     * @param crossConnectionName The name of the ExpressRouteCrossConnection (service key of the circuit).
     * @param options The options parameters.
     */
    get(resourceGroupName, crossConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, crossConnectionName, options }, getOperationSpec$1j);
    }
    /**
     * Update the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param parameters Parameters supplied to the update express route crossConnection operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, crossConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, crossConnectionName, parameters, options },
                spec: createOrUpdateOperationSpec$17
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Update the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param parameters Parameters supplied to the update express route crossConnection operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, crossConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, crossConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an express route cross connection tags.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the cross connection.
     * @param crossConnectionParameters Parameters supplied to update express route cross connection tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, crossConnectionName, crossConnectionParameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            crossConnectionName,
            crossConnectionParameters,
            options
        }, updateTagsOperationSpec$s);
    }
    /**
     * Gets the currently advertised ARP table associated with the express route cross connection in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListArpTable(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    crossConnectionName,
                    peeringName,
                    devicePath,
                    options
                },
                spec: listArpTableOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the currently advertised ARP table associated with the express route cross connection in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListArpTableAndWait(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListArpTable(resourceGroupName, crossConnectionName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the route table summary associated with the express route cross connection in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableSummary(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    crossConnectionName,
                    peeringName,
                    devicePath,
                    options
                },
                spec: listRoutesTableSummaryOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the route table summary associated with the express route cross connection in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableSummaryAndWait(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListRoutesTableSummary(resourceGroupName, crossConnectionName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the currently advertised routes table associated with the express route cross connection in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTable(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    crossConnectionName,
                    peeringName,
                    devicePath,
                    options
                },
                spec: listRoutesTableOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the currently advertised routes table associated with the express route cross connection in a
     * resource group.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param devicePath The path of the device.
     * @param options The options parameters.
     */
    beginListRoutesTableAndWait(resourceGroupName, crossConnectionName, peeringName, devicePath, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListRoutesTable(resourceGroupName, crossConnectionName, peeringName, devicePath, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$1b);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$1E = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1o = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteCrossConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1E
};
const listByResourceGroupOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const getOperationSpec$1j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const createOrUpdateOperationSpec$17 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnection
        },
        201: {
            bodyMapper: ExpressRouteCrossConnection
        },
        202: {
            bodyMapper: ExpressRouteCrossConnection
        },
        204: {
            bodyMapper: ExpressRouteCrossConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters16,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        crossConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1E
};
const updateTagsOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: crossConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        crossConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1E
};
const listArpTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}/arpTables/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsArpTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        devicePath,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const listRoutesTableSummaryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}/routeTablesSummary/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionsRoutesTableSummaryListResult
        },
        201: {
            bodyMapper: ExpressRouteCrossConnectionsRoutesTableSummaryListResult
        },
        202: {
            bodyMapper: ExpressRouteCrossConnectionsRoutesTableSummaryListResult
        },
        204: {
            bodyMapper: ExpressRouteCrossConnectionsRoutesTableSummaryListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        devicePath,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const listRoutesTableOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}/routeTables/{devicePath}",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        201: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        202: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        204: {
            bodyMapper: ExpressRouteCircuitsRoutesTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        devicePath,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const listNextOperationSpec$1b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};
const listByResourceGroupNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteCrossConnectionPeerings operations. */
class ExpressRouteCrossConnectionPeeringsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteCrossConnectionPeerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all peerings in a specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param options The options parameters.
     */
    list(resourceGroupName, crossConnectionName, options) {
        const iter = this.listPagingAll(resourceGroupName, crossConnectionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, crossConnectionName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, crossConnectionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, crossConnectionName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, crossConnectionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, crossConnectionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, crossConnectionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all peerings in a specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param options The options parameters.
     */
    _list(resourceGroupName, crossConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, crossConnectionName, options }, listOperationSpec$1n);
    }
    /**
     * Deletes the specified peering from the ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, crossConnectionName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, crossConnectionName, peeringName, options },
                spec: deleteOperationSpec$16
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified peering from the ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, crossConnectionName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, crossConnectionName, peeringName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified peering for the ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, crossConnectionName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, crossConnectionName, peeringName, options }, getOperationSpec$1i);
    }
    /**
     * Creates or updates a peering in the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param peeringParameters Parameters supplied to the create or update ExpressRouteCrossConnection
     *                          peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, crossConnectionName, peeringName, peeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    crossConnectionName,
                    peeringName,
                    peeringParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$16
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a peering in the specified ExpressRouteCrossConnection.
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param peeringName The name of the peering.
     * @param peeringParameters Parameters supplied to the create or update ExpressRouteCrossConnection
     *                          peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, crossConnectionName, peeringName, peeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, crossConnectionName, peeringName, peeringParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param crossConnectionName The name of the ExpressRouteCrossConnection.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, crossConnectionName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, crossConnectionName, nextLink, options }, listNextOperationSpec$1a);
    }
}
// Operation Specifications
const serializer$1D = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionPeeringList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};
const deleteOperationSpec$16 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};
const getOperationSpec$1i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};
const createOrUpdateOperationSpec$16 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteCrossConnections/{crossConnectionName}/peerings/{peeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        201: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        202: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        204: {
            bodyMapper: ExpressRouteCrossConnectionPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: peeringParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        crossConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1D
};
const listNextOperationSpec$1a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteCrossConnectionPeeringList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        crossConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRoutePortsLocations operations. */
class ExpressRoutePortsLocationsImpl {
    /**
     * Initialize a new instance of the class ExpressRoutePortsLocations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all ExpressRoutePort peering locations. Does not return available bandwidths for each
     * location. Available bandwidths can only be obtained when retrieving a specific peering location.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves all ExpressRoutePort peering locations. Does not return available bandwidths for each
     * location. Available bandwidths can only be obtained when retrieving a specific peering location.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1m);
    }
    /**
     * Retrieves a single ExpressRoutePort peering location, including the list of available bandwidths
     * available at said peering location.
     * @param locationName Name of the requested ExpressRoutePort peering location.
     * @param options The options parameters.
     */
    get(locationName, options) {
        return this.client.sendOperationRequest({ locationName, options }, getOperationSpec$1h);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$19);
    }
}
// Operation Specifications
const serializer$1C = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1m = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ExpressRoutePortsLocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortsLocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1C
};
const getOperationSpec$1h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ExpressRoutePortsLocations/{locationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortsLocation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        locationName
    ],
    headerParameters: [accept],
    serializer: serializer$1C
};
const listNextOperationSpec$19 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortsLocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRoutePorts operations. */
class ExpressRoutePortsImpl {
    /**
     * Initialize a new instance of the class ExpressRoutePorts class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all the ExpressRoutePort resources in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all the ExpressRoutePort resources in the specified subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, expressRoutePortName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, expressRoutePortName, options },
                spec: deleteOperationSpec$15
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, expressRoutePortName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, expressRoutePortName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the requested ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of ExpressRoutePort.
     * @param options The options parameters.
     */
    get(resourceGroupName, expressRoutePortName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, options }, getOperationSpec$1g);
    }
    /**
     * Creates or updates the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param parameters Parameters supplied to the create ExpressRoutePort operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, expressRoutePortName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, expressRoutePortName, parameters, options },
                spec: createOrUpdateOperationSpec$15
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param parameters Parameters supplied to the create ExpressRoutePort operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, expressRoutePortName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, expressRoutePortName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update ExpressRoutePort tags.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param parameters Parameters supplied to update ExpressRoutePort resource tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, expressRoutePortName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, parameters, options }, updateTagsOperationSpec$r);
    }
    /**
     * List all the ExpressRoutePort resources in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$h);
    }
    /**
     * List all the ExpressRoutePort resources in the specified subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1l);
    }
    /**
     * Generate a letter of authorization for the requested ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of ExpressRoutePort.
     * @param request Request parameters supplied to generate a letter of authorization.
     * @param options The options parameters.
     */
    generateLOA(resourceGroupName, expressRoutePortName, request, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, request, options }, generateLOAOperationSpec);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$g);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$18);
    }
}
// Operation Specifications
const serializer$1B = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$15 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const getOperationSpec$1g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePort
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const createOrUpdateOperationSpec$15 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRoutePort
        },
        201: {
            bodyMapper: ExpressRoutePort
        },
        202: {
            bodyMapper: ExpressRoutePort
        },
        204: {
            bodyMapper: ExpressRoutePort
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters17,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1B
};
const updateTagsOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ExpressRoutePort
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1B
};
const listByResourceGroupOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const listOperationSpec$1l = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ExpressRoutePorts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1B
};
const generateLOAOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRoutePorts/{expressRoutePortName}/generateLoa",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GenerateExpressRoutePortsLOAResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1B
};
const listByResourceGroupNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};
const listNextOperationSpec$18 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRouteLinks operations. */
class ExpressRouteLinksImpl {
    /**
     * Initialize a new instance of the class ExpressRouteLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieve the ExpressRouteLink sub-resources of the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, expressRoutePortName, options) {
        const iter = this.listPagingAll(resourceGroupName, expressRoutePortName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, expressRoutePortName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, expressRoutePortName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, expressRoutePortName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, expressRoutePortName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, expressRoutePortName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, expressRoutePortName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the specified ExpressRouteLink resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param linkName The name of the ExpressRouteLink resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, expressRoutePortName, linkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, linkName, options }, getOperationSpec$1f);
    }
    /**
     * Retrieve the ExpressRouteLink sub-resources of the specified ExpressRoutePort resource.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, expressRoutePortName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, options }, listOperationSpec$1k);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the ExpressRoutePort resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, expressRoutePortName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, nextLink, options }, listNextOperationSpec$17);
    }
}
// Operation Specifications
const serializer$1A = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$1f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}/links/{linkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteLink
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName,
        linkName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};
const listOperationSpec$1k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ExpressRoutePorts/{expressRoutePortName}/links",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};
const listNextOperationSpec$17 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$1A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ExpressRoutePortAuthorizations operations. */
class ExpressRoutePortAuthorizationsImpl {
    /**
     * Initialize a new instance of the class ExpressRoutePortAuthorizations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all authorizations in an express route port.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the express route port.
     * @param options The options parameters.
     */
    list(resourceGroupName, expressRoutePortName, options) {
        const iter = this.listPagingAll(resourceGroupName, expressRoutePortName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, expressRoutePortName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, expressRoutePortName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, expressRoutePortName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, expressRoutePortName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, expressRoutePortName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, expressRoutePortName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified authorization from the specified express route port.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the express route port.
     * @param authorizationName The name of the authorization.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, expressRoutePortName, authorizationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    expressRoutePortName,
                    authorizationName,
                    options
                },
                spec: deleteOperationSpec$14
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified authorization from the specified express route port.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the express route port.
     * @param authorizationName The name of the authorization.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, expressRoutePortName, authorizationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, expressRoutePortName, authorizationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified authorization from the specified express route port.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the express route port.
     * @param authorizationName The name of the authorization.
     * @param options The options parameters.
     */
    get(resourceGroupName, expressRoutePortName, authorizationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, authorizationName, options }, getOperationSpec$1e);
    }
    /**
     * Creates or updates an authorization in the specified express route port.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the express route port.
     * @param authorizationName The name of the authorization.
     * @param authorizationParameters Parameters supplied to the create or update express route port
     *                                authorization operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, expressRoutePortName, authorizationName, authorizationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    expressRoutePortName,
                    authorizationName,
                    authorizationParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$14
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an authorization in the specified express route port.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the express route port.
     * @param authorizationName The name of the authorization.
     * @param authorizationParameters Parameters supplied to the create or update express route port
     *                                authorization operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, expressRoutePortName, authorizationName, authorizationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, expressRoutePortName, authorizationName, authorizationParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all authorizations in an express route port.
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the express route port.
     * @param options The options parameters.
     */
    _list(resourceGroupName, expressRoutePortName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, options }, listOperationSpec$1j);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param expressRoutePortName The name of the express route port.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, expressRoutePortName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRoutePortName, nextLink, options }, listNextOperationSpec$16);
    }
}
// Operation Specifications
const serializer$1z = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$14 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRoutePorts/{expressRoutePortName}/authorizations/{authorizationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        authorizationName,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$1z
};
const getOperationSpec$1e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRoutePorts/{expressRoutePortName}/authorizations/{authorizationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortAuthorization
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        authorizationName,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$1z
};
const createOrUpdateOperationSpec$14 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRoutePorts/{expressRoutePortName}/authorizations/{authorizationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortAuthorization
        },
        201: {
            bodyMapper: ExpressRoutePortAuthorization
        },
        202: {
            bodyMapper: ExpressRoutePortAuthorization
        },
        204: {
            bodyMapper: ExpressRoutePortAuthorization
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: authorizationParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        authorizationName,
        expressRoutePortName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1z
};
const listOperationSpec$1j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRoutePorts/{expressRoutePortName}/authorizations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortAuthorizationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$1z
};
const listNextOperationSpec$16 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRoutePortAuthorizationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        expressRoutePortName
    ],
    headerParameters: [accept],
    serializer: serializer$1z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ExpressRouteProviderPortsLocation operations. */
class ExpressRouteProviderPortsLocationImpl {
    /**
     * Initialize a new instance of the class ExpressRouteProviderPortsLocation class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all the ExpressRouteProviderPorts in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1i);
    }
}
// Operation Specifications
const serializer$1y = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1i = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteProviderPorts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteProviderPortListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, filter],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FirewallPolicies operations. */
class FirewallPoliciesImpl {
    /**
     * Initialize a new instance of the class FirewallPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Firewall Policies in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Firewall Policies in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, firewallPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, firewallPolicyName, options },
                spec: deleteOperationSpec$13
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, firewallPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, firewallPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, firewallPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, options }, getOperationSpec$1d);
    }
    /**
     * Creates or updates the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Parameters supplied to the create or update Firewall Policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, firewallPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, firewallPolicyName, parameters, options },
                spec: createOrUpdateOperationSpec$13
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified Firewall Policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Parameters supplied to the create or update Firewall Policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, firewallPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, firewallPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of a Azure Firewall Policy resource.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Parameters supplied to update Azure Firewall Policy tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, firewallPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, parameters, options }, updateTagsOperationSpec$q);
    }
    /**
     * Lists all Firewall Policies in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1h);
    }
    /**
     * Gets all the Firewall Policies in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$a);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$15);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$1x = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$13 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const getOperationSpec$1d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const createOrUpdateOperationSpec$13 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FirewallPolicy
        },
        201: {
            bodyMapper: FirewallPolicy
        },
        202: {
            bodyMapper: FirewallPolicy
        },
        204: {
            bodyMapper: FirewallPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters18,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1x
};
const updateTagsOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: FirewallPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1x
};
const listOperationSpec$1h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const listAllOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/firewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1x
};
const listNextOperationSpec$15 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};
const listAllNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FirewallPolicyRuleCollectionGroups operations. */
class FirewallPolicyRuleCollectionGroupsImpl {
    /**
     * Initialize a new instance of the class FirewallPolicyRuleCollectionGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all FirewallPolicyRuleCollectionGroups in a FirewallPolicy resource.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    list(resourceGroupName, firewallPolicyName, options) {
        const iter = this.listPagingAll(resourceGroupName, firewallPolicyName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, firewallPolicyName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, firewallPolicyName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, firewallPolicyName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, firewallPolicyName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, firewallPolicyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, firewallPolicyName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    firewallPolicyName,
                    ruleCollectionGroupName,
                    options
                },
                spec: deleteOperationSpec$12
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param options The options parameters.
     */
    get(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            firewallPolicyName,
            ruleCollectionGroupName,
            options
        }, getOperationSpec$1c);
    }
    /**
     * Creates or updates the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param parameters Parameters supplied to the create or update FirewallPolicyRuleCollectionGroup
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    firewallPolicyName,
                    ruleCollectionGroupName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$12
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified FirewallPolicyRuleCollectionGroup.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param ruleCollectionGroupName The name of the FirewallPolicyRuleCollectionGroup.
     * @param parameters Parameters supplied to the create or update FirewallPolicyRuleCollectionGroup
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, firewallPolicyName, ruleCollectionGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all FirewallPolicyRuleCollectionGroups in a FirewallPolicy resource.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    _list(resourceGroupName, firewallPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, options }, listOperationSpec$1g);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, firewallPolicyName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, nextLink, options }, listNextOperationSpec$14);
    }
}
// Operation Specifications
const serializer$1w = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/ruleCollectionGroups/{ruleCollectionGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName,
        ruleCollectionGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const getOperationSpec$1c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/ruleCollectionGroups/{ruleCollectionGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName,
        ruleCollectionGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const createOrUpdateOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/ruleCollectionGroups/{ruleCollectionGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        201: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        202: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        204: {
            bodyMapper: FirewallPolicyRuleCollectionGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters19,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName,
        ruleCollectionGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1w
};
const listOperationSpec$1g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/ruleCollectionGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyRuleCollectionGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};
const listNextOperationSpec$14 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FirewallPolicyRuleCollectionGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing FirewallPolicyIdpsSignatures operations. */
class FirewallPolicyIdpsSignaturesImpl {
    /**
     * Initialize a new instance of the class FirewallPolicyIdpsSignatures class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the current status of IDPS signatures for the relevant policy
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Will describe the query to run against the IDPS signatures DB
     * @param options The options parameters.
     */
    list(resourceGroupName, firewallPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, parameters, options }, listOperationSpec$1f);
    }
}
// Operation Specifications
const serializer$1v = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/listIdpsSignatures",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: QueryResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters20,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing FirewallPolicyIdpsSignaturesOverrides operations. */
class FirewallPolicyIdpsSignaturesOverridesImpl {
    /**
     * Initialize a new instance of the class FirewallPolicyIdpsSignaturesOverrides class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Will update the status of policy's signature overrides for IDPS
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Will contain all properties of the object to put
     * @param options The options parameters.
     */
    patch(resourceGroupName, firewallPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, parameters, options }, patchOperationSpec$1);
    }
    /**
     * Will override/create a new signature overrides for the policy's IDPS
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Will contain all properties of the object to put
     * @param options The options parameters.
     */
    put(resourceGroupName, firewallPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, parameters, options }, putOperationSpec);
    }
    /**
     * Returns all signatures overrides for a specific policy.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, firewallPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, options }, getOperationSpec$1b);
    }
    /**
     * Returns all signatures overrides objects for a specific policy as a list containing a single value.
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param options The options parameters.
     */
    list(resourceGroupName, firewallPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, options }, listOperationSpec$1e);
    }
}
// Operation Specifications
const serializer$1u = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const patchOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides/default",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SignaturesOverrides
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters21,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1u
};
const putOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides/default",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SignaturesOverrides
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters21,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1u
};
const getOperationSpec$1b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides/default",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SignaturesOverrides
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};
const listOperationSpec$1e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/signatureOverrides",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SignaturesOverridesList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$1u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing FirewallPolicyIdpsSignaturesFilterValues operations. */
class FirewallPolicyIdpsSignaturesFilterValuesImpl {
    /**
     * Initialize a new instance of the class FirewallPolicyIdpsSignaturesFilterValues class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the current filter values for the signatures overrides
     * @param resourceGroupName The name of the resource group.
     * @param firewallPolicyName The name of the Firewall Policy.
     * @param parameters Describes the filter values possibles for a given column
     * @param options The options parameters.
     */
    list(resourceGroupName, firewallPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, firewallPolicyName, parameters, options }, listOperationSpec$1d);
    }
}
// Operation Specifications
const serializer$1t = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$1d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/firewallPolicies/{firewallPolicyName}/listIdpsFilterOptions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SignatureOverridesFilterValuesResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters22,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        firewallPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IpAllocations operations. */
class IpAllocationsImpl {
    /**
     * Initialize a new instance of the class IpAllocations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all IpAllocations in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all IpAllocations in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified IpAllocation.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, ipAllocationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, ipAllocationName, options },
                spec: deleteOperationSpec$11
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified IpAllocation.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, ipAllocationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, ipAllocationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified IpAllocation by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param options The options parameters.
     */
    get(resourceGroupName, ipAllocationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ipAllocationName, options }, getOperationSpec$1a);
    }
    /**
     * Creates or updates an IpAllocation in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param parameters Parameters supplied to the create or update virtual network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, ipAllocationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, ipAllocationName, parameters, options },
                spec: createOrUpdateOperationSpec$11
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an IpAllocation in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param parameters Parameters supplied to the create or update virtual network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, ipAllocationName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, ipAllocationName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a IpAllocation tags.
     * @param resourceGroupName The name of the resource group.
     * @param ipAllocationName The name of the IpAllocation.
     * @param parameters Parameters supplied to update IpAllocation tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, ipAllocationName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ipAllocationName, parameters, options }, updateTagsOperationSpec$p);
    }
    /**
     * Gets all IpAllocations in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1c);
    }
    /**
     * Gets all IpAllocations in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$g);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$13);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$1s = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations/{ipAllocationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipAllocationName
    ],
    headerParameters: [accept],
    serializer: serializer$1s
};
const getOperationSpec$1a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations/{ipAllocationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipAllocationName
    ],
    headerParameters: [accept],
    serializer: serializer$1s
};
const createOrUpdateOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations/{ipAllocationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IpAllocation
        },
        201: {
            bodyMapper: IpAllocation
        },
        202: {
            bodyMapper: IpAllocation
        },
        204: {
            bodyMapper: IpAllocation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters23,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipAllocationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1s
};
const updateTagsOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations/{ipAllocationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IpAllocation
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipAllocationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1s
};
const listOperationSpec$1c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/IpAllocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1s
};
const listByResourceGroupOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/IpAllocations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1s
};
const listNextOperationSpec$13 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1s
};
const listByResourceGroupNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpAllocationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing IpGroups operations. */
class IpGroupsImpl {
    /**
     * Initialize a new instance of the class IpGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all IpGroups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all IpGroups in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the specified ipGroups.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param options The options parameters.
     */
    get(resourceGroupName, ipGroupsName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ipGroupsName, options }, getOperationSpec$19);
    }
    /**
     * Creates or updates an ipGroups in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param parameters Parameters supplied to the create or update IpGroups operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, ipGroupsName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, ipGroupsName, parameters, options },
                spec: createOrUpdateOperationSpec$10
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an ipGroups in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param parameters Parameters supplied to the create or update IpGroups operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, ipGroupsName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, ipGroupsName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of an IpGroups resource.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param parameters Parameters supplied to the update ipGroups operation.
     * @param options The options parameters.
     */
    updateGroups(resourceGroupName, ipGroupsName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, ipGroupsName, parameters, options }, updateGroupsOperationSpec);
    }
    /**
     * Deletes the specified ipGroups.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, ipGroupsName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, ipGroupsName, options },
                spec: deleteOperationSpec$10
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified ipGroups.
     * @param resourceGroupName The name of the resource group.
     * @param ipGroupsName The name of the ipGroups.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, ipGroupsName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, ipGroupsName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all IpGroups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$f);
    }
    /**
     * Gets all IpGroups in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$1b);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$e);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$12);
    }
}
// Operation Specifications
const serializer$1r = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$19 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups/{ipGroupsName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroup
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipGroupsName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const createOrUpdateOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups/{ipGroupsName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: IpGroup
        },
        201: {
            bodyMapper: IpGroup
        },
        202: {
            bodyMapper: IpGroup
        },
        204: {
            bodyMapper: IpGroup
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters24,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipGroupsName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1r
};
const updateGroupsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups/{ipGroupsName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: IpGroup
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipGroupsName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1r
};
const deleteOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups/{ipGroupsName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ipGroupsName
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const listByResourceGroupOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ipGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const listOperationSpec$1b = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ipGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1r
};
const listByResourceGroupNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};
const listNextOperationSpec$12 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IpGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancers operations. */
class LoadBalancersImpl {
    /**
     * Initialize a new instance of the class LoadBalancers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancers in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, loadBalancerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, loadBalancerName, options },
                spec: deleteOperationSpec$$
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, loadBalancerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, loadBalancerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, getOperationSpec$18);
    }
    /**
     * Creates or updates a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param parameters Parameters supplied to the create or update load balancer operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, loadBalancerName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, loadBalancerName, parameters, options },
                spec: createOrUpdateOperationSpec$$
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param parameters Parameters supplied to the create or update load balancer operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, loadBalancerName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, loadBalancerName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a load balancer tags.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param parameters Parameters supplied to update load balancer tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, loadBalancerName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, parameters, options }, updateTagsOperationSpec$o);
    }
    /**
     * Gets all the load balancers in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$9);
    }
    /**
     * Gets all the load balancers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$1a);
    }
    /**
     * Swaps VIPs between two load balancers.
     * @param location The region where load balancers are located at.
     * @param parameters Parameters that define which VIPs should be swapped.
     * @param options The options parameters.
     */
    beginSwapPublicIpAddresses(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { location, parameters, options },
                spec: swapPublicIpAddressesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Swaps VIPs between two load balancers.
     * @param location The region where load balancers are located at.
     * @param parameters Parameters that define which VIPs should be swapped.
     * @param options The options parameters.
     */
    beginSwapPublicIpAddressesAndWait(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSwapPublicIpAddresses(location, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * List of inbound NAT rule port mappings.
     * @param groupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendPoolName The name of the load balancer backend address pool.
     * @param parameters Query inbound NAT rule port mapping request.
     * @param options The options parameters.
     */
    beginListInboundNatRulePortMappings(groupName, loadBalancerName, backendPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    groupName,
                    loadBalancerName,
                    backendPoolName,
                    parameters,
                    options
                },
                spec: listInboundNatRulePortMappingsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * List of inbound NAT rule port mappings.
     * @param groupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendPoolName The name of the load balancer backend address pool.
     * @param parameters Query inbound NAT rule port mapping request.
     * @param options The options parameters.
     */
    beginListInboundNatRulePortMappingsAndWait(groupName, loadBalancerName, backendPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListInboundNatRulePortMappings(groupName, loadBalancerName, backendPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$8);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$11);
    }
}
// Operation Specifications
const serializer$1q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const getOperationSpec$18 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancer
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const createOrUpdateOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LoadBalancer
        },
        201: {
            bodyMapper: LoadBalancer
        },
        202: {
            bodyMapper: LoadBalancer
        },
        204: {
            bodyMapper: LoadBalancer
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters25,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1q
};
const updateTagsOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: LoadBalancer
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1q
};
const listAllOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/loadBalancers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1q
};
const listOperationSpec$1a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const swapPublicIpAddressesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/setLoadBalancerFrontendPublicIpAddresses",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters26,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1q
};
const listInboundNatRulePortMappingsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools/{backendPoolName}/queryInboundNatRulePortMapping",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BackendAddressInboundNatRulePortMappings
        },
        201: {
            bodyMapper: BackendAddressInboundNatRulePortMappings
        },
        202: {
            bodyMapper: BackendAddressInboundNatRulePortMappings
        },
        204: {
            bodyMapper: BackendAddressInboundNatRulePortMappings
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters27,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        groupName,
        loadBalancerName,
        backendPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1q
};
const listAllNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};
const listNextOperationSpec$11 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerBackendAddressPools operations. */
class LoadBalancerBackendAddressPoolsImpl {
    /**
     * Initialize a new instance of the class LoadBalancerBackendAddressPools class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancer backed address pools.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, loadBalancerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancer backed address pools.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$19);
    }
    /**
     * Gets load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, backendAddressPoolName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, backendAddressPoolName, options }, getOperationSpec$17);
    }
    /**
     * Creates or updates a load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param parameters Parameters supplied to the create or update load balancer backend address pool
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, loadBalancerName, backendAddressPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    loadBalancerName,
                    backendAddressPoolName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$_
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param parameters Parameters supplied to the create or update load balancer backend address pool
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, loadBalancerName, backendAddressPoolName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, loadBalancerName, backendAddressPoolName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes the specified load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, loadBalancerName, backendAddressPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    loadBalancerName,
                    backendAddressPoolName,
                    options
                },
                spec: deleteOperationSpec$_
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified load balancer backend address pool.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param backendAddressPoolName The name of the backend address pool.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, loadBalancerName, backendAddressPoolName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, loadBalancerName, backendAddressPoolName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$10);
    }
}
// Operation Specifications
const serializer$1p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$19 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerBackendAddressPoolListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};
const getOperationSpec$17 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools/{backendAddressPoolName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BackendAddressPool
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        backendAddressPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};
const createOrUpdateOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools/{backendAddressPoolName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BackendAddressPool
        },
        201: {
            bodyMapper: BackendAddressPool
        },
        202: {
            bodyMapper: BackendAddressPool
        },
        204: {
            bodyMapper: BackendAddressPool
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters28,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        backendAddressPoolName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1p
};
const deleteOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/backendAddressPools/{backendAddressPoolName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        backendAddressPoolName
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};
const listNextOperationSpec$10 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerBackendAddressPoolListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerFrontendIPConfigurations operations. */
class LoadBalancerFrontendIPConfigurationsImpl {
    /**
     * Initialize a new instance of the class LoadBalancerFrontendIPConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancer frontend IP configurations.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, loadBalancerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancer frontend IP configurations.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$18);
    }
    /**
     * Gets load balancer frontend IP configuration.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param frontendIPConfigurationName The name of the frontend IP configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, frontendIPConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            loadBalancerName,
            frontendIPConfigurationName,
            options
        }, getOperationSpec$16);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$$);
    }
}
// Operation Specifications
const serializer$1o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$18 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/frontendIPConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerFrontendIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};
const getOperationSpec$16 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/frontendIPConfigurations/{frontendIPConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FrontendIPConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        frontendIPConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};
const listNextOperationSpec$$ = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerFrontendIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing InboundNatRules operations. */
class InboundNatRulesImpl {
    /**
     * Initialize a new instance of the class InboundNatRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the inbound NAT rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, loadBalancerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the inbound NAT rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$17);
    }
    /**
     * Deletes the specified load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, loadBalancerName, inboundNatRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    loadBalancerName,
                    inboundNatRuleName,
                    options
                },
                spec: deleteOperationSpec$Z
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, loadBalancerName, inboundNatRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, loadBalancerName, inboundNatRuleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, inboundNatRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, inboundNatRuleName, options }, getOperationSpec$15);
    }
    /**
     * Creates or updates a load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param inboundNatRuleParameters Parameters supplied to the create or update inbound NAT rule
     *                                 operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, loadBalancerName, inboundNatRuleName, inboundNatRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    loadBalancerName,
                    inboundNatRuleName,
                    inboundNatRuleParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$Z
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a load balancer inbound NAT rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param inboundNatRuleName The name of the inbound NAT rule.
     * @param inboundNatRuleParameters Parameters supplied to the create or update inbound NAT rule
     *                                 operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, loadBalancerName, inboundNatRuleName, inboundNatRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, loadBalancerName, inboundNatRuleName, inboundNatRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$_);
    }
}
// Operation Specifications
const serializer$1n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$17 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/inboundNatRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundNatRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const deleteOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/inboundNatRules/{inboundNatRuleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        inboundNatRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const getOperationSpec$15 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/inboundNatRules/{inboundNatRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        inboundNatRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};
const createOrUpdateOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/inboundNatRules/{inboundNatRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: InboundNatRule
        },
        201: {
            bodyMapper: InboundNatRule
        },
        202: {
            bodyMapper: InboundNatRule
        },
        204: {
            bodyMapper: InboundNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: inboundNatRuleParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        inboundNatRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1n
};
const listNextOperationSpec$_ = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: InboundNatRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerLoadBalancingRules operations. */
class LoadBalancerLoadBalancingRulesImpl {
    /**
     * Initialize a new instance of the class LoadBalancerLoadBalancingRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancing rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, loadBalancerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancing rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$16);
    }
    /**
     * Gets the specified load balancer load balancing rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param loadBalancingRuleName The name of the load balancing rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, loadBalancingRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, loadBalancingRuleName, options }, getOperationSpec$14);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$Z);
    }
}
// Operation Specifications
const serializer$1m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$16 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/loadBalancingRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerLoadBalancingRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};
const getOperationSpec$14 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/loadBalancingRules/{loadBalancingRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancingRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        loadBalancingRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};
const listNextOperationSpec$Z = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerLoadBalancingRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerOutboundRules operations. */
class LoadBalancerOutboundRulesImpl {
    /**
     * Initialize a new instance of the class LoadBalancerOutboundRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the outbound rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, loadBalancerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the outbound rules in a load balancer.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$15);
    }
    /**
     * Gets the specified load balancer outbound rule.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param outboundRuleName The name of the outbound rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, outboundRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, outboundRuleName, options }, getOperationSpec$13);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$Y);
    }
}
// Operation Specifications
const serializer$1l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$15 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/outboundRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerOutboundRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};
const getOperationSpec$13 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/outboundRules/{outboundRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OutboundRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        outboundRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};
const listNextOperationSpec$Y = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerOutboundRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerNetworkInterfaces operations. */
class LoadBalancerNetworkInterfacesImpl {
    /**
     * Initialize a new instance of the class LoadBalancerNetworkInterfaces class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets associated load balancer network interfaces.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, loadBalancerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets associated load balancer network interfaces.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$14);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$X);
    }
}
// Operation Specifications
const serializer$1k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$14 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/networkInterfaces",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1k
};
const listNextOperationSpec$X = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LoadBalancerProbes operations. */
class LoadBalancerProbesImpl {
    /**
     * Initialize a new instance of the class LoadBalancerProbes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the load balancer probes.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    list(resourceGroupName, loadBalancerName, options) {
        const iter = this.listPagingAll(resourceGroupName, loadBalancerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, loadBalancerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, loadBalancerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, loadBalancerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, loadBalancerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, loadBalancerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, loadBalancerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the load balancer probes.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param options The options parameters.
     */
    _list(resourceGroupName, loadBalancerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, options }, listOperationSpec$13);
    }
    /**
     * Gets load balancer probe.
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param probeName The name of the probe.
     * @param options The options parameters.
     */
    get(resourceGroupName, loadBalancerName, probeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, probeName, options }, getOperationSpec$12);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param loadBalancerName The name of the load balancer.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, loadBalancerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, loadBalancerName, nextLink, options }, listNextOperationSpec$W);
    }
}
// Operation Specifications
const serializer$1j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$13 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerProbeListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};
const getOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Probe
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        loadBalancerName,
        probeName
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};
const listNextOperationSpec$W = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LoadBalancerProbeListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        loadBalancerName
    ],
    headerParameters: [accept],
    serializer: serializer$1j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NatGateways operations. */
class NatGatewaysImpl {
    /**
     * Initialize a new instance of the class NatGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the Nat Gateways in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all nat gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified nat gateway.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, natGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, natGatewayName, options },
                spec: deleteOperationSpec$Y
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified nat gateway.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, natGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, natGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified nat gateway in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, natGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, natGatewayName, options }, getOperationSpec$11);
    }
    /**
     * Creates or updates a nat gateway.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param parameters Parameters supplied to the create or update nat gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, natGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, natGatewayName, parameters, options },
                spec: createOrUpdateOperationSpec$Y
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a nat gateway.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param parameters Parameters supplied to the create or update nat gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, natGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, natGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates nat gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param natGatewayName The name of the nat gateway.
     * @param parameters Parameters supplied to update nat gateway tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, natGatewayName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, natGatewayName, parameters, options }, updateTagsOperationSpec$n);
    }
    /**
     * Gets all the Nat Gateways in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$8);
    }
    /**
     * Gets all nat gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$12);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$7);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$V);
    }
}
// Operation Specifications
const serializer$1i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$Y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways/{natGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const getOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways/{natGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const createOrUpdateOperationSpec$Y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways/{natGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NatGateway
        },
        201: {
            bodyMapper: NatGateway
        },
        202: {
            bodyMapper: NatGateway
        },
        204: {
            bodyMapper: NatGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters29,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const updateTagsOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways/{natGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NatGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1i
};
const listAllOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/natGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1i
};
const listOperationSpec$12 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/natGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const listAllNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};
const listNextOperationSpec$V = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NatGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkInterfaceIPConfigurations operations. */
class NetworkInterfaceIPConfigurationsImpl {
    /**
     * Initialize a new instance of the class NetworkInterfaceIPConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all ip configurations in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkInterfaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkInterfaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkInterfaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkInterfaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkInterfaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkInterfaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkInterfaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Get all ip configurations in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, options }, listOperationSpec$11);
    }
    /**
     * Gets the specified network interface ip configuration.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param ipConfigurationName The name of the ip configuration name.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkInterfaceName, ipConfigurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, ipConfigurationName, options }, getOperationSpec$10);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkInterfaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, nextLink, options }, listNextOperationSpec$U);
    }
}
// Operation Specifications
const serializer$1h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$11 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/ipConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1h
};
const getOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/ipConfigurations/{ipConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        ipConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1h
};
const listNextOperationSpec$U = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceIPConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkInterfaceLoadBalancers operations. */
class NetworkInterfaceLoadBalancersImpl {
    /**
     * Initialize a new instance of the class NetworkInterfaceLoadBalancers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all load balancers in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkInterfaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkInterfaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkInterfaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkInterfaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkInterfaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkInterfaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkInterfaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all load balancers in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, options }, listOperationSpec$10);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkInterfaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, nextLink, options }, listNextOperationSpec$T);
    }
}
// Operation Specifications
const serializer$1g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$10 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/loadBalancers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceLoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1g
};
const listNextOperationSpec$T = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceLoadBalancerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkInterfaceTapConfigurations operations. */
class NetworkInterfaceTapConfigurationsImpl {
    /**
     * Initialize a new instance of the class NetworkInterfaceTapConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Get all Tap configurations in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkInterfaceName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkInterfaceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkInterfaceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkInterfaceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkInterfaceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkInterfaceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkInterfaceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkInterfaceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified tap configuration from the NetworkInterface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkInterfaceName, tapConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkInterfaceName,
                    tapConfigurationName,
                    options
                },
                spec: deleteOperationSpec$X
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified tap configuration from the NetworkInterface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkInterfaceName, tapConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkInterfaceName, tapConfigurationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the specified tap configuration on a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkInterfaceName, tapConfigurationName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkInterfaceName,
            tapConfigurationName,
            options
        }, getOperationSpec$$);
    }
    /**
     * Creates or updates a Tap configuration in the specified NetworkInterface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param tapConfigurationParameters Parameters supplied to the create or update tap configuration
     *                                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkInterfaceName, tapConfigurationName, tapConfigurationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkInterfaceName,
                    tapConfigurationName,
                    tapConfigurationParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$X
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a Tap configuration in the specified NetworkInterface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param tapConfigurationName The name of the tap configuration.
     * @param tapConfigurationParameters Parameters supplied to the create or update tap configuration
     *                                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkInterfaceName, tapConfigurationName, tapConfigurationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkInterfaceName, tapConfigurationName, tapConfigurationParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get all Tap configurations in a network interface.
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkInterfaceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, options }, listOperationSpec$$);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkInterfaceName The name of the network interface.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkInterfaceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkInterfaceName, nextLink, options }, listNextOperationSpec$S);
    }
}
// Operation Specifications
const serializer$1f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$X = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/tapConfigurations/{tapConfigurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        tapConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1f
};
const getOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/tapConfigurations/{tapConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        tapConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$1f
};
const createOrUpdateOperationSpec$X = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/tapConfigurations/{tapConfigurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        201: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        202: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        204: {
            bodyMapper: NetworkInterfaceTapConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: tapConfigurationParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName,
        tapConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1f
};
const listOperationSpec$$ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkInterfaces/{networkInterfaceName}/tapConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceTapConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1f
};
const listNextOperationSpec$S = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkInterfaceTapConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkInterfaceName
    ],
    headerParameters: [accept],
    serializer: serializer$1f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkManagers operations. */
class NetworkManagersImpl {
    /**
     * Initialize a new instance of the class NetworkManagers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all network managers in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List network managers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the specified Network Manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkManagerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, options }, getOperationSpec$_);
    }
    /**
     * Creates or updates a Network Manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Parameters supplied to specify which network manager is.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkManagerName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, parameters, options }, createOrUpdateOperationSpec$W);
    }
    /**
     * Deletes a network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkManagerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkManagerName, options },
                spec: deleteOperationSpec$W
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkManagerName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkManagerName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Patch NetworkManager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Parameters supplied to specify which network manager is.
     * @param options The options parameters.
     */
    patch(resourceGroupName, networkManagerName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, parameters, options }, patchOperationSpec);
    }
    /**
     * List all network managers in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$3);
    }
    /**
     * List network managers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$_);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$R);
    }
}
// Operation Specifications
const serializer$1e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManager
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};
const createOrUpdateOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkManager
        },
        201: {
            bodyMapper: NetworkManager
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters30,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1e
};
const deleteOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};
const patchOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkManager
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters31,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1e
};
const listBySubscriptionOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkManagers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1e
};
const listOperationSpec$_ = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};
const listBySubscriptionNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};
const listNextOperationSpec$R = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing NetworkManagerCommits operations. */
class NetworkManagerCommitsImpl {
    /**
     * Initialize a new instance of the class NetworkManagerCommits class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Post a Network Manager Commit.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Parameters supplied to specify which Managed Network commit is.
     * @param options The options parameters.
     */
    beginPost(resourceGroupName, networkManagerName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkManagerName, parameters, options },
                spec: postOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Post a Network Manager Commit.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Parameters supplied to specify which Managed Network commit is.
     * @param options The options parameters.
     */
    beginPostAndWait(resourceGroupName, networkManagerName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPost(resourceGroupName, networkManagerName, parameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$1d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const postOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/commit",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NetworkManagerCommit
        },
        201: {
            bodyMapper: NetworkManagerCommit
        },
        202: {
            bodyMapper: NetworkManagerCommit
        },
        204: {
            bodyMapper: NetworkManagerCommit
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters32,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing NetworkManagerDeploymentStatusOperations operations. */
class NetworkManagerDeploymentStatusOperationsImpl {
    /**
     * Initialize a new instance of the class NetworkManagerDeploymentStatusOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Post to List of Network Manager Deployment Status.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Parameters supplied to specify which Managed Network deployment status is.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkManagerName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, parameters, options }, listOperationSpec$Z);
    }
}
// Operation Specifications
const serializer$1c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/listDeploymentStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NetworkManagerDeploymentStatusListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters33,
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SubscriptionNetworkManagerConnections operations. */
class SubscriptionNetworkManagerConnectionsImpl {
    /**
     * Initialize a new instance of the class SubscriptionNetworkManagerConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all network manager connections created by this subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create a network manager connection on this subscription.
     * @param networkManagerConnectionName Name for the network manager connection.
     * @param parameters Network manager connection to be created/updated.
     * @param options The options parameters.
     */
    createOrUpdate(networkManagerConnectionName, parameters, options) {
        return this.client.sendOperationRequest({ networkManagerConnectionName, parameters, options }, createOrUpdateOperationSpec$V);
    }
    /**
     * Get a specified connection created by this subscription.
     * @param networkManagerConnectionName Name for the network manager connection.
     * @param options The options parameters.
     */
    get(networkManagerConnectionName, options) {
        return this.client.sendOperationRequest({ networkManagerConnectionName, options }, getOperationSpec$Z);
    }
    /**
     * Delete specified connection created by this subscription.
     * @param networkManagerConnectionName Name for the network manager connection.
     * @param options The options parameters.
     */
    delete(networkManagerConnectionName, options) {
        return this.client.sendOperationRequest({ networkManagerConnectionName, options }, deleteOperationSpec$V);
    }
    /**
     * List all network manager connections created by this subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$Y);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$Q);
    }
}
// Operation Specifications
const serializer$1b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkManagerConnections/{networkManagerConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkManagerConnection
        },
        201: {
            bodyMapper: NetworkManagerConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters34,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        networkManagerConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1b
};
const getOperationSpec$Z = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkManagerConnections/{networkManagerConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        networkManagerConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1b
};
const deleteOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkManagerConnections/{networkManagerConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        networkManagerConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$1b
};
const listOperationSpec$Y = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkManagerConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1b
};
const listNextOperationSpec$Q = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ManagementGroupNetworkManagerConnections operations. */
class ManagementGroupNetworkManagerConnectionsImpl {
    /**
     * Initialize a new instance of the class ManagementGroupNetworkManagerConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all network manager connections created by this management group.
     * @param managementGroupId The management group Id which uniquely identify the Microsoft Azure
     *                          management group.
     * @param options The options parameters.
     */
    list(managementGroupId, options) {
        const iter = this.listPagingAll(managementGroupId, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(managementGroupId, options, settings);
            }
        };
    }
    listPagingPage(managementGroupId, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(managementGroupId, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(managementGroupId, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(managementGroupId, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(managementGroupId, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create a network manager connection on this management group.
     * @param managementGroupId The management group Id which uniquely identify the Microsoft Azure
     *                          management group.
     * @param networkManagerConnectionName Name for the network manager connection.
     * @param parameters Network manager connection to be created/updated.
     * @param options The options parameters.
     */
    createOrUpdate(managementGroupId, networkManagerConnectionName, parameters, options) {
        return this.client.sendOperationRequest({ managementGroupId, networkManagerConnectionName, parameters, options }, createOrUpdateOperationSpec$U);
    }
    /**
     * Get a specified connection created by this management group.
     * @param managementGroupId The management group Id which uniquely identify the Microsoft Azure
     *                          management group.
     * @param networkManagerConnectionName Name for the network manager connection.
     * @param options The options parameters.
     */
    get(managementGroupId, networkManagerConnectionName, options) {
        return this.client.sendOperationRequest({ managementGroupId, networkManagerConnectionName, options }, getOperationSpec$Y);
    }
    /**
     * Delete specified pending connection created by this management group.
     * @param managementGroupId The management group Id which uniquely identify the Microsoft Azure
     *                          management group.
     * @param networkManagerConnectionName Name for the network manager connection.
     * @param options The options parameters.
     */
    delete(managementGroupId, networkManagerConnectionName, options) {
        return this.client.sendOperationRequest({ managementGroupId, networkManagerConnectionName, options }, deleteOperationSpec$U);
    }
    /**
     * List all network manager connections created by this management group.
     * @param managementGroupId The management group Id which uniquely identify the Microsoft Azure
     *                          management group.
     * @param options The options parameters.
     */
    _list(managementGroupId, options) {
        return this.client.sendOperationRequest({ managementGroupId, options }, listOperationSpec$X);
    }
    /**
     * ListNext
     * @param managementGroupId The management group Id which uniquely identify the Microsoft Azure
     *                          management group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(managementGroupId, nextLink, options) {
        return this.client.sendOperationRequest({ managementGroupId, nextLink, options }, listNextOperationSpec$P);
    }
}
// Operation Specifications
const serializer$1a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$U = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Network/networkManagerConnections/{networkManagerConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkManagerConnection
        },
        201: {
            bodyMapper: NetworkManagerConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters34,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        networkManagerConnectionName,
        managementGroupId
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1a
};
const getOperationSpec$Y = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Network/networkManagerConnections/{networkManagerConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        networkManagerConnectionName,
        managementGroupId
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};
const deleteOperationSpec$U = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Network/networkManagerConnections/{networkManagerConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        networkManagerConnectionName,
        managementGroupId
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};
const listOperationSpec$X = {
    path: "/providers/Microsoft.Management/managementGroups/{managementGroupId}/providers/Microsoft.Network/networkManagerConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [$host, managementGroupId],
    headerParameters: [accept],
    serializer: serializer$1a
};
const listNextOperationSpec$P = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkManagerConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        nextLink,
        managementGroupId
    ],
    headerParameters: [accept],
    serializer: serializer$1a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ConnectivityConfigurations operations. */
class ConnectivityConfigurationsImpl {
    /**
     * Initialize a new instance of the class ConnectivityConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the network manager connectivity configuration in a specified network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkManagerName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkManagerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkManagerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkManagerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkManagerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkManagerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkManagerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkManagerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a Network Connectivity Configuration, specified by the resource group, network manager name,
     * and connectivity Configuration name
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager connectivity configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkManagerName, configurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, configurationName, options }, getOperationSpec$X);
    }
    /**
     * Creates/Updates a new network manager connectivity configuration
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager connectivity configuration.
     * @param connectivityConfiguration Parameters supplied to create/update a network manager connectivity
     *                                  configuration
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkManagerName, configurationName, connectivityConfiguration, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            configurationName,
            connectivityConfiguration,
            options
        }, createOrUpdateOperationSpec$T);
    }
    /**
     * Deletes a network manager connectivity configuration, specified by the resource group, network
     * manager name, and connectivity configuration name
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager connectivity configuration.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkManagerName, configurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkManagerName,
                    configurationName,
                    options
                },
                spec: deleteOperationSpec$T
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a network manager connectivity configuration, specified by the resource group, network
     * manager name, and connectivity configuration name
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager connectivity configuration.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkManagerName, configurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkManagerName, configurationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the network manager connectivity configuration in a specified network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkManagerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, options }, listOperationSpec$W);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkManagerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, nextLink, options }, listNextOperationSpec$O);
    }
}
// Operation Specifications
const serializer$19 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$X = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/connectivityConfigurations/{configurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectivityConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};
const createOrUpdateOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/connectivityConfigurations/{configurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectivityConfiguration
        },
        201: {
            bodyMapper: ConnectivityConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: connectivityConfiguration,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$19
};
const deleteOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/connectivityConfigurations/{configurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};
const listOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/connectivityConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectivityConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};
const listNextOperationSpec$O = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectivityConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$19
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkGroups operations. */
class NetworkGroupsImpl {
    /**
     * Initialize a new instance of the class NetworkGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the specified network group.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkManagerName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkManagerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkManagerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkManagerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkManagerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkManagerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkManagerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkManagerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the specified network group.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkManagerName, networkGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, networkGroupName, options }, getOperationSpec$W);
    }
    /**
     * Creates or updates a network group.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param parameters Parameters supplied to the specify which network group need to create
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkManagerName, networkGroupName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            networkGroupName,
            parameters,
            options
        }, createOrUpdateOperationSpec$S);
    }
    /**
     * Deletes a network group.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkManagerName, networkGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkManagerName,
                    networkGroupName,
                    options
                },
                spec: deleteOperationSpec$S
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a network group.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkManagerName, networkGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkManagerName, networkGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists the specified network group.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkManagerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, options }, listOperationSpec$V);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkManagerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, nextLink, options }, listNextOperationSpec$N);
    }
}
// Operation Specifications
const serializer$18 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$W = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/networkGroups/{networkGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        networkGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const createOrUpdateOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/networkGroups/{networkGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkGroup,
            headersMapper: NetworkGroupsCreateOrUpdateHeaders
        },
        201: {
            bodyMapper: NetworkGroup,
            headersMapper: NetworkGroupsCreateOrUpdateHeaders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters35,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        networkGroupName
    ],
    headerParameters: [
        accept,
        contentType,
        ifMatch
    ],
    mediaType: "json",
    serializer: serializer$18
};
const deleteOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/networkGroups/{networkGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        networkGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const listOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/networkGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$18
};
const listNextOperationSpec$N = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$18
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing StaticMembers operations. */
class StaticMembersImpl {
    /**
     * Initialize a new instance of the class StaticMembers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists the specified static member.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkManagerName, networkGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkManagerName, networkGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkManagerName, networkGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkManagerName, networkGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkManagerName, networkGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkManagerName, networkGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkManagerName, networkGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkManagerName, networkGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the specified static member.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param staticMemberName The name of the static member.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkManagerName, networkGroupName, staticMemberName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            networkGroupName,
            staticMemberName,
            options
        }, getOperationSpec$V);
    }
    /**
     * Creates or updates a static member.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param staticMemberName The name of the static member.
     * @param parameters Parameters supplied to the specify the static member to create
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkManagerName, networkGroupName, staticMemberName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            networkGroupName,
            staticMemberName,
            parameters,
            options
        }, createOrUpdateOperationSpec$R);
    }
    /**
     * Deletes a static member.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param staticMemberName The name of the static member.
     * @param options The options parameters.
     */
    delete(resourceGroupName, networkManagerName, networkGroupName, staticMemberName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            networkGroupName,
            staticMemberName,
            options
        }, deleteOperationSpec$R);
    }
    /**
     * Lists the specified static member.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkManagerName, networkGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, networkGroupName, options }, listOperationSpec$U);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param networkGroupName The name of the network group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkManagerName, networkGroupName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            networkGroupName,
            nextLink,
            options
        }, listNextOperationSpec$M);
    }
}
// Operation Specifications
const serializer$17 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$V = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/networkGroups/{networkGroupName}/staticMembers/{staticMemberName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticMember
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        networkGroupName,
        staticMemberName
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const createOrUpdateOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/networkGroups/{networkGroupName}/staticMembers/{staticMemberName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: StaticMember
        },
        201: {
            bodyMapper: StaticMember
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters36,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        networkGroupName,
        staticMemberName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$17
};
const deleteOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/networkGroups/{networkGroupName}/staticMembers/{staticMemberName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        networkGroupName,
        staticMemberName
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const listOperationSpec$U = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/networkGroups/{networkGroupName}/staticMembers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticMemberListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        networkGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$17
};
const listNextOperationSpec$M = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: StaticMemberListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkManagerName,
        networkGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$17
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ScopeConnections operations. */
class ScopeConnectionsImpl {
    /**
     * Initialize a new instance of the class ScopeConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all scope connections created by this network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkManagerName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkManagerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkManagerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkManagerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkManagerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkManagerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkManagerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkManagerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates or updates scope connection from Network Manager
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param scopeConnectionName Name for the cross-tenant connection.
     * @param parameters Scope connection to be created/updated.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkManagerName, scopeConnectionName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            scopeConnectionName,
            parameters,
            options
        }, createOrUpdateOperationSpec$Q);
    }
    /**
     * Get specified scope connection created by this Network Manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param scopeConnectionName Name for the cross-tenant connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkManagerName, scopeConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, scopeConnectionName, options }, getOperationSpec$U);
    }
    /**
     * Delete the pending scope connection created by this network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param scopeConnectionName Name for the cross-tenant connection.
     * @param options The options parameters.
     */
    delete(resourceGroupName, networkManagerName, scopeConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, scopeConnectionName, options }, deleteOperationSpec$Q);
    }
    /**
     * List all scope connections created by this network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkManagerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, options }, listOperationSpec$T);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkManagerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, nextLink, options }, listNextOperationSpec$L);
    }
}
// Operation Specifications
const serializer$16 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/scopeConnections/{scopeConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ScopeConnection
        },
        201: {
            bodyMapper: ScopeConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters37,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        scopeConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$16
};
const getOperationSpec$U = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/scopeConnections/{scopeConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScopeConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        scopeConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const deleteOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/scopeConnections/{scopeConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        scopeConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const listOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/scopeConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScopeConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$16
};
const listNextOperationSpec$L = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ScopeConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$16
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecurityAdminConfigurations operations. */
class SecurityAdminConfigurationsImpl {
    /**
     * Initialize a new instance of the class SecurityAdminConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the network manager security admin configurations in a network manager, in a paginated
     * format.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkManagerName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkManagerName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkManagerName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkManagerName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkManagerName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkManagerName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkManagerName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkManagerName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the network manager security admin configurations in a network manager, in a paginated
     * format.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkManagerName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, options }, listOperationSpec$S);
    }
    /**
     * Retrieves a network manager security admin configuration.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkManagerName, configurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, configurationName, options }, getOperationSpec$T);
    }
    /**
     * Creates or updates a network manager security admin configuration.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param securityAdminConfiguration The security admin configuration to create or update
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkManagerName, configurationName, securityAdminConfiguration, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            configurationName,
            securityAdminConfiguration,
            options
        }, createOrUpdateOperationSpec$P);
    }
    /**
     * Deletes a network manager security admin configuration.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkManagerName, configurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkManagerName,
                    configurationName,
                    options
                },
                spec: deleteOperationSpec$P
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a network manager security admin configuration.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkManagerName, configurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkManagerName, configurationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkManagerName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, nextLink, options }, listNextOperationSpec$K);
    }
}
// Operation Specifications
const serializer$15 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAdminConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const getOperationSpec$T = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAdminConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const createOrUpdateOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityAdminConfiguration
        },
        201: {
            bodyMapper: SecurityAdminConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: securityAdminConfiguration,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$15
};
const deleteOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};
const listNextOperationSpec$K = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityAdminConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkManagerName
    ],
    headerParameters: [accept],
    serializer: serializer$15
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AdminRuleCollections operations. */
class AdminRuleCollectionsImpl {
    /**
     * Initialize a new instance of the class AdminRuleCollections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the rule collections in a security admin configuration, in a paginated format.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkManagerName, configurationName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkManagerName, configurationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkManagerName, configurationName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkManagerName, configurationName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkManagerName, configurationName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkManagerName, configurationName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkManagerName, configurationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkManagerName, configurationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the rule collections in a security admin configuration, in a paginated format.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkManagerName, configurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkManagerName, configurationName, options }, listOperationSpec$R);
    }
    /**
     * Gets a network manager security admin configuration rule collection.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            configurationName,
            ruleCollectionName,
            options
        }, getOperationSpec$S);
    }
    /**
     * Creates or updates an admin rule collection.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param ruleCollection The Rule Collection to create or update
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, ruleCollection, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            configurationName,
            ruleCollectionName,
            ruleCollection,
            options
        }, createOrUpdateOperationSpec$O);
    }
    /**
     * Deletes an admin rule collection.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkManagerName,
                    configurationName,
                    ruleCollectionName,
                    options
                },
                spec: deleteOperationSpec$O
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an admin rule collection.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkManagerName, configurationName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            configurationName,
            nextLink,
            options
        }, listNextOperationSpec$J);
    }
}
// Operation Specifications
const serializer$14 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}/ruleCollections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdminRuleCollectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const getOperationSpec$S = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdminRuleCollection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName,
        ruleCollectionName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const createOrUpdateOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: AdminRuleCollection
        },
        201: {
            bodyMapper: AdminRuleCollection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: ruleCollection,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName,
        ruleCollectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$14
};
const deleteOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName,
        ruleCollectionName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};
const listNextOperationSpec$J = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdminRuleCollectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkManagerName,
        configurationName
    ],
    headerParameters: [accept],
    serializer: serializer$14
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AdminRules operations. */
class AdminRulesImpl {
    /**
     * Initialize a new instance of the class AdminRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all network manager security configuration admin rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all network manager security configuration admin rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            configurationName,
            ruleCollectionName,
            options
        }, listOperationSpec$Q);
    }
    /**
     * Gets a network manager security configuration admin rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param ruleName The name of the rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, ruleName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            configurationName,
            ruleCollectionName,
            ruleName,
            options
        }, getOperationSpec$R);
    }
    /**
     * Creates or updates an admin rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param ruleName The name of the rule.
     * @param adminRule The admin rule to create or update
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, ruleName, adminRule, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            configurationName,
            ruleCollectionName,
            ruleName,
            adminRule,
            options
        }, createOrUpdateOperationSpec$N);
    }
    /**
     * Deletes an admin rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param ruleName The name of the rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkManagerName,
                    configurationName,
                    ruleCollectionName,
                    ruleName,
                    options
                },
                spec: deleteOperationSpec$N
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes an admin rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param ruleName The name of the rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, ruleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param configurationName The name of the network manager Security Configuration.
     * @param ruleCollectionName The name of the network manager security Configuration rule collection.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkManagerName, configurationName, ruleCollectionName, nextLink, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkManagerName,
            configurationName,
            ruleCollectionName,
            nextLink,
            options
        }, listNextOperationSpec$I);
    }
}
// Operation Specifications
const serializer$13 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}/rules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdminRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top,
        skipToken
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName,
        ruleCollectionName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const getOperationSpec$R = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}/rules/{ruleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BaseAdminRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName,
        ruleCollectionName,
        ruleName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const createOrUpdateOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}/rules/{ruleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BaseAdminRule
        },
        201: {
            bodyMapper: BaseAdminRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: adminRule,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName,
        ruleCollectionName,
        ruleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$13
};
const deleteOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/securityAdminConfigurations/{configurationName}/ruleCollections/{ruleCollectionName}/rules/{ruleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, force],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName,
        configurationName,
        ruleCollectionName,
        ruleName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};
const listNextOperationSpec$I = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AdminRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkManagerName,
        configurationName,
        ruleCollectionName
    ],
    headerParameters: [accept],
    serializer: serializer$13
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkProfiles operations. */
class NetworkProfilesImpl {
    /**
     * Initialize a new instance of the class NetworkProfiles class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the network profiles in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all network profiles in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified network profile.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the NetworkProfile.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkProfileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkProfileName, options },
                spec: deleteOperationSpec$M
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified network profile.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the NetworkProfile.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkProfileName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkProfileName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified network profile in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the public IP prefix.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkProfileName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkProfileName, options }, getOperationSpec$Q);
    }
    /**
     * Creates or updates a network profile.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the network profile.
     * @param parameters Parameters supplied to the create or update network profile operation.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkProfileName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkProfileName, parameters, options }, createOrUpdateOperationSpec$M);
    }
    /**
     * Updates network profile tags.
     * @param resourceGroupName The name of the resource group.
     * @param networkProfileName The name of the network profile.
     * @param parameters Parameters supplied to update network profile tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkProfileName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkProfileName, parameters, options }, updateTagsOperationSpec$m);
    }
    /**
     * Gets all the network profiles in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$7);
    }
    /**
     * Gets all network profiles in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$P);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$6);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$H);
    }
}
// Operation Specifications
const serializer$12 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles/{networkProfileName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkProfileName
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const getOperationSpec$Q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles/{networkProfileName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfile
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkProfileName
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const createOrUpdateOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles/{networkProfileName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkProfile
        },
        201: {
            bodyMapper: NetworkProfile
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters38,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkProfileName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$12
};
const updateTagsOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles/{networkProfileName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkProfile
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkProfileName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$12
};
const listAllOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfileListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$12
};
const listOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkProfiles",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfileListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const listAllNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfileListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$12
};
const listNextOperationSpec$H = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkProfileListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$12
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkSecurityGroups operations. */
class NetworkSecurityGroupsImpl {
    /**
     * Initialize a new instance of the class NetworkSecurityGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all network security groups in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all network security groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkSecurityGroupName, options },
                spec: deleteOperationSpec$L
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkSecurityGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, options }, getOperationSpec$P);
    }
    /**
     * Creates or updates a network security group in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param parameters Parameters supplied to the create or update network security group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkSecurityGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkSecurityGroupName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$L
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a network security group in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param parameters Parameters supplied to the create or update network security group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkSecurityGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkSecurityGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a network security group tags.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param parameters Parameters supplied to update network security group tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkSecurityGroupName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, parameters, options }, updateTagsOperationSpec$l);
    }
    /**
     * Gets all network security groups in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$6);
    }
    /**
     * Gets all network security groups in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$O);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$5);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$G);
    }
}
// Operation Specifications
const serializer$11 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const getOperationSpec$P = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const createOrUpdateOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroup
        },
        201: {
            bodyMapper: NetworkSecurityGroup
        },
        202: {
            bodyMapper: NetworkSecurityGroup
        },
        204: {
            bodyMapper: NetworkSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters39,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$11
};
const updateTagsOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$11
};
const listAllOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkSecurityGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$11
};
const listOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const listAllNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$11
};
const listNextOperationSpec$G = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkSecurityGroupListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$11
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecurityRules operations. */
class SecurityRulesImpl {
    /**
     * Initialize a new instance of the class SecurityRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all security rules in a network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkSecurityGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkSecurityGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkSecurityGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkSecurityGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkSecurityGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkSecurityGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkSecurityGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified network security rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkSecurityGroupName, securityRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkSecurityGroupName,
                    securityRuleName,
                    options
                },
                spec: deleteOperationSpec$K
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified network security rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkSecurityGroupName, securityRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkSecurityGroupName, securityRuleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the specified network security rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkSecurityGroupName, securityRuleName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkSecurityGroupName,
            securityRuleName,
            options
        }, getOperationSpec$O);
    }
    /**
     * Creates or updates a security rule in the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param securityRuleParameters Parameters supplied to the create or update network security rule
     *                               operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkSecurityGroupName, securityRuleName, securityRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkSecurityGroupName,
                    securityRuleName,
                    securityRuleParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$K
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a security rule in the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param securityRuleName The name of the security rule.
     * @param securityRuleParameters Parameters supplied to the create or update network security rule
     *                               operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkSecurityGroupName, securityRuleName, securityRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkSecurityGroupName, securityRuleName, securityRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all security rules in a network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, options }, listOperationSpec$N);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkSecurityGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, nextLink, options }, listNextOperationSpec$F);
    }
}
// Operation Specifications
const serializer$10 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/securityRules/{securityRuleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName,
        securityRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const getOperationSpec$O = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/securityRules/{securityRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName,
        securityRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const createOrUpdateOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/securityRules/{securityRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityRule
        },
        201: {
            bodyMapper: SecurityRule
        },
        202: {
            bodyMapper: SecurityRule
        },
        204: {
            bodyMapper: SecurityRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: securityRuleParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName,
        securityRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$10
};
const listOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/securityRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};
const listNextOperationSpec$F = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$10
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing DefaultSecurityRules operations. */
class DefaultSecurityRulesImpl {
    /**
     * Initialize a new instance of the class DefaultSecurityRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all default security rules in a network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkSecurityGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkSecurityGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkSecurityGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkSecurityGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkSecurityGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkSecurityGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkSecurityGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkSecurityGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all default security rules in a network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkSecurityGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, options }, listOperationSpec$M);
    }
    /**
     * Get the specified default network security rule.
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param defaultSecurityRuleName The name of the default security rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkSecurityGroupName, defaultSecurityRuleName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkSecurityGroupName,
            defaultSecurityRuleName,
            options
        }, getOperationSpec$N);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkSecurityGroupName The name of the network security group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkSecurityGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkSecurityGroupName, nextLink, options }, listNextOperationSpec$E);
    }
}
// Operation Specifications
const serializer$$ = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/defaultSecurityRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const getOperationSpec$N = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkSecurityGroups/{networkSecurityGroupName}/defaultSecurityRules/{defaultSecurityRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkSecurityGroupName,
        defaultSecurityRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};
const listNextOperationSpec$E = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkSecurityGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$$
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkVirtualAppliances operations. */
class NetworkVirtualAppliancesImpl {
    /**
     * Initialize a new instance of the class NetworkVirtualAppliances class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Network Virtual Appliances in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all Network Virtual Appliances in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkVirtualApplianceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkVirtualApplianceName, options },
                spec: deleteOperationSpec$J
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkVirtualApplianceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkVirtualApplianceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkVirtualApplianceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, options }, getOperationSpec$M);
    }
    /**
     * Updates a Network Virtual Appliance.
     * @param resourceGroupName The resource group name of Network Virtual Appliance.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance being updated.
     * @param parameters Parameters supplied to Update Network Virtual Appliance Tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkVirtualApplianceName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, parameters, options }, updateTagsOperationSpec$k);
    }
    /**
     * Creates or updates the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkVirtualApplianceName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$J
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified Network Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of Network Virtual Appliance.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkVirtualApplianceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Network Virtual Appliances in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$e);
    }
    /**
     * Gets all Network Virtual Appliances in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$L);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$d);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$D);
    }
}
// Operation Specifications
const serializer$_ = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const getOperationSpec$M = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualAppliance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const updateTagsOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkVirtualAppliance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$_
};
const createOrUpdateOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkVirtualAppliance
        },
        201: {
            bodyMapper: NetworkVirtualAppliance
        },
        202: {
            bodyMapper: NetworkVirtualAppliance
        },
        204: {
            bodyMapper: NetworkVirtualAppliance
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters40,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$_
};
const listByResourceGroupOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const listOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkVirtualAppliances",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$_
};
const listByResourceGroupNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$_
};
const listNextOperationSpec$D = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$_
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualApplianceSites operations. */
class VirtualApplianceSitesImpl {
    /**
     * Initialize a new instance of the class VirtualApplianceSites class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Network Virtual Appliance Sites in a Network Virtual Appliance resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkVirtualApplianceName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkVirtualApplianceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkVirtualApplianceName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkVirtualApplianceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkVirtualApplianceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkVirtualApplianceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkVirtualApplianceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkVirtualApplianceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified site from a Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkVirtualApplianceName, siteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkVirtualApplianceName,
                    siteName,
                    options
                },
                spec: deleteOperationSpec$I
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified site from a Virtual Appliance.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkVirtualApplianceName, siteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkVirtualApplianceName, siteName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Virtual Appliance Site.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkVirtualApplianceName, siteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, siteName, options }, getOperationSpec$L);
    }
    /**
     * Creates or updates the specified Network Virtual Appliance Site.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance Site
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, siteName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkVirtualApplianceName,
                    siteName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$I
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified Network Virtual Appliance Site.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param siteName The name of the site.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance Site
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkVirtualApplianceName, siteName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, siteName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Network Virtual Appliance Sites in a Network Virtual Appliance resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkVirtualApplianceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, options }, listOperationSpec$K);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkVirtualApplianceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkVirtualApplianceName, nextLink, options }, listNextOperationSpec$C);
    }
}
// Operation Specifications
const serializer$Z = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/virtualApplianceSites/{siteName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const getOperationSpec$L = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/virtualApplianceSites/{siteName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualApplianceSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName,
        siteName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const createOrUpdateOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/virtualApplianceSites/{siteName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualApplianceSite
        },
        201: {
            bodyMapper: VirtualApplianceSite
        },
        202: {
            bodyMapper: VirtualApplianceSite
        },
        204: {
            bodyMapper: VirtualApplianceSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters41,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName,
        siteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$Z
};
const listOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/virtualApplianceSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSiteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkVirtualApplianceName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};
const listNextOperationSpec$C = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSiteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkVirtualApplianceName
    ],
    headerParameters: [accept],
    serializer: serializer$Z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualApplianceSkus operations. */
class VirtualApplianceSkusImpl {
    /**
     * Initialize a new instance of the class VirtualApplianceSkus class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List all SKUs available for a virtual appliance.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List all SKUs available for a virtual appliance.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$J);
    }
    /**
     * Retrieves a single available sku for network virtual appliance.
     * @param skuName Name of the Sku.
     * @param options The options parameters.
     */
    get(skuName, options) {
        return this.client.sendOperationRequest({ skuName, options }, getOperationSpec$K);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$B);
    }
}
// Operation Specifications
const serializer$Y = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkVirtualApplianceSkus",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSkuListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$Y
};
const getOperationSpec$K = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkVirtualApplianceSkus/{skuName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSku
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        skuName
    ],
    headerParameters: [accept],
    serializer: serializer$Y
};
const listNextOperationSpec$B = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkVirtualApplianceSkuListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$Y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing InboundSecurityRuleOperations operations. */
class InboundSecurityRuleOperationsImpl {
    /**
     * Initialize a new instance of the class InboundSecurityRuleOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates or updates the specified Network Virtual Appliance Inbound Security Rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param ruleCollectionName The name of security rule collection.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance Inbound
     *                   Security Rules operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, ruleCollectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkVirtualApplianceName,
                    ruleCollectionName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$H
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified Network Virtual Appliance Inbound Security Rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkVirtualApplianceName The name of the Network Virtual Appliance.
     * @param ruleCollectionName The name of security rule collection.
     * @param parameters Parameters supplied to the create or update Network Virtual Appliance Inbound
     *                   Security Rules operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkVirtualApplianceName, ruleCollectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkVirtualApplianceName, ruleCollectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$X = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkVirtualAppliances/{networkVirtualApplianceName}/inboundSecurityRules/{ruleCollectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: InboundSecurityRule
        },
        201: {
            bodyMapper: InboundSecurityRule
        },
        202: {
            bodyMapper: InboundSecurityRule
        },
        204: {
            bodyMapper: InboundSecurityRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters42,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ruleCollectionName,
        networkVirtualApplianceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$X
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NetworkWatchers operations. */
class NetworkWatchersImpl {
    /**
     * Initialize a new instance of the class NetworkWatchers class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all network watchers by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all network watchers by subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            result = yield tslib.__await(this._listAll(options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates or updates a network watcher in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the network watcher resource.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, networkWatcherName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, parameters, options }, createOrUpdateOperationSpec$G);
    }
    /**
     * Gets the specified network watcher by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkWatcherName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, options }, getOperationSpec$J);
    }
    /**
     * Deletes the specified network watcher resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkWatcherName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, options },
                spec: deleteOperationSpec$H
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified network watcher resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkWatcherName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkWatcherName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a network watcher tags.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters supplied to update network watcher tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkWatcherName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, parameters, options }, updateTagsOperationSpec$j);
    }
    /**
     * Gets all network watchers by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$I);
    }
    /**
     * Gets all network watchers by subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$5);
    }
    /**
     * Gets the current network topology by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the representation of topology.
     * @param options The options parameters.
     */
    getTopology(resourceGroupName, networkWatcherName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, parameters, options }, getTopologyOperationSpec);
    }
    /**
     * Verify IP flow from the specified VM to a location given the currently configured NSG rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the IP flow to be verified.
     * @param options The options parameters.
     */
    beginVerifyIPFlow(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: verifyIPFlowOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Verify IP flow from the specified VM to a location given the currently configured NSG rules.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the IP flow to be verified.
     * @param options The options parameters.
     */
    beginVerifyIPFlowAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginVerifyIPFlow(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the next hop from the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the source and destination endpoint.
     * @param options The options parameters.
     */
    beginGetNextHop(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: getNextHopOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the next hop from the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the source and destination endpoint.
     * @param options The options parameters.
     */
    beginGetNextHopAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetNextHop(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the configured and effective security group rules on the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the VM to check security groups for.
     * @param options The options parameters.
     */
    beginGetVMSecurityRules(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: getVMSecurityRulesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the configured and effective security group rules on the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters that define the VM to check security groups for.
     * @param options The options parameters.
     */
    beginGetVMSecurityRulesAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetVMSecurityRules(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Initiate troubleshooting on a specified resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the resource to troubleshoot.
     * @param options The options parameters.
     */
    beginGetTroubleshooting(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: getTroubleshootingOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Initiate troubleshooting on a specified resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the resource to troubleshoot.
     * @param options The options parameters.
     */
    beginGetTroubleshootingAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetTroubleshooting(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the last completed troubleshooting result on a specified resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the resource to query the troubleshooting result.
     * @param options The options parameters.
     */
    beginGetTroubleshootingResult(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: getTroubleshootingResultOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Get the last completed troubleshooting result on a specified resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the resource to query the troubleshooting result.
     * @param options The options parameters.
     */
    beginGetTroubleshootingResultAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetTroubleshootingResult(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Configures flow log and traffic analytics (optional) on a specified resource.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the configuration of flow log.
     * @param options The options parameters.
     */
    beginSetFlowLogConfiguration(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: setFlowLogConfigurationOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Configures flow log and traffic analytics (optional) on a specified resource.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define the configuration of flow log.
     * @param options The options parameters.
     */
    beginSetFlowLogConfigurationAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSetFlowLogConfiguration(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Queries status of flow log and traffic analytics (optional) on a specified resource.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define a resource to query flow log and traffic analytics
     *                   (optional) status.
     * @param options The options parameters.
     */
    beginGetFlowLogStatus(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: getFlowLogStatusOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Queries status of flow log and traffic analytics (optional) on a specified resource.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that define a resource to query flow log and traffic analytics
     *                   (optional) status.
     * @param options The options parameters.
     */
    beginGetFlowLogStatusAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetFlowLogStatus(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Verifies the possibility of establishing a direct TCP connection from a virtual machine to a given
     * endpoint including another VM or an arbitrary remote server.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that determine how the connectivity check will be performed.
     * @param options The options parameters.
     */
    beginCheckConnectivity(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: checkConnectivityOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Verifies the possibility of establishing a direct TCP connection from a virtual machine to a given
     * endpoint including another VM or an arbitrary remote server.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that determine how the connectivity check will be performed.
     * @param options The options parameters.
     */
    beginCheckConnectivityAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCheckConnectivity(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * NOTE: This feature is currently in preview and still being tested for stability. Gets the relative
     * latency score for internet service providers from a specified location to Azure regions.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that determine Azure reachability report configuration.
     * @param options The options parameters.
     */
    beginGetAzureReachabilityReport(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: getAzureReachabilityReportOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * NOTE: This feature is currently in preview and still being tested for stability. Gets the relative
     * latency score for internet service providers from a specified location to Azure regions.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that determine Azure reachability report configuration.
     * @param options The options parameters.
     */
    beginGetAzureReachabilityReportAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetAzureReachabilityReport(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * NOTE: This feature is currently in preview and still being tested for stability. Lists all available
     * internet service providers for a specified Azure region.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that scope the list of available providers.
     * @param options The options parameters.
     */
    beginListAvailableProviders(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: listAvailableProvidersOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * NOTE: This feature is currently in preview and still being tested for stability. Lists all available
     * internet service providers for a specified Azure region.
     * @param resourceGroupName The name of the network watcher resource group.
     * @param networkWatcherName The name of the network watcher resource.
     * @param parameters Parameters that scope the list of available providers.
     * @param options The options parameters.
     */
    beginListAvailableProvidersAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListAvailableProviders(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets Network Configuration Diagnostic data to help customers understand and debug network behavior.
     * It provides detailed information on what security rules were applied to a specified traffic flow and
     * the result of evaluating these rules. Customers must provide details of a flow like source,
     * destination, protocol, etc. The API returns whether traffic was allowed or denied, the rules
     * evaluated for the specified flow and the evaluation results.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters to get network configuration diagnostic.
     * @param options The options parameters.
     */
    beginGetNetworkConfigurationDiagnostic(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, parameters, options },
                spec: getNetworkConfigurationDiagnosticOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets Network Configuration Diagnostic data to help customers understand and debug network behavior.
     * It provides detailed information on what security rules were applied to a specified traffic flow and
     * the result of evaluating these rules. Customers must provide details of a flow like source,
     * destination, protocol, etc. The API returns whether traffic was allowed or denied, the rules
     * evaluated for the specified flow and the evaluation results.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param parameters Parameters to get network configuration diagnostic.
     * @param options The options parameters.
     */
    beginGetNetworkConfigurationDiagnosticAndWait(resourceGroupName, networkWatcherName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetNetworkConfigurationDiagnostic(resourceGroupName, networkWatcherName, parameters, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$W = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: NetworkWatcher
        },
        201: {
            bodyMapper: NetworkWatcher
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters43,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const getOperationSpec$J = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkWatcher
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const deleteOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const updateTagsOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: NetworkWatcher
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const listOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkWatcherListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$W
};
const listAllOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/networkWatchers",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: NetworkWatcherListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$W
};
const getTopologyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/topology",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: Topology
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters44,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const verifyIPFlowOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/ipFlowVerify",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VerificationIPFlowResult
        },
        201: {
            bodyMapper: VerificationIPFlowResult
        },
        202: {
            bodyMapper: VerificationIPFlowResult
        },
        204: {
            bodyMapper: VerificationIPFlowResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters45,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const getNextHopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/nextHop",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NextHopResult
        },
        201: {
            bodyMapper: NextHopResult
        },
        202: {
            bodyMapper: NextHopResult
        },
        204: {
            bodyMapper: NextHopResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters46,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const getVMSecurityRulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/securityGroupView",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: SecurityGroupViewResult
        },
        201: {
            bodyMapper: SecurityGroupViewResult
        },
        202: {
            bodyMapper: SecurityGroupViewResult
        },
        204: {
            bodyMapper: SecurityGroupViewResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters47,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const getTroubleshootingOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/troubleshoot",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TroubleshootingResult
        },
        201: {
            bodyMapper: TroubleshootingResult
        },
        202: {
            bodyMapper: TroubleshootingResult
        },
        204: {
            bodyMapper: TroubleshootingResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters48,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const getTroubleshootingResultOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/queryTroubleshootResult",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: TroubleshootingResult
        },
        201: {
            bodyMapper: TroubleshootingResult
        },
        202: {
            bodyMapper: TroubleshootingResult
        },
        204: {
            bodyMapper: TroubleshootingResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters49,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const setFlowLogConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/configureFlowLog",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FlowLogInformation
        },
        201: {
            bodyMapper: FlowLogInformation
        },
        202: {
            bodyMapper: FlowLogInformation
        },
        204: {
            bodyMapper: FlowLogInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters50,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const getFlowLogStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/queryFlowLogStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: FlowLogInformation
        },
        201: {
            bodyMapper: FlowLogInformation
        },
        202: {
            bodyMapper: FlowLogInformation
        },
        204: {
            bodyMapper: FlowLogInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters51,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const checkConnectivityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectivityCheck",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectivityInformation
        },
        201: {
            bodyMapper: ConnectivityInformation
        },
        202: {
            bodyMapper: ConnectivityInformation
        },
        204: {
            bodyMapper: ConnectivityInformation
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters52,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const getAzureReachabilityReportOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/azureReachabilityReport",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AzureReachabilityReport
        },
        201: {
            bodyMapper: AzureReachabilityReport
        },
        202: {
            bodyMapper: AzureReachabilityReport
        },
        204: {
            bodyMapper: AzureReachabilityReport
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters53,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const listAvailableProvidersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/availableProvidersList",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AvailableProvidersList
        },
        201: {
            bodyMapper: AvailableProvidersList
        },
        202: {
            bodyMapper: AvailableProvidersList
        },
        204: {
            bodyMapper: AvailableProvidersList
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters54,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};
const getNetworkConfigurationDiagnosticOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/networkConfigurationDiagnostic",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NetworkConfigurationDiagnosticResponse
        },
        201: {
            bodyMapper: NetworkConfigurationDiagnosticResponse
        },
        202: {
            bodyMapper: NetworkConfigurationDiagnosticResponse
        },
        204: {
            bodyMapper: NetworkConfigurationDiagnosticResponse
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters55,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$W
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PacketCaptures operations. */
class PacketCapturesImpl {
    /**
     * Initialize a new instance of the class PacketCaptures class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all packet capture sessions within the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkWatcherName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkWatcherName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkWatcherName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkWatcherName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, networkWatcherName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, networkWatcherName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkWatcherName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create and start a packet capture on the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param parameters Parameters that define the create packet capture operation.
     * @param options The options parameters.
     */
    beginCreate(resourceGroupName, networkWatcherName, packetCaptureName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    packetCaptureName,
                    parameters,
                    options
                },
                spec: createOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create and start a packet capture on the specified VM.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param parameters Parameters that define the create packet capture operation.
     * @param options The options parameters.
     */
    beginCreateAndWait(resourceGroupName, networkWatcherName, packetCaptureName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreate(resourceGroupName, networkWatcherName, packetCaptureName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a packet capture session by name.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, packetCaptureName, options }, getOperationSpec$I);
    }
    /**
     * Deletes the specified packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    packetCaptureName,
                    options
                },
                spec: deleteOperationSpec$G
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkWatcherName, packetCaptureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops a specified packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    packetCaptureName,
                    options
                },
                spec: stopOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stops a specified packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param packetCaptureName The name of the packet capture session.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, networkWatcherName, packetCaptureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Query the status of a running packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param packetCaptureName The name given to the packet capture session.
     * @param options The options parameters.
     */
    beginGetStatus(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    packetCaptureName,
                    options
                },
                spec: getStatusOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Query the status of a running packet capture session.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param packetCaptureName The name given to the packet capture session.
     * @param options The options parameters.
     */
    beginGetStatusAndWait(resourceGroupName, networkWatcherName, packetCaptureName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetStatus(resourceGroupName, networkWatcherName, packetCaptureName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all packet capture sessions within the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkWatcherName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, options }, listOperationSpec$H);
    }
}
// Operation Specifications
const serializer$V = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PacketCaptureResult
        },
        201: {
            bodyMapper: PacketCaptureResult
        },
        202: {
            bodyMapper: PacketCaptureResult
        },
        204: {
            bodyMapper: PacketCaptureResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters56,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$V
};
const getOperationSpec$I = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCaptureResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const deleteOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const stopOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const getStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures/{packetCaptureName}/queryStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PacketCaptureQueryStatusResult
        },
        201: {
            bodyMapper: PacketCaptureQueryStatusResult
        },
        202: {
            bodyMapper: PacketCaptureQueryStatusResult
        },
        204: {
            bodyMapper: PacketCaptureQueryStatusResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        packetCaptureName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};
const listOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/packetCaptures",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PacketCaptureListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$V
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ConnectionMonitors operations. */
class ConnectionMonitorsImpl {
    /**
     * Initialize a new instance of the class ConnectionMonitors class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all connection monitors for the specified Network Watcher.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkWatcherName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkWatcherName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkWatcherName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkWatcherName, options, _settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            result = yield tslib.__await(this._list(resourceGroupName, networkWatcherName, options));
            yield yield tslib.__await(result.value || []);
        });
    }
    listPagingAll(resourceGroupName, networkWatcherName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkWatcherName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param parameters Parameters that define the operation to create a connection monitor.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    connectionMonitorName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$F
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param parameters Parameters that define the operation to create a connection monitor.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a connection monitor by name.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, connectionMonitorName, options }, getOperationSpec$H);
    }
    /**
     * Deletes the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    connectionMonitorName,
                    options
                },
                spec: deleteOperationSpec$F
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkWatcherName, connectionMonitorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update tags of the specified connection monitor.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param connectionMonitorName The name of the connection monitor.
     * @param parameters Parameters supplied to update connection monitor tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkWatcherName, connectionMonitorName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkWatcherName,
            connectionMonitorName,
            parameters,
            options
        }, updateTagsOperationSpec$i);
    }
    /**
     * Stops the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginStop(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    connectionMonitorName,
                    options
                },
                spec: stopOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stops the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginStopAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStop(resourceGroupName, networkWatcherName, connectionMonitorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginStart(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    connectionMonitorName,
                    options
                },
                spec: startOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts the specified connection monitor.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name of the connection monitor.
     * @param options The options parameters.
     */
    beginStartAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStart(resourceGroupName, networkWatcherName, connectionMonitorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Query a snapshot of the most recent connection states.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name given to the connection monitor.
     * @param options The options parameters.
     */
    beginQuery(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    connectionMonitorName,
                    options
                },
                spec: queryOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Query a snapshot of the most recent connection states.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param connectionMonitorName The name given to the connection monitor.
     * @param options The options parameters.
     */
    beginQueryAndWait(resourceGroupName, networkWatcherName, connectionMonitorName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginQuery(resourceGroupName, networkWatcherName, connectionMonitorName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all connection monitors for the specified Network Watcher.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkWatcherName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, options }, listOperationSpec$G);
    }
}
// Operation Specifications
const serializer$U = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorResult
        },
        201: {
            bodyMapper: ConnectionMonitorResult
        },
        202: {
            bodyMapper: ConnectionMonitorResult
        },
        204: {
            bodyMapper: ConnectionMonitorResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters57,
    queryParameters: [apiVersion, migrate],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const getOperationSpec$H = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const deleteOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const updateTagsOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$U
};
const stopOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}/stop",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const startOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}/start",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const queryOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors/{connectionMonitorName}/query",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorQueryResult
        },
        201: {
            bodyMapper: ConnectionMonitorQueryResult
        },
        202: {
            bodyMapper: ConnectionMonitorQueryResult
        },
        204: {
            bodyMapper: ConnectionMonitorQueryResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        connectionMonitorName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};
const listOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/connectionMonitors",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectionMonitorListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$U
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing FlowLogs operations. */
class FlowLogsImpl {
    /**
     * Initialize a new instance of the class FlowLogs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all flow log resources for the specified Network Watcher.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    list(resourceGroupName, networkWatcherName, options) {
        const iter = this.listPagingAll(resourceGroupName, networkWatcherName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, networkWatcherName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, networkWatcherName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, networkWatcherName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, networkWatcherName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, networkWatcherName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, networkWatcherName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Create or update a flow log for the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log.
     * @param parameters Parameters that define the create or update flow log resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, networkWatcherName, flowLogName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    networkWatcherName,
                    flowLogName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$E
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or update a flow log for the specified network security group.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log.
     * @param parameters Parameters that define the create or update flow log resource.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, networkWatcherName, flowLogName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, networkWatcherName, flowLogName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Update tags of the specified flow log.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log.
     * @param parameters Parameters supplied to update flow log tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, networkWatcherName, flowLogName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            networkWatcherName,
            flowLogName,
            parameters,
            options
        }, updateTagsOperationSpec$h);
    }
    /**
     * Gets a flow log resource by name.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log resource.
     * @param options The options parameters.
     */
    get(resourceGroupName, networkWatcherName, flowLogName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, flowLogName, options }, getOperationSpec$G);
    }
    /**
     * Deletes the specified flow log resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log resource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, networkWatcherName, flowLogName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, networkWatcherName, flowLogName, options },
                spec: deleteOperationSpec$E
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified flow log resource.
     * @param resourceGroupName The name of the resource group.
     * @param networkWatcherName The name of the network watcher.
     * @param flowLogName The name of the flow log resource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, networkWatcherName, flowLogName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, networkWatcherName, flowLogName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all flow log resources for the specified Network Watcher.
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param options The options parameters.
     */
    _list(resourceGroupName, networkWatcherName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, options }, listOperationSpec$F);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group containing Network Watcher.
     * @param networkWatcherName The name of the Network Watcher resource.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, networkWatcherName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, networkWatcherName, nextLink, options }, listNextOperationSpec$A);
    }
}
// Operation Specifications
const serializer$T = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: FlowLog
        },
        201: {
            bodyMapper: FlowLog
        },
        202: {
            bodyMapper: FlowLog
        },
        204: {
            bodyMapper: FlowLog
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters58,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        flowLogName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$T
};
const updateTagsOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: FlowLog
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        flowLogName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$T
};
const getOperationSpec$G = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FlowLog
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        flowLogName
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const deleteOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs/{flowLogName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName,
        flowLogName
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const listOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkWatchers/{networkWatcherName}/flowLogs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FlowLogListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$T
};
const listNextOperationSpec$A = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: FlowLogListResult
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        networkWatcherName
    ],
    headerParameters: [accept],
    serializer: serializer$T
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Operations operations. */
class OperationsImpl {
    /**
     * Initialize a new instance of the class Operations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the available Network Rest API operations.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all of the available Network Rest API operations.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$E);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$z);
    }
}
// Operation Specifications
const serializer$S = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$E = {
    path: "/providers/Microsoft.Network/operations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host],
    headerParameters: [accept],
    serializer: serializer$S
};
const listNextOperationSpec$z = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: OperationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [$host, nextLink],
    headerParameters: [accept],
    serializer: serializer$S
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateEndpoints operations. */
class PrivateEndpointsImpl {
    /**
     * Initialize a new instance of the class PrivateEndpoints class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all private endpoints in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all private endpoints in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateEndpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateEndpointName, options },
                spec: deleteOperationSpec$D
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateEndpointName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateEndpointName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified private endpoint by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param options The options parameters.
     */
    get(resourceGroupName, privateEndpointName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, privateEndpointName, options }, getOperationSpec$F);
    }
    /**
     * Creates or updates an private endpoint in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param parameters Parameters supplied to the create or update private endpoint operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateEndpointName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, privateEndpointName, parameters, options },
                spec: createOrUpdateOperationSpec$D
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an private endpoint in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param parameters Parameters supplied to the create or update private endpoint operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateEndpointName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateEndpointName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private endpoints in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$D);
    }
    /**
     * Gets all private endpoints in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$y);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$R = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const getOperationSpec$F = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpoint
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const createOrUpdateOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpoint
        },
        201: {
            bodyMapper: PrivateEndpoint
        },
        202: {
            bodyMapper: PrivateEndpoint
        },
        204: {
            bodyMapper: PrivateEndpoint
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters59,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$R
};
const listOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const listBySubscriptionOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/privateEndpoints",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$R
};
const listNextOperationSpec$y = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$R
};
const listBySubscriptionNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$R
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing AvailablePrivateEndpointTypes operations. */
class AvailablePrivateEndpointTypesImpl {
    /**
     * Initialize a new instance of the class AvailablePrivateEndpointTypes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Returns all of the resource types that can be linked to a Private Endpoint in this subscription in
     * this region.
     * @param location The location of the domain name.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Returns all of the resource types that can be linked to a Private Endpoint in this subscription in
     * this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(location, resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(location, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(location, resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(location, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(location, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(location, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(location, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(location, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns all of the resource types that can be linked to a Private Endpoint in this subscription in
     * this region.
     * @param location The location of the domain name.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$C);
    }
    /**
     * Returns all of the resource types that can be linked to a Private Endpoint in this subscription in
     * this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(location, resourceGroupName, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, options }, listByResourceGroupOperationSpec$d);
    }
    /**
     * ListNext
     * @param location The location of the domain name.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$x);
    }
    /**
     * ListByResourceGroupNext
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(location, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$Q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/availablePrivateEndpointTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailablePrivateEndpointTypesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const listByResourceGroupOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/availablePrivateEndpointTypes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailablePrivateEndpointTypesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const listNextOperationSpec$x = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailablePrivateEndpointTypesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};
const listByResourceGroupNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AvailablePrivateEndpointTypesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$Q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateDnsZoneGroups operations. */
class PrivateDnsZoneGroupsImpl {
    /**
     * Initialize a new instance of the class PrivateDnsZoneGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all private dns zone groups in a private endpoint.
     * @param privateEndpointName The name of the private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(privateEndpointName, resourceGroupName, options) {
        const iter = this.listPagingAll(privateEndpointName, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(privateEndpointName, resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(privateEndpointName, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(privateEndpointName, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(privateEndpointName, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(privateEndpointName, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(privateEndpointName, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified private dns zone group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateEndpointName,
                    privateDnsZoneGroupName,
                    options
                },
                spec: deleteOperationSpec$C
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified private dns zone group.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the private dns zone group resource by specified private dns zone group name.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param options The options parameters.
     */
    get(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            privateEndpointName,
            privateDnsZoneGroupName,
            options
        }, getOperationSpec$E);
    }
    /**
     * Creates or updates a private dns zone group in the specified private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param parameters Parameters supplied to the create or update private dns zone group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    privateEndpointName,
                    privateDnsZoneGroupName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$C
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a private dns zone group in the specified private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param privateEndpointName The name of the private endpoint.
     * @param privateDnsZoneGroupName The name of the private dns zone group.
     * @param parameters Parameters supplied to the create or update private dns zone group operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, privateEndpointName, privateDnsZoneGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private dns zone groups in a private endpoint.
     * @param privateEndpointName The name of the private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(privateEndpointName, resourceGroupName, options) {
        return this.client.sendOperationRequest({ privateEndpointName, resourceGroupName, options }, listOperationSpec$B);
    }
    /**
     * ListNext
     * @param privateEndpointName The name of the private endpoint.
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(privateEndpointName, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ privateEndpointName, resourceGroupName, nextLink, options }, listNextOperationSpec$w);
    }
}
// Operation Specifications
const serializer$P = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}/privateDnsZoneGroups/{privateDnsZoneGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName,
        privateDnsZoneGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const getOperationSpec$E = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}/privateDnsZoneGroups/{privateDnsZoneGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateDnsZoneGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName,
        privateDnsZoneGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const createOrUpdateOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}/privateDnsZoneGroups/{privateDnsZoneGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateDnsZoneGroup
        },
        201: {
            bodyMapper: PrivateDnsZoneGroup
        },
        202: {
            bodyMapper: PrivateDnsZoneGroup
        },
        204: {
            bodyMapper: PrivateDnsZoneGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters60,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName,
        privateDnsZoneGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$P
};
const listOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateEndpoints/{privateEndpointName}/privateDnsZoneGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateDnsZoneGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};
const listNextOperationSpec$w = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateDnsZoneGroupListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        privateEndpointName
    ],
    headerParameters: [accept],
    serializer: serializer$P
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PrivateLinkServices operations. */
class PrivateLinkServicesImpl {
    /**
     * Initialize a new instance of the class PrivateLinkServices class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all private link services in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all private link service in a subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        const iter = this.listBySubscriptionPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listBySubscriptionPagingPage(options, settings);
            }
        };
    }
    listBySubscriptionPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listBySubscription(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listBySubscriptionNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listBySubscriptionPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listBySubscriptionPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listBySubscriptionPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets all private end point connections for a specific private link service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    listPrivateEndpointConnections(resourceGroupName, serviceName, options) {
        const iter = this.listPrivateEndpointConnectionsPagingAll(resourceGroupName, serviceName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPrivateEndpointConnectionsPagingPage(resourceGroupName, serviceName, options, settings);
            }
        };
    }
    listPrivateEndpointConnectionsPagingPage(resourceGroupName, serviceName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPrivateEndpointConnectionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listPrivateEndpointConnections(resourceGroupName, serviceName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listPrivateEndpointConnectionsNext(resourceGroupName, serviceName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPrivateEndpointConnectionsPagingAll(resourceGroupName, serviceName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPrivateEndpointConnectionsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPrivateEndpointConnectionsPagingPage(resourceGroupName, serviceName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns all of the private link service ids that can be linked to a Private Endpoint with auto
     * approved in this subscription in this region.
     * @param location The location of the domain name.
     * @param options The options parameters.
     */
    listAutoApprovedPrivateLinkServices(location, options) {
        const iter = this.listAutoApprovedPrivateLinkServicesPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAutoApprovedPrivateLinkServicesPagingPage(location, options, settings);
            }
        };
    }
    listAutoApprovedPrivateLinkServicesPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAutoApprovedPrivateLinkServicesPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAutoApprovedPrivateLinkServices(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAutoApprovedPrivateLinkServicesNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAutoApprovedPrivateLinkServicesPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAutoApprovedPrivateLinkServicesPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAutoApprovedPrivateLinkServicesPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Returns all of the private link service ids that can be linked to a Private Endpoint with auto
     * approved in this subscription in this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listAutoApprovedPrivateLinkServicesByResourceGroup(location, resourceGroupName, options) {
        const iter = this.listAutoApprovedPrivateLinkServicesByResourceGroupPagingAll(location, resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAutoApprovedPrivateLinkServicesByResourceGroupPagingPage(location, resourceGroupName, options, settings);
            }
        };
    }
    listAutoApprovedPrivateLinkServicesByResourceGroupPagingPage(location, resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAutoApprovedPrivateLinkServicesByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAutoApprovedPrivateLinkServicesByResourceGroup(location, resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAutoApprovedPrivateLinkServicesByResourceGroupNext(location, resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAutoApprovedPrivateLinkServicesByResourceGroupPagingAll(location, resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listAutoApprovedPrivateLinkServicesByResourceGroupPagingAll_1() {
            var e_5, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAutoApprovedPrivateLinkServicesByResourceGroupPagingPage(location, resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_5) throw e_5.error; }
            }
        });
    }
    /**
     * Deletes the specified private link service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, serviceName, options },
                spec: deleteOperationSpec$B
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified private link service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serviceName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serviceName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified private link service by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, getOperationSpec$D);
    }
    /**
     * Creates or updates an private link service in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param parameters Parameters supplied to the create or update private link service operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, serviceName, parameters, options },
                spec: createOrUpdateOperationSpec$B
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates an private link service in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param parameters Parameters supplied to the create or update private link service operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private link services in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$A);
    }
    /**
     * Gets all private link service in a subscription.
     * @param options The options parameters.
     */
    _listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec$1);
    }
    /**
     * Get the specific private end point connection by specific private link service in the resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param peConnectionName The name of the private end point connection.
     * @param options The options parameters.
     */
    getPrivateEndpointConnection(resourceGroupName, serviceName, peConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, peConnectionName, options }, getPrivateEndpointConnectionOperationSpec);
    }
    /**
     * Approve or reject private end point connection for a private link service in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param peConnectionName The name of the private end point connection.
     * @param parameters Parameters supplied to approve or reject the private end point connection.
     * @param options The options parameters.
     */
    updatePrivateEndpointConnection(resourceGroupName, serviceName, peConnectionName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, peConnectionName, parameters, options }, updatePrivateEndpointConnectionOperationSpec);
    }
    /**
     * Delete private end point connection for a private link service in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param peConnectionName The name of the private end point connection.
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnection(resourceGroupName, serviceName, peConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, serviceName, peConnectionName, options },
                spec: deletePrivateEndpointConnectionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Delete private end point connection for a private link service in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param peConnectionName The name of the private end point connection.
     * @param options The options parameters.
     */
    beginDeletePrivateEndpointConnectionAndWait(resourceGroupName, serviceName, peConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeletePrivateEndpointConnection(resourceGroupName, serviceName, peConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all private end point connections for a specific private link service.
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param options The options parameters.
     */
    _listPrivateEndpointConnections(resourceGroupName, serviceName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, options }, listPrivateEndpointConnectionsOperationSpec);
    }
    /**
     * Checks whether the subscription is visible to private link service.
     * @param location The location of the domain name.
     * @param parameters The request body of CheckPrivateLinkService API call.
     * @param options The options parameters.
     */
    beginCheckPrivateLinkServiceVisibility(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { location, parameters, options },
                spec: checkPrivateLinkServiceVisibilityOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Checks whether the subscription is visible to private link service.
     * @param location The location of the domain name.
     * @param parameters The request body of CheckPrivateLinkService API call.
     * @param options The options parameters.
     */
    beginCheckPrivateLinkServiceVisibilityAndWait(location, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCheckPrivateLinkServiceVisibility(location, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Checks whether the subscription is visible to private link service in the specified resource group.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param parameters The request body of CheckPrivateLinkService API call.
     * @param options The options parameters.
     */
    beginCheckPrivateLinkServiceVisibilityByResourceGroup(location, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { location, resourceGroupName, parameters, options },
                spec: checkPrivateLinkServiceVisibilityByResourceGroupOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Checks whether the subscription is visible to private link service in the specified resource group.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param parameters The request body of CheckPrivateLinkService API call.
     * @param options The options parameters.
     */
    beginCheckPrivateLinkServiceVisibilityByResourceGroupAndWait(location, resourceGroupName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCheckPrivateLinkServiceVisibilityByResourceGroup(location, resourceGroupName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Returns all of the private link service ids that can be linked to a Private Endpoint with auto
     * approved in this subscription in this region.
     * @param location The location of the domain name.
     * @param options The options parameters.
     */
    _listAutoApprovedPrivateLinkServices(location, options) {
        return this.client.sendOperationRequest({ location, options }, listAutoApprovedPrivateLinkServicesOperationSpec);
    }
    /**
     * Returns all of the private link service ids that can be linked to a Private Endpoint with auto
     * approved in this subscription in this region.
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listAutoApprovedPrivateLinkServicesByResourceGroup(location, resourceGroupName, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, options }, listAutoApprovedPrivateLinkServicesByResourceGroupOperationSpec);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$v);
    }
    /**
     * ListBySubscriptionNext
     * @param nextLink The nextLink from the previous successful call to the ListBySubscription method.
     * @param options The options parameters.
     */
    _listBySubscriptionNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listBySubscriptionNextOperationSpec);
    }
    /**
     * ListPrivateEndpointConnectionsNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceName The name of the private link service.
     * @param nextLink The nextLink from the previous successful call to the ListPrivateEndpointConnections
     *                 method.
     * @param options The options parameters.
     */
    _listPrivateEndpointConnectionsNext(resourceGroupName, serviceName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceName, nextLink, options }, listPrivateEndpointConnectionsNextOperationSpec);
    }
    /**
     * ListAutoApprovedPrivateLinkServicesNext
     * @param location The location of the domain name.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListAutoApprovedPrivateLinkServices method.
     * @param options The options parameters.
     */
    _listAutoApprovedPrivateLinkServicesNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listAutoApprovedPrivateLinkServicesNextOperationSpec);
    }
    /**
     * ListAutoApprovedPrivateLinkServicesByResourceGroupNext
     * @param location The location of the domain name.
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the
     *                 ListAutoApprovedPrivateLinkServicesByResourceGroup method.
     * @param options The options parameters.
     */
    _listAutoApprovedPrivateLinkServicesByResourceGroupNext(location, resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ location, resourceGroupName, nextLink, options }, listAutoApprovedPrivateLinkServicesByResourceGroupNextOperationSpec);
    }
}
// Operation Specifications
const serializer$O = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const getOperationSpec$D = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkService
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const createOrUpdateOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateLinkService
        },
        201: {
            bodyMapper: PrivateLinkService
        },
        202: {
            bodyMapper: PrivateLinkService
        },
        204: {
            bodyMapper: PrivateLinkService
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters61,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$O
};
const listOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listBySubscriptionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/privateLinkServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$O
};
const getPrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}/privateEndpointConnections/{peConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName,
        peConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const updatePrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}/privateEndpointConnections/{peConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnection
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters62,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName,
        peConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$O
};
const deletePrivateEndpointConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}/privateEndpointConnections/{peConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName,
        peConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listPrivateEndpointConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/privateLinkServices/{serviceName}/privateEndpointConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const checkPrivateLinkServiceVisibilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/checkPrivateLinkServiceVisibility",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        201: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        202: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        204: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters63,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$O
};
const checkPrivateLinkServiceVisibilityByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/checkPrivateLinkServiceVisibility",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        201: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        202: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        204: {
            bodyMapper: PrivateLinkServiceVisibility
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters63,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$O
};
const listAutoApprovedPrivateLinkServicesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/autoApprovedPrivateLinkServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoApprovedPrivateLinkServicesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listAutoApprovedPrivateLinkServicesByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/locations/{location}/autoApprovedPrivateLinkServices",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoApprovedPrivateLinkServicesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listNextOperationSpec$v = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listBySubscriptionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateLinkServiceListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listPrivateEndpointConnectionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PrivateEndpointConnectionListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        serviceName
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listAutoApprovedPrivateLinkServicesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoApprovedPrivateLinkServicesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$O
};
const listAutoApprovedPrivateLinkServicesByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AutoApprovedPrivateLinkServicesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$O
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing PublicIPPrefixes operations. */
class PublicIPPrefixesImpl {
    /**
     * Initialize a new instance of the class PublicIPPrefixes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the public IP prefixes in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all public IP prefixes in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified public IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the PublicIpPrefix.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, publicIpPrefixName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, publicIpPrefixName, options },
                spec: deleteOperationSpec$A
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified public IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the PublicIpPrefix.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, publicIpPrefixName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, publicIpPrefixName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified public IP prefix in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the public IP prefix.
     * @param options The options parameters.
     */
    get(resourceGroupName, publicIpPrefixName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, publicIpPrefixName, options }, getOperationSpec$C);
    }
    /**
     * Creates or updates a static or dynamic public IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the public IP prefix.
     * @param parameters Parameters supplied to the create or update public IP prefix operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, publicIpPrefixName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, publicIpPrefixName, parameters, options },
                spec: createOrUpdateOperationSpec$A
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a static or dynamic public IP prefix.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the public IP prefix.
     * @param parameters Parameters supplied to the create or update public IP prefix operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, publicIpPrefixName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, publicIpPrefixName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates public IP prefix tags.
     * @param resourceGroupName The name of the resource group.
     * @param publicIpPrefixName The name of the public IP prefix.
     * @param parameters Parameters supplied to update public IP prefix tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, publicIpPrefixName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, publicIpPrefixName, parameters, options }, updateTagsOperationSpec$g);
    }
    /**
     * Gets all the public IP prefixes in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$4);
    }
    /**
     * Gets all public IP prefixes in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$z);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$4);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$u);
    }
}
// Operation Specifications
const serializer$N = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIpPrefixName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const getOperationSpec$C = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIpPrefixName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpPrefixName
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const createOrUpdateOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIpPrefixName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: PublicIPPrefix
        },
        201: {
            bodyMapper: PublicIPPrefix
        },
        202: {
            bodyMapper: PublicIPPrefix
        },
        204: {
            bodyMapper: PublicIPPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters64,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpPrefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$N
};
const updateTagsOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIpPrefixName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: PublicIPPrefix
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        publicIpPrefixName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$N
};
const listAllOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/publicIPPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$N
};
const listOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const listAllNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$N
};
const listNextOperationSpec$u = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: PublicIPPrefixListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$N
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RouteFilters operations. */
class RouteFiltersImpl {
    /**
     * Initialize a new instance of the class RouteFilters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all route filters in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all route filters in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, routeFilterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, routeFilterName, options },
                spec: deleteOperationSpec$z
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, routeFilterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, routeFilterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    get(resourceGroupName, routeFilterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, options }, getOperationSpec$B);
    }
    /**
     * Creates or updates a route filter in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param routeFilterParameters Parameters supplied to the create or update route filter operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, routeFilterName, routeFilterParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    routeFilterName,
                    routeFilterParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$z
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a route filter in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param routeFilterParameters Parameters supplied to the create or update route filter operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, routeFilterName, routeFilterParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, routeFilterName, routeFilterParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param parameters Parameters supplied to update route filter tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, routeFilterName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, parameters, options }, updateTagsOperationSpec$f);
    }
    /**
     * Gets all route filters in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$c);
    }
    /**
     * Gets all route filters in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$y);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$b);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$t);
    }
}
// Operation Specifications
const serializer$M = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const getOperationSpec$B = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilter
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const createOrUpdateOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RouteFilter
        },
        201: {
            bodyMapper: RouteFilter
        },
        202: {
            bodyMapper: RouteFilter
        },
        204: {
            bodyMapper: RouteFilter
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routeFilterParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const updateTagsOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RouteFilter
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$M
};
const listByResourceGroupOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/routeFilters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$M
};
const listByResourceGroupNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$M
};
const listNextOperationSpec$t = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$M
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RouteFilterRules operations. */
class RouteFilterRulesImpl {
    /**
     * Initialize a new instance of the class RouteFilterRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all RouteFilterRules in a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    listByRouteFilter(resourceGroupName, routeFilterName, options) {
        const iter = this.listByRouteFilterPagingAll(resourceGroupName, routeFilterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByRouteFilterPagingPage(resourceGroupName, routeFilterName, options, settings);
            }
        };
    }
    listByRouteFilterPagingPage(resourceGroupName, routeFilterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByRouteFilterPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByRouteFilter(resourceGroupName, routeFilterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByRouteFilterNext(resourceGroupName, routeFilterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByRouteFilterPagingAll(resourceGroupName, routeFilterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByRouteFilterPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByRouteFilterPagingPage(resourceGroupName, routeFilterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified rule from a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, routeFilterName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, routeFilterName, ruleName, options },
                spec: deleteOperationSpec$y
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified rule from a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, routeFilterName, ruleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, routeFilterName, ruleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified rule from a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, routeFilterName, ruleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, ruleName, options }, getOperationSpec$A);
    }
    /**
     * Creates or updates a route in the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the route filter rule.
     * @param routeFilterRuleParameters Parameters supplied to the create or update route filter rule
     *                                  operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, routeFilterName, ruleName, routeFilterRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    routeFilterName,
                    ruleName,
                    routeFilterRuleParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$y
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a route in the specified route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param ruleName The name of the route filter rule.
     * @param routeFilterRuleParameters Parameters supplied to the create or update route filter rule
     *                                  operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, routeFilterName, ruleName, routeFilterRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, routeFilterName, ruleName, routeFilterRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all RouteFilterRules in a route filter.
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param options The options parameters.
     */
    _listByRouteFilter(resourceGroupName, routeFilterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, options }, listByRouteFilterOperationSpec);
    }
    /**
     * ListByRouteFilterNext
     * @param resourceGroupName The name of the resource group.
     * @param routeFilterName The name of the route filter.
     * @param nextLink The nextLink from the previous successful call to the ListByRouteFilter method.
     * @param options The options parameters.
     */
    _listByRouteFilterNext(resourceGroupName, routeFilterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeFilterName, nextLink, options }, listByRouteFilterNextOperationSpec);
    }
}
// Operation Specifications
const serializer$L = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}/routeFilterRules/{ruleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ruleName,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const getOperationSpec$A = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}/routeFilterRules/{ruleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ruleName,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const createOrUpdateOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}/routeFilterRules/{ruleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RouteFilterRule
        },
        201: {
            bodyMapper: RouteFilterRule
        },
        202: {
            bodyMapper: RouteFilterRule
        },
        204: {
            bodyMapper: RouteFilterRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routeFilterRuleParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        ruleName,
        routeFilterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$L
};
const listByRouteFilterOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeFilters/{routeFilterName}/routeFilterRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};
const listByRouteFilterNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteFilterRuleListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        routeFilterName
    ],
    headerParameters: [accept],
    serializer: serializer$L
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RouteTables operations. */
class RouteTablesImpl {
    /**
     * Initialize a new instance of the class RouteTables class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all route tables in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all route tables in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, routeTableName, options },
                spec: deleteOperationSpec$x
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, routeTableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    get(resourceGroupName, routeTableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, options }, getOperationSpec$z);
    }
    /**
     * Create or updates a route table in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param parameters Parameters supplied to the create or update route table operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, routeTableName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, routeTableName, parameters, options },
                spec: createOrUpdateOperationSpec$x
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Create or updates a route table in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param parameters Parameters supplied to the create or update route table operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, routeTableName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, routeTableName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a route table tags.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param parameters Parameters supplied to update route table tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, routeTableName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, parameters, options }, updateTagsOperationSpec$e);
    }
    /**
     * Gets all route tables in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$x);
    }
    /**
     * Gets all route tables in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$s);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$K = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const getOperationSpec$z = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const createOrUpdateOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RouteTable
        },
        201: {
            bodyMapper: RouteTable
        },
        202: {
            bodyMapper: RouteTable
        },
        204: {
            bodyMapper: RouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters65,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$K
};
const updateTagsOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: RouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$K
};
const listOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const listAllOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/routeTables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$K
};
const listNextOperationSpec$s = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$K
};
const listAllNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteTableListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$K
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Routes operations. */
class RoutesImpl {
    /**
     * Initialize a new instance of the class Routes class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all routes in a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    list(resourceGroupName, routeTableName, options) {
        const iter = this.listPagingAll(resourceGroupName, routeTableName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, routeTableName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, routeTableName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, routeTableName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, routeTableName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, routeTableName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, routeTableName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified route from a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, routeTableName, routeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, routeTableName, routeName, options },
                spec: deleteOperationSpec$w
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified route from a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, routeTableName, routeName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, routeTableName, routeName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified route from a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param options The options parameters.
     */
    get(resourceGroupName, routeTableName, routeName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, routeName, options }, getOperationSpec$y);
    }
    /**
     * Creates or updates a route in the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param routeParameters Parameters supplied to the create or update route operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, routeTableName, routeName, routeParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    routeTableName,
                    routeName,
                    routeParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$w
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a route in the specified route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param routeName The name of the route.
     * @param routeParameters Parameters supplied to the create or update route operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, routeTableName, routeName, routeParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, routeTableName, routeName, routeParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all routes in a route table.
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param options The options parameters.
     */
    _list(resourceGroupName, routeTableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, options }, listOperationSpec$w);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param routeTableName The name of the route table.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, routeTableName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, routeTableName, nextLink, options }, listNextOperationSpec$r);
    }
}
// Operation Specifications
const serializer$J = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}/routes/{routeName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        routeName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const getOperationSpec$y = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}/routes/{routeName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Route
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        routeName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const createOrUpdateOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}/routes/{routeName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Route
        },
        201: {
            bodyMapper: Route
        },
        202: {
            bodyMapper: Route
        },
        204: {
            bodyMapper: Route
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routeParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        routeName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$J
};
const listOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/routeTables/{routeTableName}/routes",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};
const listNextOperationSpec$r = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        routeTableName
    ],
    headerParameters: [accept],
    serializer: serializer$J
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing SecurityPartnerProviders operations. */
class SecurityPartnerProvidersImpl {
    /**
     * Initialize a new instance of the class SecurityPartnerProviders class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Security Partner Providers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Security Partner Providers in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, securityPartnerProviderName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, securityPartnerProviderName, options },
                spec: deleteOperationSpec$v
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, securityPartnerProviderName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, securityPartnerProviderName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param options The options parameters.
     */
    get(resourceGroupName, securityPartnerProviderName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, securityPartnerProviderName, options }, getOperationSpec$x);
    }
    /**
     * Creates or updates the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param parameters Parameters supplied to the create or update Security Partner Provider operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, securityPartnerProviderName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    securityPartnerProviderName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$v
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified Security Partner Provider.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param parameters Parameters supplied to the create or update Security Partner Provider operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, securityPartnerProviderName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, securityPartnerProviderName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of a Security Partner Provider resource.
     * @param resourceGroupName The name of the resource group.
     * @param securityPartnerProviderName The name of the Security Partner Provider.
     * @param parameters Parameters supplied to update Security Partner Provider tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, securityPartnerProviderName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, securityPartnerProviderName, parameters, options }, updateTagsOperationSpec$d);
    }
    /**
     * Lists all Security Partner Providers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$b);
    }
    /**
     * Gets all the Security Partner Providers in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$v);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$a);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$q);
    }
}
// Operation Specifications
const serializer$I = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders/{securityPartnerProviderName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        securityPartnerProviderName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const getOperationSpec$x = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders/{securityPartnerProviderName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProvider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        securityPartnerProviderName
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const createOrUpdateOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders/{securityPartnerProviderName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProvider
        },
        201: {
            bodyMapper: SecurityPartnerProvider
        },
        202: {
            bodyMapper: SecurityPartnerProvider
        },
        204: {
            bodyMapper: SecurityPartnerProvider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters66,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        securityPartnerProviderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$I
};
const updateTagsOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders/{securityPartnerProviderName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProvider
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        securityPartnerProviderName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$I
};
const listByResourceGroupOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/securityPartnerProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const listOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/securityPartnerProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$I
};
const listByResourceGroupNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$I
};
const listNextOperationSpec$q = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SecurityPartnerProviderListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$I
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing BgpServiceCommunities operations. */
class BgpServiceCommunitiesImpl {
    /**
     * Initialize a new instance of the class BgpServiceCommunities class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the available bgp service communities.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the available bgp service communities.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$u);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$p);
    }
}
// Operation Specifications
const serializer$H = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/bgpServiceCommunities",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BgpServiceCommunityListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$H
};
const listNextOperationSpec$p = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BgpServiceCommunityListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$H
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServiceEndpointPolicies operations. */
class ServiceEndpointPoliciesImpl {
    /**
     * Initialize a new instance of the class ServiceEndpointPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the service endpoint policies in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all service endpoint Policies in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serviceEndpointPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, serviceEndpointPolicyName, options },
                spec: deleteOperationSpec$u
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serviceEndpointPolicyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serviceEndpointPolicyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified service Endpoint Policies in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceEndpointPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceEndpointPolicyName, options }, getOperationSpec$w);
    }
    /**
     * Creates or updates a service Endpoint Policies.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param parameters Parameters supplied to the create or update service endpoint policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceEndpointPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    serviceEndpointPolicyName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$u
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a service Endpoint Policies.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param parameters Parameters supplied to the create or update service endpoint policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceEndpointPolicyName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceEndpointPolicyName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates tags of a service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param parameters Parameters supplied to update service endpoint policy tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, serviceEndpointPolicyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceEndpointPolicyName, parameters, options }, updateTagsOperationSpec$c);
    }
    /**
     * Gets all the service endpoint policies in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$t);
    }
    /**
     * Gets all service endpoint Policies in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$a);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$o);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$G = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const getOperationSpec$w = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const createOrUpdateOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicy
        },
        201: {
            bodyMapper: ServiceEndpointPolicy
        },
        202: {
            bodyMapper: ServiceEndpointPolicy
        },
        204: {
            bodyMapper: ServiceEndpointPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters67,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$G
};
const updateTagsOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$G
};
const listOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ServiceEndpointPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$G
};
const listByResourceGroupOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const listNextOperationSpec$o = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$G
};
const listByResourceGroupNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$G
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServiceEndpointPolicyDefinitions operations. */
class ServiceEndpointPolicyDefinitionsImpl {
    /**
     * Initialize a new instance of the class ServiceEndpointPolicyDefinitions class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all service endpoint policy definitions in a service end point policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy name.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, serviceEndpointPolicyName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, serviceEndpointPolicyName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, serviceEndpointPolicyName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, serviceEndpointPolicyName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, serviceEndpointPolicyName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, serviceEndpointPolicyName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, serviceEndpointPolicyName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, serviceEndpointPolicyName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified ServiceEndpoint policy definitions.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the Service Endpoint Policy.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    serviceEndpointPolicyName,
                    serviceEndpointPolicyDefinitionName,
                    options
                },
                spec: deleteOperationSpec$t
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified ServiceEndpoint policy definitions.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the Service Endpoint Policy.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get the specified service endpoint policy definitions from service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy name.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition name.
     * @param options The options parameters.
     */
    get(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            serviceEndpointPolicyName,
            serviceEndpointPolicyDefinitionName,
            options
        }, getOperationSpec$v);
    }
    /**
     * Creates or updates a service endpoint policy definition in the specified service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition name.
     * @param serviceEndpointPolicyDefinitions Parameters supplied to the create or update service endpoint
     *                                         policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, serviceEndpointPolicyDefinitions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    serviceEndpointPolicyName,
                    serviceEndpointPolicyDefinitionName,
                    serviceEndpointPolicyDefinitions,
                    options
                },
                spec: createOrUpdateOperationSpec$t
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a service endpoint policy definition in the specified service endpoint policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy.
     * @param serviceEndpointPolicyDefinitionName The name of the service endpoint policy definition name.
     * @param serviceEndpointPolicyDefinitions Parameters supplied to the create or update service endpoint
     *                                         policy operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, serviceEndpointPolicyDefinitions, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, serviceEndpointPolicyName, serviceEndpointPolicyDefinitionName, serviceEndpointPolicyDefinitions, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all service endpoint policy definitions in a service end point policy.
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy name.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, serviceEndpointPolicyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceEndpointPolicyName, options }, listByResourceGroupOperationSpec$9);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param serviceEndpointPolicyName The name of the service endpoint policy name.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, serviceEndpointPolicyName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, serviceEndpointPolicyName, nextLink, options }, listByResourceGroupNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$F = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}/serviceEndpointPolicyDefinitions/{serviceEndpointPolicyDefinitionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName,
        serviceEndpointPolicyDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const getOperationSpec$v = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}/serviceEndpointPolicyDefinitions/{serviceEndpointPolicyDefinitionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName,
        serviceEndpointPolicyDefinitionName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const createOrUpdateOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}/serviceEndpointPolicyDefinitions/{serviceEndpointPolicyDefinitionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        201: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        202: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        204: {
            bodyMapper: ServiceEndpointPolicyDefinition
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: serviceEndpointPolicyDefinitions,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName,
        serviceEndpointPolicyDefinitionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$F
};
const listByResourceGroupOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/serviceEndpointPolicies/{serviceEndpointPolicyName}/serviceEndpointPolicyDefinitions",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};
const listByResourceGroupNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceEndpointPolicyDefinitionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        serviceEndpointPolicyName
    ],
    headerParameters: [accept],
    serializer: serializer$F
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ServiceTags operations. */
class ServiceTagsImpl {
    /**
     * Initialize a new instance of the class ServiceTags class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of service tag information resources.
     * @param location The location that will be used as a reference for version (not as a filter based on
     *                 location, you will get the list of service tags with prefix details across all regions but limited
     *                 to the cloud that your subscription belongs to).
     * @param options The options parameters.
     */
    list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$s);
    }
}
// Operation Specifications
const serializer$E = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/serviceTags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceTagsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$E
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ServiceTagInformationOperations operations. */
class ServiceTagInformationOperationsImpl {
    /**
     * Initialize a new instance of the class ServiceTagInformationOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of service tag information resources with pagination.
     * @param location The location that will be used as a reference for cloud (not as a filter based on
     *                 location, you will get the list of service tags with prefix details across all regions but limited
     *                 to the cloud that your subscription belongs to).
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of service tag information resources with pagination.
     * @param location The location that will be used as a reference for cloud (not as a filter based on
     *                 location, you will get the list of service tags with prefix details across all regions but limited
     *                 to the cloud that your subscription belongs to).
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$r);
    }
    /**
     * ListNext
     * @param location The location that will be used as a reference for cloud (not as a filter based on
     *                 location, you will get the list of service tags with prefix details across all regions but limited
     *                 to the cloud that your subscription belongs to).
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$n);
    }
}
// Operation Specifications
const serializer$D = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/serviceTagDetails",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceTagInformationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        noAddressPrefixes,
        tagName
    ],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$D
};
const listNextOperationSpec$n = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceTagInformationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location
    ],
    headerParameters: [accept],
    serializer: serializer$D
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Usages operations. */
class UsagesImpl {
    /**
     * Initialize a new instance of the class Usages class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * List network usages for a subscription.
     * @param location The location where resource usage is queried.
     * @param options The options parameters.
     */
    list(location, options) {
        const iter = this.listPagingAll(location, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(location, options, settings);
            }
        };
    }
    listPagingPage(location, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(location, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(location, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(location, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(location, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * List network usages for a subscription.
     * @param location The location where resource usage is queried.
     * @param options The options parameters.
     */
    _list(location, options) {
        return this.client.sendOperationRequest({ location, options }, listOperationSpec$q);
    }
    /**
     * ListNext
     * @param location The location where resource usage is queried.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(location, nextLink, options) {
        return this.client.sendOperationRequest({ location, nextLink, options }, listNextOperationSpec$m);
    }
}
// Operation Specifications
const serializer$C = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$C
};
const listNextOperationSpec$m = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: UsagesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink,
        location1
    ],
    headerParameters: [accept],
    serializer: serializer$C
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworks operations. */
class VirtualNetworksImpl {
    /**
     * Initialize a new instance of the class VirtualNetworks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all virtual networks in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all virtual networks in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists usage stats.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    listUsage(resourceGroupName, virtualNetworkName, options) {
        const iter = this.listUsagePagingAll(resourceGroupName, virtualNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listUsagePagingPage(resourceGroupName, virtualNetworkName, options, settings);
            }
        };
    }
    listUsagePagingPage(resourceGroupName, virtualNetworkName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listUsage(resourceGroupName, virtualNetworkName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listUsageNext(resourceGroupName, virtualNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listUsagePagingAll(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listUsagePagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listUsagePagingPage(resourceGroupName, virtualNetworkName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets the Ddos Protection Status of all IP Addresses under the Virtual Network
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    beginListDdosProtectionStatusAndWait(resourceGroupName, virtualNetworkName, options) {
        const iter = this.listDdosProtectionStatusPagingAll(resourceGroupName, virtualNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listDdosProtectionStatusPagingPage(resourceGroupName, virtualNetworkName, options, settings);
            }
        };
    }
    listDdosProtectionStatusPagingPage(resourceGroupName, virtualNetworkName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listDdosProtectionStatusPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield tslib.__await(this._listDdosProtectionStatus(resourceGroupName, virtualNetworkName, options));
                result = yield tslib.__await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listDdosProtectionStatusNext(resourceGroupName, virtualNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listDdosProtectionStatusPagingAll(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listDdosProtectionStatusPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listDdosProtectionStatusPagingPage(resourceGroupName, virtualNetworkName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Deletes the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkName, options },
                spec: deleteOperationSpec$s
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified virtual network by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, options }, getOperationSpec$u);
    }
    /**
     * Creates or updates a virtual network in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to the create or update virtual network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkName, parameters, options },
                spec: createOrUpdateOperationSpec$s
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a virtual network in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to the create or update virtual network operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a virtual network tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to update virtual network tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, virtualNetworkName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, parameters, options }, updateTagsOperationSpec$b);
    }
    /**
     * Gets all virtual networks in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$2);
    }
    /**
     * Gets all virtual networks in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$p);
    }
    /**
     * Checks whether a private IP address is available for use.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param ipAddress The private IP address to be verified.
     * @param options The options parameters.
     */
    checkIPAddressAvailability(resourceGroupName, virtualNetworkName, ipAddress, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, ipAddress, options }, checkIPAddressAvailabilityOperationSpec);
    }
    /**
     * Lists usage stats.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    _listUsage(resourceGroupName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, options }, listUsageOperationSpec);
    }
    /**
     * Gets the Ddos Protection Status of all IP Addresses under the Virtual Network
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    _listDdosProtectionStatus(resourceGroupName, virtualNetworkName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkName, options },
                spec: listDdosProtectionStatusOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$l);
    }
    /**
     * ListUsageNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param nextLink The nextLink from the previous successful call to the ListUsage method.
     * @param options The options parameters.
     */
    _listUsageNext(resourceGroupName, virtualNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, nextLink, options }, listUsageNextOperationSpec);
    }
    /**
     * ListDdosProtectionStatusNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param nextLink The nextLink from the previous successful call to the ListDdosProtectionStatus
     *                 method.
     * @param options The options parameters.
     */
    _listDdosProtectionStatusNext(resourceGroupName, virtualNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, nextLink, options }, listDdosProtectionStatusNextOperationSpec);
    }
}
// Operation Specifications
const serializer$B = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const getOperationSpec$u = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const createOrUpdateOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        201: {
            bodyMapper: VirtualNetwork
        },
        202: {
            bodyMapper: VirtualNetwork
        },
        204: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters68,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$B
};
const updateTagsOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetwork
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$B
};
const listAllOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$B
};
const listOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const checkIPAddressAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/CheckIPAddressAvailability",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: IPAddressAvailabilityResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, ipAddress],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listUsageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/usages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListUsageResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listDdosProtectionStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/ddosProtectionStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VirtualNetworkDdosProtectionStatusResult
        },
        201: {
            bodyMapper: VirtualNetworkDdosProtectionStatusResult
        },
        202: {
            bodyMapper: VirtualNetworkDdosProtectionStatusResult
        },
        204: {
            bodyMapper: VirtualNetworkDdosProtectionStatusResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [
        apiVersion,
        top1,
        skipToken1
    ],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listAllNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listNextOperationSpec$l = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listUsageNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkListUsageResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};
const listDdosProtectionStatusNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkDdosProtectionStatusResult
        },
        202: {},
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$B
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing Subnets operations. */
class SubnetsImpl {
    /**
     * Initialize a new instance of the class Subnets class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all subnets in a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualNetworkName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualNetworkName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualNetworkName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualNetworkName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualNetworkName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified subnet.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkName, subnetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkName, subnetName, options },
                spec: deleteOperationSpec$r
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified subnet.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkName, subnetName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkName, subnetName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified subnet by virtual network and resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkName, subnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, subnetName, options }, getOperationSpec$t);
    }
    /**
     * Creates or updates a subnet in the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param subnetParameters Parameters supplied to the create or update subnet operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkName, subnetName, subnetParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkName,
                    subnetName,
                    subnetParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$r
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a subnet in the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param subnetParameters Parameters supplied to the create or update subnet operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkName, subnetName, subnetParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkName, subnetName, subnetParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Prepares a subnet by applying network intent policies.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param prepareNetworkPoliciesRequestParameters Parameters supplied to prepare subnet by applying
     *                                                network intent policies.
     * @param options The options parameters.
     */
    beginPrepareNetworkPolicies(resourceGroupName, virtualNetworkName, subnetName, prepareNetworkPoliciesRequestParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkName,
                    subnetName,
                    prepareNetworkPoliciesRequestParameters,
                    options
                },
                spec: prepareNetworkPoliciesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Prepares a subnet by applying network intent policies.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param prepareNetworkPoliciesRequestParameters Parameters supplied to prepare subnet by applying
     *                                                network intent policies.
     * @param options The options parameters.
     */
    beginPrepareNetworkPoliciesAndWait(resourceGroupName, virtualNetworkName, subnetName, prepareNetworkPoliciesRequestParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginPrepareNetworkPolicies(resourceGroupName, virtualNetworkName, subnetName, prepareNetworkPoliciesRequestParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Unprepares a subnet by removing network intent policies.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param unprepareNetworkPoliciesRequestParameters Parameters supplied to unprepare subnet to remove
     *                                                  network intent policies.
     * @param options The options parameters.
     */
    beginUnprepareNetworkPolicies(resourceGroupName, virtualNetworkName, subnetName, unprepareNetworkPoliciesRequestParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkName,
                    subnetName,
                    unprepareNetworkPoliciesRequestParameters,
                    options
                },
                spec: unprepareNetworkPoliciesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Unprepares a subnet by removing network intent policies.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param unprepareNetworkPoliciesRequestParameters Parameters supplied to unprepare subnet to remove
     *                                                  network intent policies.
     * @param options The options parameters.
     */
    beginUnprepareNetworkPoliciesAndWait(resourceGroupName, virtualNetworkName, subnetName, unprepareNetworkPoliciesRequestParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUnprepareNetworkPolicies(resourceGroupName, virtualNetworkName, subnetName, unprepareNetworkPoliciesRequestParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all subnets in a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, options }, listOperationSpec$o);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, nextLink, options }, listNextOperationSpec$k);
    }
}
// Operation Specifications
const serializer$A = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const getOperationSpec$t = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Subnet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const createOrUpdateOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: Subnet
        },
        201: {
            bodyMapper: Subnet
        },
        202: {
            bodyMapper: Subnet
        },
        204: {
            bodyMapper: Subnet
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: subnetParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const prepareNetworkPoliciesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}/PrepareNetworkPolicies",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: prepareNetworkPoliciesRequestParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const unprepareNetworkPoliciesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}/UnprepareNetworkPolicies",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: unprepareNetworkPoliciesRequestParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$A
};
const listOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubnetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};
const listNextOperationSpec$k = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: SubnetListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$A
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ResourceNavigationLinks operations. */
class ResourceNavigationLinksImpl {
    /**
     * Initialize a new instance of the class ResourceNavigationLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of resource navigation links for a subnet.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualNetworkName, subnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, subnetName, options }, listOperationSpec$n);
    }
}
// Operation Specifications
const serializer$z = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}/ResourceNavigationLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ResourceNavigationLinksListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept],
    serializer: serializer$z
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ServiceAssociationLinks operations. */
class ServiceAssociationLinksImpl {
    /**
     * Initialize a new instance of the class ServiceAssociationLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets a list of service association links for a subnet.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param subnetName The name of the subnet.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualNetworkName, subnetName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, subnetName, options }, listOperationSpec$m);
    }
}
// Operation Specifications
const serializer$y = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}/ServiceAssociationLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ServiceAssociationLinksListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        subnetName
    ],
    headerParameters: [accept],
    serializer: serializer$y
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkPeerings operations. */
class VirtualNetworkPeeringsImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkPeerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all virtual network peerings in a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualNetworkName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualNetworkName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualNetworkName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualNetworkName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualNetworkName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualNetworkName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualNetworkName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualNetworkName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified virtual network peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the virtual network peering.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkName,
                    virtualNetworkPeeringName,
                    options
                },
                spec: deleteOperationSpec$q
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified virtual network peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the virtual network peering.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified virtual network peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the virtual network peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualNetworkName,
            virtualNetworkPeeringName,
            options
        }, getOperationSpec$s);
    }
    /**
     * Creates or updates a peering in the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the peering.
     * @param virtualNetworkPeeringParameters Parameters supplied to the create or update virtual network
     *                                        peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, virtualNetworkPeeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkName,
                    virtualNetworkPeeringName,
                    virtualNetworkPeeringParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$q
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a peering in the specified virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param virtualNetworkPeeringName The name of the peering.
     * @param virtualNetworkPeeringParameters Parameters supplied to the create or update virtual network
     *                                        peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, virtualNetworkPeeringParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkName, virtualNetworkPeeringName, virtualNetworkPeeringParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all virtual network peerings in a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualNetworkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, options }, listOperationSpec$l);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualNetworkName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkName, nextLink, options }, listNextOperationSpec$j);
    }
}
// Operation Specifications
const serializer$x = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/virtualNetworkPeerings/{virtualNetworkPeeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        virtualNetworkPeeringName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const getOperationSpec$s = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/virtualNetworkPeerings/{virtualNetworkPeeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        virtualNetworkPeeringName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const createOrUpdateOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/virtualNetworkPeerings/{virtualNetworkPeeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeering
        },
        201: {
            bodyMapper: VirtualNetworkPeering
        },
        202: {
            bodyMapper: VirtualNetworkPeering
        },
        204: {
            bodyMapper: VirtualNetworkPeering
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: virtualNetworkPeeringParameters,
    queryParameters: [apiVersion, syncRemoteAddressSpace],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName,
        virtualNetworkPeeringName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$x
};
const listOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/virtualNetworkPeerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeeringListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};
const listNextOperationSpec$j = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkPeeringListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkName
    ],
    headerParameters: [accept],
    serializer: serializer$x
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkGateways operations. */
class VirtualNetworkGatewaysImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all virtual network gateways by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the connections in a virtual network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    listConnections(resourceGroupName, virtualNetworkGatewayName, options) {
        const iter = this.listConnectionsPagingAll(resourceGroupName, virtualNetworkGatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listConnectionsPagingPage(resourceGroupName, virtualNetworkGatewayName, options, settings);
            }
        };
    }
    listConnectionsPagingPage(resourceGroupName, virtualNetworkGatewayName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listConnectionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listConnections(resourceGroupName, virtualNetworkGatewayName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listConnectionsNext(resourceGroupName, virtualNetworkGatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listConnectionsPagingAll(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listConnectionsPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listConnectionsPagingPage(resourceGroupName, virtualNetworkGatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Creates or updates a virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to create or update virtual network gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$p
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to create or update virtual network gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified virtual network gateway by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, options }, getOperationSpec$r);
    }
    /**
     * Deletes the specified virtual network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, options },
                spec: deleteOperationSpec$p
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified virtual network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a virtual network gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to update virtual network gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayName,
                    parameters,
                    options
                },
                spec: updateTagsOperationSpec$a
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a virtual network gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to update virtual network gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets all virtual network gateways by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$k);
    }
    /**
     * Gets all the connections in a virtual network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    _listConnections(resourceGroupName, virtualNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, options }, listConnectionsOperationSpec);
    }
    /**
     * Resets the primary of the virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginReset(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, options },
                spec: resetOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resets the primary of the virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginResetAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReset(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resets the VPN client shared key of the virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginResetVpnClientSharedKey(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, options },
                spec: resetVpnClientSharedKeyOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resets the VPN client shared key of the virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginResetVpnClientSharedKeyAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetVpnClientSharedKey(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generates VPN client package for P2S client of the virtual network gateway in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to the generate virtual network gateway VPN client package
     *                   operation.
     * @param options The options parameters.
     */
    beginGeneratevpnclientpackage(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayName,
                    parameters,
                    options
                },
                spec: generatevpnclientpackageOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Generates VPN client package for P2S client of the virtual network gateway in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to the generate virtual network gateway VPN client package
     *                   operation.
     * @param options The options parameters.
     */
    beginGeneratevpnclientpackageAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGeneratevpnclientpackage(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generates VPN profile for P2S client of the virtual network gateway in the specified resource group.
     * Used for IKEV2 and radius based authentication.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to the generate virtual network gateway VPN client package
     *                   operation.
     * @param options The options parameters.
     */
    beginGenerateVpnProfile(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayName,
                    parameters,
                    options
                },
                spec: generateVpnProfileOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Generates VPN profile for P2S client of the virtual network gateway in the specified resource group.
     * Used for IKEV2 and radius based authentication.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Parameters supplied to the generate virtual network gateway VPN client package
     *                   operation.
     * @param options The options parameters.
     */
    beginGenerateVpnProfileAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGenerateVpnProfile(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets pre-generated VPN profile for P2S client of the virtual network gateway in the specified
     * resource group. The profile needs to be generated first using generateVpnProfile.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetVpnProfilePackageUrl(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, options },
                spec: getVpnProfilePackageUrlOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets pre-generated VPN profile for P2S client of the virtual network gateway in the specified
     * resource group. The profile needs to be generated first using generateVpnProfile.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetVpnProfilePackageUrlAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetVpnProfilePackageUrl(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The GetBgpPeerStatus operation retrieves the status of all BGP peers.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetBgpPeerStatus(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, options },
                spec: getBgpPeerStatusOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The GetBgpPeerStatus operation retrieves the status of all BGP peers.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetBgpPeerStatusAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetBgpPeerStatus(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a xml format representation for supported vpn devices.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    supportedVpnDevices(resourceGroupName, virtualNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, options }, supportedVpnDevicesOperationSpec);
    }
    /**
     * This operation retrieves a list of routes the virtual network gateway has learned, including routes
     * learned from BGP peers.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetLearnedRoutes(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, options },
                spec: getLearnedRoutesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation retrieves a list of routes the virtual network gateway has learned, including routes
     * learned from BGP peers.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetLearnedRoutesAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetLearnedRoutes(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * This operation retrieves a list of routes the virtual network gateway is advertising to the
     * specified peer.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param peer The IP address of the peer.
     * @param options The options parameters.
     */
    beginGetAdvertisedRoutes(resourceGroupName, virtualNetworkGatewayName, peer, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, peer, options },
                spec: getAdvertisedRoutesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * This operation retrieves a list of routes the virtual network gateway is advertising to the
     * specified peer.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param peer The IP address of the peer.
     * @param options The options parameters.
     */
    beginGetAdvertisedRoutesAndWait(resourceGroupName, virtualNetworkGatewayName, peer, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetAdvertisedRoutes(resourceGroupName, virtualNetworkGatewayName, peer, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Set VpnclientIpsecParameters operation sets the vpnclient ipsec policy for P2S client of virtual
     * network gateway in the specified resource group through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param vpnclientIpsecParams Parameters supplied to the Begin Set vpnclient ipsec parameters of
     *                             Virtual Network Gateway P2S client operation through Network resource provider.
     * @param options The options parameters.
     */
    beginSetVpnclientIpsecParameters(resourceGroupName, virtualNetworkGatewayName, vpnclientIpsecParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayName,
                    vpnclientIpsecParams,
                    options
                },
                spec: setVpnclientIpsecParametersOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The Set VpnclientIpsecParameters operation sets the vpnclient ipsec policy for P2S client of virtual
     * network gateway in the specified resource group through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param vpnclientIpsecParams Parameters supplied to the Begin Set vpnclient ipsec parameters of
     *                             Virtual Network Gateway P2S client operation through Network resource provider.
     * @param options The options parameters.
     */
    beginSetVpnclientIpsecParametersAndWait(resourceGroupName, virtualNetworkGatewayName, vpnclientIpsecParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSetVpnclientIpsecParameters(resourceGroupName, virtualNetworkGatewayName, vpnclientIpsecParams, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Get VpnclientIpsecParameters operation retrieves information about the vpnclient ipsec policy
     * for P2S client of virtual network gateway in the specified resource group through Network resource
     * provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The virtual network gateway name.
     * @param options The options parameters.
     */
    beginGetVpnclientIpsecParameters(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, options },
                spec: getVpnclientIpsecParametersOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The Get VpnclientIpsecParameters operation retrieves information about the vpnclient ipsec policy
     * for P2S client of virtual network gateway in the specified resource group through Network resource
     * provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The virtual network gateway name.
     * @param options The options parameters.
     */
    beginGetVpnclientIpsecParametersAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetVpnclientIpsecParameters(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets a xml format representation for vpn device configuration script.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection for
     *                                            which the configuration script is generated.
     * @param parameters Parameters supplied to the generate vpn device script operation.
     * @param options The options parameters.
     */
    vpnDeviceConfigurationScript(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            virtualNetworkGatewayConnectionName,
            parameters,
            options
        }, vpnDeviceConfigurationScriptOperationSpec);
    }
    /**
     * Starts packet capture on virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginStartPacketCapture(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, options },
                spec: startPacketCaptureOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts packet capture on virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginStartPacketCaptureAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartPacketCapture(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops packet capture on virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Virtual network gateway packet capture parameters supplied to stop packet capture
     *                   on gateway.
     * @param options The options parameters.
     */
    beginStopPacketCapture(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayName,
                    parameters,
                    options
                },
                spec: stopPacketCaptureOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stops packet capture on virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param parameters Virtual network gateway packet capture parameters supplied to stop packet capture
     *                   on gateway.
     * @param options The options parameters.
     */
    beginStopPacketCaptureAndWait(resourceGroupName, virtualNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopPacketCapture(resourceGroupName, virtualNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Get VPN client connection health detail per P2S client connection of the virtual network gateway in
     * the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetVpnclientConnectionHealth(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, options },
                spec: getVpnclientConnectionHealthOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Get VPN client connection health detail per P2S client connection of the virtual network gateway in
     * the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param options The options parameters.
     */
    beginGetVpnclientConnectionHealthAndWait(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetVpnclientConnectionHealth(resourceGroupName, virtualNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Disconnect vpn connections of virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param request The parameters are supplied to disconnect vpn connections.
     * @param options The options parameters.
     */
    beginDisconnectVirtualNetworkGatewayVpnConnections(resourceGroupName, virtualNetworkGatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayName, request, options },
                spec: disconnectVirtualNetworkGatewayVpnConnectionsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Disconnect vpn connections of virtual network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param request The parameters are supplied to disconnect vpn connections.
     * @param options The options parameters.
     */
    beginDisconnectVirtualNetworkGatewayVpnConnectionsAndWait(resourceGroupName, virtualNetworkGatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisconnectVirtualNetworkGatewayVpnConnections(resourceGroupName, virtualNetworkGatewayName, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$i);
    }
    /**
     * ListConnectionsNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayName The name of the virtual network gateway.
     * @param nextLink The nextLink from the previous successful call to the ListConnections method.
     * @param options The options parameters.
     */
    _listConnectionsNext(resourceGroupName, virtualNetworkGatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, nextLink, options }, listConnectionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$w = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGateway
        },
        201: {
            bodyMapper: VirtualNetworkGateway
        },
        202: {
            bodyMapper: VirtualNetworkGateway
        },
        204: {
            bodyMapper: VirtualNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters69,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const getOperationSpec$r = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const deleteOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const updateTagsOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGateway
        },
        201: {
            bodyMapper: VirtualNetworkGateway
        },
        202: {
            bodyMapper: VirtualNetworkGateway
        },
        204: {
            bodyMapper: VirtualNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const listOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const listConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/connections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayListConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const resetOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/reset",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGateway
        },
        201: {
            bodyMapper: VirtualNetworkGateway
        },
        202: {
            bodyMapper: VirtualNetworkGateway
        },
        204: {
            bodyMapper: VirtualNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, gatewayVip],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const resetVpnClientSharedKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/resetvpnclientsharedkey",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const generatevpnclientpackageOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/generatevpnclientpackage",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters70,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const generateVpnProfileOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/generatevpnprofile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters70,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const getVpnProfilePackageUrlOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getvpnprofilepackageurl",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const getBgpPeerStatusOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getBgpPeerStatus",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BgpPeerStatusListResult
        },
        201: {
            bodyMapper: BgpPeerStatusListResult
        },
        202: {
            bodyMapper: BgpPeerStatusListResult
        },
        204: {
            bodyMapper: BgpPeerStatusListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, peer],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const supportedVpnDevicesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/supportedvpndevices",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const getLearnedRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getLearnedRoutes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GatewayRouteListResult
        },
        201: {
            bodyMapper: GatewayRouteListResult
        },
        202: {
            bodyMapper: GatewayRouteListResult
        },
        204: {
            bodyMapper: GatewayRouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const getAdvertisedRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getAdvertisedRoutes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: GatewayRouteListResult
        },
        201: {
            bodyMapper: GatewayRouteListResult
        },
        202: {
            bodyMapper: GatewayRouteListResult
        },
        204: {
            bodyMapper: GatewayRouteListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, peer1],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const setVpnclientIpsecParametersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/setvpnclientipsecparameters",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnClientIPsecParameters
        },
        201: {
            bodyMapper: VpnClientIPsecParameters
        },
        202: {
            bodyMapper: VpnClientIPsecParameters
        },
        204: {
            bodyMapper: VpnClientIPsecParameters
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnclientIpsecParams,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const getVpnclientIpsecParametersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getvpnclientipsecparameters",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnClientIPsecParameters
        },
        201: {
            bodyMapper: VpnClientIPsecParameters
        },
        202: {
            bodyMapper: VpnClientIPsecParameters
        },
        204: {
            bodyMapper: VpnClientIPsecParameters
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const vpnDeviceConfigurationScriptOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/vpndeviceconfigurationscript",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters71,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const startPacketCaptureOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/startPacketCapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters72,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const stopPacketCaptureOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/stopPacketCapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters73,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const getVpnclientConnectionHealthOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/getVpnClientConnectionHealth",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnClientConnectionHealthDetailListResult
        },
        201: {
            bodyMapper: VpnClientConnectionHealthDetailListResult
        },
        202: {
            bodyMapper: VpnClientConnectionHealthDetailListResult
        },
        204: {
            bodyMapper: VpnClientConnectionHealthDetailListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const disconnectVirtualNetworkGatewayVpnConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/disconnectVirtualNetworkGatewayVpnConnections",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$w
};
const listNextOperationSpec$i = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$w
};
const listConnectionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayListConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$w
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkGatewayConnections operations. */
class VirtualNetworkGatewayConnectionsImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkGatewayConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * The List VirtualNetworkGatewayConnections operation retrieves all the virtual network gateways
     * connections created.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates or updates a virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param parameters Parameters supplied to the create or update virtual network gateway connection
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayConnectionName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$o
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param parameters Parameters supplied to the create or update virtual network gateway connection
     *                   operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified virtual network gateway connection by resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayConnectionName, options }, getOperationSpec$q);
    }
    /**
     * Deletes the specified virtual network Gateway connection.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayConnectionName, options },
                spec: deleteOperationSpec$o
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified virtual network Gateway connection.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkGatewayConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a virtual network gateway connection tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param parameters Parameters supplied to update virtual network gateway connection tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayConnectionName,
                    parameters,
                    options
                },
                spec: updateTagsOperationSpec$9
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates a virtual network gateway connection tags.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param parameters Parameters supplied to update virtual network gateway connection tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Put VirtualNetworkGatewayConnectionSharedKey operation sets the virtual network gateway
     * connection shared key for passed virtual network gateway connection in the specified resource group
     * through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection name.
     * @param parameters Parameters supplied to the Begin Set Virtual Network Gateway connection Shared key
     *                   operation throughNetwork resource provider.
     * @param options The options parameters.
     */
    beginSetSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayConnectionName,
                    parameters,
                    options
                },
                spec: setSharedKeyOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The Put VirtualNetworkGatewayConnectionSharedKey operation sets the virtual network gateway
     * connection shared key for passed virtual network gateway connection in the specified resource group
     * through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection name.
     * @param parameters Parameters supplied to the Begin Set Virtual Network Gateway connection Shared key
     *                   operation throughNetwork resource provider.
     * @param options The options parameters.
     */
    beginSetSharedKeyAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginSetSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * The Get VirtualNetworkGatewayConnectionSharedKey operation retrieves information about the specified
     * virtual network gateway connection shared key through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection shared key name.
     * @param options The options parameters.
     */
    getSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayConnectionName, options }, getSharedKeyOperationSpec);
    }
    /**
     * The List VirtualNetworkGatewayConnections operation retrieves all the virtual network gateways
     * connections created.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$j);
    }
    /**
     * The VirtualNetworkGatewayConnectionResetSharedKey operation resets the virtual network gateway
     * connection shared key for passed virtual network gateway connection in the specified resource group
     * through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection reset shared key
     *                                            Name.
     * @param parameters Parameters supplied to the begin reset virtual network gateway connection shared
     *                   key operation through network resource provider.
     * @param options The options parameters.
     */
    beginResetSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayConnectionName,
                    parameters,
                    options
                },
                spec: resetSharedKeyOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * The VirtualNetworkGatewayConnectionResetSharedKey operation resets the virtual network gateway
     * connection shared key for passed virtual network gateway connection in the specified resource group
     * through Network resource provider.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The virtual network gateway connection reset shared key
     *                                            Name.
     * @param parameters Parameters supplied to the begin reset virtual network gateway connection shared
     *                   key operation through network resource provider.
     * @param options The options parameters.
     */
    beginResetSharedKeyAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetSharedKey(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts packet capture on virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    beginStartPacketCapture(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayConnectionName, options },
                spec: startPacketCaptureOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts packet capture on virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway connection.
     * @param options The options parameters.
     */
    beginStartPacketCaptureAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartPacketCapture(resourceGroupName, virtualNetworkGatewayConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops packet capture on virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param parameters Virtual network gateway packet capture parameters supplied to stop packet capture
     *                   on gateway connection.
     * @param options The options parameters.
     */
    beginStopPacketCapture(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayConnectionName,
                    parameters,
                    options
                },
                spec: stopPacketCaptureOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stops packet capture on virtual network gateway connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param parameters Virtual network gateway packet capture parameters supplied to stop packet capture
     *                   on gateway connection.
     * @param options The options parameters.
     */
    beginStopPacketCaptureAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopPacketCapture(resourceGroupName, virtualNetworkGatewayConnectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists IKE Security Associations for the virtual network gateway connection in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param options The options parameters.
     */
    beginGetIkeSas(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayConnectionName, options },
                spec: getIkeSasOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Lists IKE Security Associations for the virtual network gateway connection in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param options The options parameters.
     */
    beginGetIkeSasAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetIkeSas(resourceGroupName, virtualNetworkGatewayConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resets the virtual network gateway connection specified.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param options The options parameters.
     */
    beginResetConnection(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualNetworkGatewayConnectionName, options },
                spec: resetConnectionOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resets the virtual network gateway connection specified.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkGatewayConnectionName The name of the virtual network gateway Connection.
     * @param options The options parameters.
     */
    beginResetConnectionAndWait(resourceGroupName, virtualNetworkGatewayConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetConnection(resourceGroupName, virtualNetworkGatewayConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$h);
    }
}
// Operation Specifications
const serializer$v = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        201: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        202: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        204: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters74,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const getOperationSpec$q = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const deleteOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const updateTagsOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        201: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        202: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        204: {
            bodyMapper: VirtualNetworkGatewayConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const setSharedKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/sharedkey",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ConnectionSharedKey
        },
        201: {
            bodyMapper: ConnectionSharedKey
        },
        202: {
            bodyMapper: ConnectionSharedKey
        },
        204: {
            bodyMapper: ConnectionSharedKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters75,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const getSharedKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/sharedkey",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ConnectionSharedKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const listOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const resetSharedKeyOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/sharedkey/reset",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ConnectionResetSharedKey
        },
        201: {
            bodyMapper: ConnectionResetSharedKey
        },
        202: {
            bodyMapper: ConnectionResetSharedKey
        },
        204: {
            bodyMapper: ConnectionResetSharedKey
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters76,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const startPacketCaptureOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/startPacketCapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters72,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const stopPacketCaptureOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/stopPacketCapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters73,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$v
};
const getIkeSasOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/getikesas",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const resetConnectionOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/connections/{virtualNetworkGatewayConnectionName}/resetconnection",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$v
};
const listNextOperationSpec$h = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayConnectionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$v
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing LocalNetworkGateways operations. */
class LocalNetworkGatewaysImpl {
    /**
     * Initialize a new instance of the class LocalNetworkGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the local network gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates or updates a local network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param parameters Parameters supplied to the create or update local network gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, localNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, localNetworkGatewayName, parameters, options },
                spec: createOrUpdateOperationSpec$n
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a local network gateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param parameters Parameters supplied to the create or update local network gateway operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, localNetworkGatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, localNetworkGatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified local network gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, localNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, localNetworkGatewayName, options }, getOperationSpec$p);
    }
    /**
     * Deletes the specified local network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, localNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, localNetworkGatewayName, options },
                spec: deleteOperationSpec$n
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified local network gateway.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, localNetworkGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, localNetworkGatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a local network gateway tags.
     * @param resourceGroupName The name of the resource group.
     * @param localNetworkGatewayName The name of the local network gateway.
     * @param parameters Parameters supplied to update local network gateway tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, localNetworkGatewayName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, localNetworkGatewayName, parameters, options }, updateTagsOperationSpec$8);
    }
    /**
     * Gets all the local network gateways in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec$i);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec$g);
    }
}
// Operation Specifications
const serializer$u = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways/{localNetworkGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: LocalNetworkGateway
        },
        201: {
            bodyMapper: LocalNetworkGateway
        },
        202: {
            bodyMapper: LocalNetworkGateway
        },
        204: {
            bodyMapper: LocalNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters77,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        localNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const getOperationSpec$p = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways/{localNetworkGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocalNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        localNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const deleteOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways/{localNetworkGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        localNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const updateTagsOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways/{localNetworkGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: LocalNetworkGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        localNetworkGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$u
};
const listOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/localNetworkGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocalNetworkGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$u
};
const listNextOperationSpec$g = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: LocalNetworkGatewayListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$u
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkGatewayNatRules operations. */
class VirtualNetworkGatewayNatRulesImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkGatewayNatRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all nat rules for a particular virtual network gateway.
     * @param resourceGroupName The resource group name of the virtual network gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param options The options parameters.
     */
    listByVirtualNetworkGateway(resourceGroupName, virtualNetworkGatewayName, options) {
        const iter = this.listByVirtualNetworkGatewayPagingAll(resourceGroupName, virtualNetworkGatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByVirtualNetworkGatewayPagingPage(resourceGroupName, virtualNetworkGatewayName, options, settings);
            }
        };
    }
    listByVirtualNetworkGatewayPagingPage(resourceGroupName, virtualNetworkGatewayName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByVirtualNetworkGatewayPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByVirtualNetworkGateway(resourceGroupName, virtualNetworkGatewayName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByVirtualNetworkGatewayNext(resourceGroupName, virtualNetworkGatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByVirtualNetworkGatewayPagingAll(resourceGroupName, virtualNetworkGatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVirtualNetworkGatewayPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVirtualNetworkGatewayPagingPage(resourceGroupName, virtualNetworkGatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a nat rule.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualNetworkGatewayName, natRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, natRuleName, options }, getOperationSpec$o);
    }
    /**
     * Creates a nat rule to a scalable virtual network gateway if it doesn't exist else updates the
     * existing nat rules.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param natRuleParameters Parameters supplied to create or Update a Nat Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayName, natRuleName, natRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayName,
                    natRuleName,
                    natRuleParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$m
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a nat rule to a scalable virtual network gateway if it doesn't exist else updates the
     * existing nat rules.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param natRuleParameters Parameters supplied to create or Update a Nat Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualNetworkGatewayName, natRuleName, natRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualNetworkGatewayName, natRuleName, natRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a nat rule.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualNetworkGatewayName, natRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualNetworkGatewayName,
                    natRuleName,
                    options
                },
                spec: deleteOperationSpec$m
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a nat rule.
     * @param resourceGroupName The resource group name of the Virtual Network Gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualNetworkGatewayName, natRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualNetworkGatewayName, natRuleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves all nat rules for a particular virtual network gateway.
     * @param resourceGroupName The resource group name of the virtual network gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param options The options parameters.
     */
    _listByVirtualNetworkGateway(resourceGroupName, virtualNetworkGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, options }, listByVirtualNetworkGatewayOperationSpec);
    }
    /**
     * ListByVirtualNetworkGatewayNext
     * @param resourceGroupName The resource group name of the virtual network gateway.
     * @param virtualNetworkGatewayName The name of the gateway.
     * @param nextLink The nextLink from the previous successful call to the ListByVirtualNetworkGateway
     *                 method.
     * @param options The options parameters.
     */
    _listByVirtualNetworkGatewayNext(resourceGroupName, virtualNetworkGatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualNetworkGatewayName, nextLink, options }, listByVirtualNetworkGatewayNextOperationSpec);
    }
}
// Operation Specifications
const serializer$t = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$o = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/natRules/{natRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName,
        natRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const createOrUpdateOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/natRules/{natRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        201: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        202: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        204: {
            bodyMapper: VirtualNetworkGatewayNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: natRuleParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName,
        natRuleName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$t
};
const deleteOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/natRules/{natRuleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName,
        natRuleName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listByVirtualNetworkGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkGateways/{virtualNetworkGatewayName}/natRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualNetworkGatewayNatRulesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};
const listByVirtualNetworkGatewayNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualNetworkGatewayNatRulesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualNetworkGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$t
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualNetworkTaps operations. */
class VirtualNetworkTapsImpl {
    /**
     * Initialize a new instance of the class VirtualNetworkTaps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets all the VirtualNetworkTaps in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the VirtualNetworkTaps in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified virtual network tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the virtual network tap.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, tapName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, tapName, options },
                spec: deleteOperationSpec$l
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified virtual network tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the virtual network tap.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, tapName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, tapName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets information about the specified virtual network tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of virtual network tap.
     * @param options The options parameters.
     */
    get(resourceGroupName, tapName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, tapName, options }, getOperationSpec$n);
    }
    /**
     * Creates or updates a Virtual Network Tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the virtual network tap.
     * @param parameters Parameters supplied to the create or update virtual network tap operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, tapName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, tapName, parameters, options },
                spec: createOrUpdateOperationSpec$l
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a Virtual Network Tap.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the virtual network tap.
     * @param parameters Parameters supplied to the create or update virtual network tap operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, tapName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, tapName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates an VirtualNetworkTap tags.
     * @param resourceGroupName The name of the resource group.
     * @param tapName The name of the tap.
     * @param tapParameters Parameters supplied to update VirtualNetworkTap tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, tapName, tapParameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, tapName, tapParameters, options }, updateTagsOperationSpec$7);
    }
    /**
     * Gets all the VirtualNetworkTaps in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec$1);
    }
    /**
     * Gets all the VirtualNetworkTaps in a subscription.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$8);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec$1);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$s = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps/{tapName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        tapName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const getOperationSpec$n = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps/{tapName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTap
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        tapName
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const createOrUpdateOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps/{tapName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTap
        },
        201: {
            bodyMapper: VirtualNetworkTap
        },
        202: {
            bodyMapper: VirtualNetworkTap
        },
        204: {
            bodyMapper: VirtualNetworkTap
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters78,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        tapName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$s
};
const updateTagsOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps/{tapName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTap
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: tapParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        tapName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$s
};
const listAllOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualNetworkTaps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTapListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$s
};
const listByResourceGroupOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworkTaps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTapListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const listAllNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTapListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$s
};
const listByResourceGroupNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualNetworkTapListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$s
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualRouters operations. */
class VirtualRoutersImpl {
    /**
     * Initialize a new instance of the class VirtualRouters class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Virtual Routers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the Virtual Routers in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Deletes the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualRouterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualRouterName, options },
                spec: deleteOperationSpec$k
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualRouterName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualRouterName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualRouterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualRouterName, options }, getOperationSpec$m);
    }
    /**
     * Creates or updates the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param parameters Parameters supplied to the create or update Virtual Router.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualRouterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualRouterName, parameters, options },
                spec: createOrUpdateOperationSpec$k
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param parameters Parameters supplied to the create or update Virtual Router.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualRouterName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualRouterName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Virtual Routers in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$7);
    }
    /**
     * Gets all the Virtual Routers in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$h);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$6);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$f);
    }
}
// Operation Specifications
const serializer$r = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const getOperationSpec$m = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouter
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion, expand],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const createOrUpdateOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualRouter
        },
        201: {
            bodyMapper: VirtualRouter
        },
        202: {
            bodyMapper: VirtualRouter
        },
        204: {
            bodyMapper: VirtualRouter
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters79,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualRouterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$r
};
const listByResourceGroupOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualRouters",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$r
};
const listByResourceGroupNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$r
};
const listNextOperationSpec$f = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$r
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualRouterPeerings operations. */
class VirtualRouterPeeringsImpl {
    /**
     * Initialize a new instance of the class VirtualRouterPeerings class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all Virtual Router Peerings in a Virtual Router resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualRouterName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualRouterName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualRouterName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualRouterName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualRouterName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualRouterName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualRouterName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualRouterName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Deletes the specified peering from a Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualRouterName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualRouterName, peeringName, options },
                spec: deleteOperationSpec$j
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified peering from a Virtual Router.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the peering.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualRouterName, peeringName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualRouterName, peeringName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified Virtual Router Peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the Virtual Router Peering.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualRouterName, peeringName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualRouterName, peeringName, options }, getOperationSpec$l);
    }
    /**
     * Creates or updates the specified Virtual Router Peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the Virtual Router Peering.
     * @param parameters Parameters supplied to the create or update Virtual Router Peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualRouterName, peeringName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualRouterName,
                    peeringName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$j
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates the specified Virtual Router Peering.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param peeringName The name of the Virtual Router Peering.
     * @param parameters Parameters supplied to the create or update Virtual Router Peering operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualRouterName, peeringName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualRouterName, peeringName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all Virtual Router Peerings in a Virtual Router resource.
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualRouterName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualRouterName, options }, listOperationSpec$g);
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param virtualRouterName The name of the Virtual Router.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualRouterName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualRouterName, nextLink, options }, listNextOperationSpec$e);
    }
}
// Operation Specifications
const serializer$q = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const deleteOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}/peerings/{peeringName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const getOperationSpec$l = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}/peerings/{peeringName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterPeering
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const createOrUpdateOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}/peerings/{peeringName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualRouterPeering
        },
        201: {
            bodyMapper: VirtualRouterPeering
        },
        202: {
            bodyMapper: VirtualRouterPeering
        },
        204: {
            bodyMapper: VirtualRouterPeering
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: parameters80,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        peeringName,
        virtualRouterName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$q
};
const listOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualRouters/{virtualRouterName}/peerings",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterPeeringListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};
const listNextOperationSpec$e = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualRouterPeeringListResult
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualRouterName
    ],
    headerParameters: [accept],
    serializer: serializer$q
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualWans operations. */
class VirtualWansImpl {
    /**
     * Initialize a new instance of the class VirtualWans class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the VirtualWANs in a resource group.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VirtualWANs in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualWANName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualWANName, options }, getOperationSpec$k);
    }
    /**
     * Creates a VirtualWAN resource if it doesn't exist else updates the existing VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being created or updated.
     * @param wANParameters Parameters supplied to create or update VirtualWAN.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualWANName, wANParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualWANName, wANParameters, options },
                spec: createOrUpdateOperationSpec$i
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a VirtualWAN resource if it doesn't exist else updates the existing VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being created or updated.
     * @param wANParameters Parameters supplied to create or update VirtualWAN.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualWANName, wANParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualWANName, wANParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates a VirtualWAN tags.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being updated.
     * @param wANParameters Parameters supplied to Update VirtualWAN tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, virtualWANName, wANParameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualWANName, wANParameters, options }, updateTagsOperationSpec$6);
    }
    /**
     * Deletes a VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualWANName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualWANName, options },
                spec: deleteOperationSpec$i
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a VirtualWAN.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param virtualWANName The name of the VirtualWAN being deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualWANName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualWANName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the VirtualWANs in a resource group.
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$6);
    }
    /**
     * Lists all the VirtualWANs in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$f);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VirtualWan.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$5);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$d);
    }
}
// Operation Specifications
const serializer$p = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$k = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{VirtualWANName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualWAN
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName1
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const createOrUpdateOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{VirtualWANName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualWAN
        },
        201: {
            bodyMapper: VirtualWAN
        },
        202: {
            bodyMapper: VirtualWAN
        },
        204: {
            bodyMapper: VirtualWAN
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: wANParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const updateTagsOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{VirtualWANName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualWAN
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: wANParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName1
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$p
};
const deleteOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{VirtualWANName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName1
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listByResourceGroupOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualWANsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualWans",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualWANsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$p
};
const listByResourceGroupNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualWANsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$p
};
const listNextOperationSpec$d = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualWANsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$p
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnSites operations. */
class VpnSitesImpl {
    /**
     * Initialize a new instance of the class VpnSites class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the vpnSites in a resource group.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VpnSites in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VPN site.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, vpnSiteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, options }, getOperationSpec$j);
    }
    /**
     * Creates a VpnSite resource if it doesn't exist else updates the existing VpnSite.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being created or updated.
     * @param vpnSiteParameters Parameters supplied to create or update VpnSite.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vpnSiteName, vpnSiteParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vpnSiteName, vpnSiteParameters, options },
                spec: createOrUpdateOperationSpec$h
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a VpnSite resource if it doesn't exist else updates the existing VpnSite.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being created or updated.
     * @param vpnSiteParameters Parameters supplied to create or update VpnSite.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vpnSiteName, vpnSiteParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vpnSiteName, vpnSiteParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates VpnSite tags.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being updated.
     * @param vpnSiteParameters Parameters supplied to update VpnSite tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, vpnSiteName, vpnSiteParameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, vpnSiteParameters, options }, updateTagsOperationSpec$5);
    }
    /**
     * Deletes a VpnSite.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vpnSiteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vpnSiteName, options },
                spec: deleteOperationSpec$h
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a VpnSite.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite being deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vpnSiteName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vpnSiteName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the vpnSites in a resource group.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$5);
    }
    /**
     * Lists all the VpnSites in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$e);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$4);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$c);
    }
}
// Operation Specifications
const serializer$o = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$j = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const createOrUpdateOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnSite
        },
        201: {
            bodyMapper: VpnSite
        },
        202: {
            bodyMapper: VpnSite
        },
        204: {
            bodyMapper: VpnSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnSiteParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o
};
const updateTagsOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VpnSite
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnSiteParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$o
};
const deleteOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listByResourceGroupOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSitesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/vpnSites",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSitesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$o
};
const listByResourceGroupNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSitesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$o
};
const listNextOperationSpec$c = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSitesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$o
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnSiteLinks operations. */
class VpnSiteLinksImpl {
    /**
     * Initialize a new instance of the class VpnSiteLinks class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the vpnSiteLinks in a resource group for a vpn site.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite.
     * @param options The options parameters.
     */
    listByVpnSite(resourceGroupName, vpnSiteName, options) {
        const iter = this.listByVpnSitePagingAll(resourceGroupName, vpnSiteName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByVpnSitePagingPage(resourceGroupName, vpnSiteName, options, settings);
            }
        };
    }
    listByVpnSitePagingPage(resourceGroupName, vpnSiteName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnSitePagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByVpnSite(resourceGroupName, vpnSiteName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByVpnSiteNext(resourceGroupName, vpnSiteName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByVpnSitePagingAll(resourceGroupName, vpnSiteName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnSitePagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVpnSitePagingPage(resourceGroupName, vpnSiteName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VPN site link.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite.
     * @param vpnSiteLinkName The name of the VpnSiteLink being retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, vpnSiteName, vpnSiteLinkName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, vpnSiteLinkName, options }, getOperationSpec$i);
    }
    /**
     * Lists all the vpnSiteLinks in a resource group for a vpn site.
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite.
     * @param options The options parameters.
     */
    _listByVpnSite(resourceGroupName, vpnSiteName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, options }, listByVpnSiteOperationSpec);
    }
    /**
     * ListByVpnSiteNext
     * @param resourceGroupName The resource group name of the VpnSite.
     * @param vpnSiteName The name of the VpnSite.
     * @param nextLink The nextLink from the previous successful call to the ListByVpnSite method.
     * @param options The options parameters.
     */
    _listByVpnSiteNext(resourceGroupName, vpnSiteName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnSiteName, nextLink, options }, listByVpnSiteNextOperationSpec);
    }
}
// Operation Specifications
const serializer$n = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$i = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}/vpnSiteLinks/{vpnSiteLinkName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnSiteLink
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName,
        vpnSiteLinkName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listByVpnSiteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnSites/{vpnSiteName}/vpnSiteLinks",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSiteLinksResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};
const listByVpnSiteNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSiteLinksResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        vpnSiteName
    ],
    headerParameters: [accept],
    serializer: serializer$n
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VpnSitesConfiguration operations. */
class VpnSitesConfigurationImpl {
    /**
     * Initialize a new instance of the class VpnSitesConfiguration class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gives the sas-url to download the configurations for vpn-sites in a resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN for which configuration of all vpn-sites is needed.
     * @param request Parameters supplied to download vpn-sites configuration.
     * @param options The options parameters.
     */
    beginDownload(resourceGroupName, virtualWANName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualWANName, request, options },
                spec: downloadOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gives the sas-url to download the configurations for vpn-sites in a resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN for which configuration of all vpn-sites is needed.
     * @param request Parameters supplied to download vpn-sites configuration.
     * @param options The options parameters.
     */
    beginDownloadAndWait(resourceGroupName, virtualWANName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDownload(resourceGroupName, virtualWANName, request, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$m = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const downloadOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/vpnConfiguration",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request2,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$m
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnServerConfigurations operations. */
class VpnServerConfigurationsImpl {
    /**
     * Initialize a new instance of the class VpnServerConfigurations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the vpnServerConfigurations in a resource group.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VpnServerConfigurations in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, vpnServerConfigurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnServerConfigurationName, options }, getOperationSpec$h);
    }
    /**
     * Creates a VpnServerConfiguration resource if it doesn't exist else updates the existing
     * VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being created or updated.
     * @param vpnServerConfigurationParameters Parameters supplied to create or update
     *                                         VpnServerConfiguration.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vpnServerConfigurationName, vpnServerConfigurationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vpnServerConfigurationName,
                    vpnServerConfigurationParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$g
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a VpnServerConfiguration resource if it doesn't exist else updates the existing
     * VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being created or updated.
     * @param vpnServerConfigurationParameters Parameters supplied to create or update
     *                                         VpnServerConfiguration.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vpnServerConfigurationName, vpnServerConfigurationParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vpnServerConfigurationName, vpnServerConfigurationParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates VpnServerConfiguration tags.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being updated.
     * @param vpnServerConfigurationParameters Parameters supplied to update VpnServerConfiguration tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, vpnServerConfigurationName, vpnServerConfigurationParameters, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vpnServerConfigurationName,
            vpnServerConfigurationParameters,
            options
        }, updateTagsOperationSpec$4);
    }
    /**
     * Deletes a VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being deleted.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vpnServerConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, vpnServerConfigurationName, options },
                spec: deleteOperationSpec$g
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a VpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration being deleted.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vpnServerConfigurationName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vpnServerConfigurationName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the vpnServerConfigurations in a resource group.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$4);
    }
    /**
     * Lists all the VpnServerConfigurations in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$d);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$3);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$b);
    }
}
// Operation Specifications
const serializer$l = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$h = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnServerConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const createOrUpdateOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnServerConfiguration
        },
        201: {
            bodyMapper: VpnServerConfiguration
        },
        202: {
            bodyMapper: VpnServerConfiguration
        },
        204: {
            bodyMapper: VpnServerConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnServerConfigurationParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const updateTagsOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VpnServerConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnServerConfigurationParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$l
};
const deleteOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByResourceGroupOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/vpnServerConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$l
};
const listByResourceGroupNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};
const listNextOperationSpec$b = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$l
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing ConfigurationPolicyGroups operations. */
class ConfigurationPolicyGroupsImpl {
    /**
     * Initialize a new instance of the class ConfigurationPolicyGroups class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the configurationPolicyGroups in a resource group for a vpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration.
     * @param options The options parameters.
     */
    listByVpnServerConfiguration(resourceGroupName, vpnServerConfigurationName, options) {
        const iter = this.listByVpnServerConfigurationPagingAll(resourceGroupName, vpnServerConfigurationName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByVpnServerConfigurationPagingPage(resourceGroupName, vpnServerConfigurationName, options, settings);
            }
        };
    }
    listByVpnServerConfigurationPagingPage(resourceGroupName, vpnServerConfigurationName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnServerConfigurationPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByVpnServerConfiguration(resourceGroupName, vpnServerConfigurationName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByVpnServerConfigurationNext(resourceGroupName, vpnServerConfigurationName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByVpnServerConfigurationPagingAll(resourceGroupName, vpnServerConfigurationName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnServerConfigurationPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVpnServerConfigurationPagingPage(resourceGroupName, vpnServerConfigurationName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a ConfigurationPolicyGroup if it doesn't exist else updates the existing one.
     * @param resourceGroupName The resource group name of the ConfigurationPolicyGroup.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration.
     * @param configurationPolicyGroupName The name of the ConfigurationPolicyGroup.
     * @param vpnServerConfigurationPolicyGroupParameters Parameters supplied to create or update a
     *                                                    VpnServerConfiguration PolicyGroup.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, vpnServerConfigurationName, configurationPolicyGroupName, vpnServerConfigurationPolicyGroupParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vpnServerConfigurationName,
                    configurationPolicyGroupName,
                    vpnServerConfigurationPolicyGroupParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$f
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a ConfigurationPolicyGroup if it doesn't exist else updates the existing one.
     * @param resourceGroupName The resource group name of the ConfigurationPolicyGroup.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration.
     * @param configurationPolicyGroupName The name of the ConfigurationPolicyGroup.
     * @param vpnServerConfigurationPolicyGroupParameters Parameters supplied to create or update a
     *                                                    VpnServerConfiguration PolicyGroup.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, vpnServerConfigurationName, configurationPolicyGroupName, vpnServerConfigurationPolicyGroupParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, vpnServerConfigurationName, configurationPolicyGroupName, vpnServerConfigurationPolicyGroupParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a ConfigurationPolicyGroup.
     * @param resourceGroupName The resource group name of the ConfigurationPolicyGroup.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration.
     * @param configurationPolicyGroupName The name of the ConfigurationPolicyGroup.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, vpnServerConfigurationName, configurationPolicyGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    vpnServerConfigurationName,
                    configurationPolicyGroupName,
                    options
                },
                spec: deleteOperationSpec$f
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a ConfigurationPolicyGroup.
     * @param resourceGroupName The resource group name of the ConfigurationPolicyGroup.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration.
     * @param configurationPolicyGroupName The name of the ConfigurationPolicyGroup.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, vpnServerConfigurationName, configurationPolicyGroupName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, vpnServerConfigurationName, configurationPolicyGroupName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of a ConfigurationPolicyGroup.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration.
     * @param configurationPolicyGroupName The name of the ConfigurationPolicyGroup being retrieved.
     * @param options The options parameters.
     */
    get(resourceGroupName, vpnServerConfigurationName, configurationPolicyGroupName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            vpnServerConfigurationName,
            configurationPolicyGroupName,
            options
        }, getOperationSpec$g);
    }
    /**
     * Lists all the configurationPolicyGroups in a resource group for a vpnServerConfiguration.
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration.
     * @param options The options parameters.
     */
    _listByVpnServerConfiguration(resourceGroupName, vpnServerConfigurationName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnServerConfigurationName, options }, listByVpnServerConfigurationOperationSpec);
    }
    /**
     * ListByVpnServerConfigurationNext
     * @param resourceGroupName The resource group name of the VpnServerConfiguration.
     * @param vpnServerConfigurationName The name of the VpnServerConfiguration.
     * @param nextLink The nextLink from the previous successful call to the ListByVpnServerConfiguration
     *                 method.
     * @param options The options parameters.
     */
    _listByVpnServerConfigurationNext(resourceGroupName, vpnServerConfigurationName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, vpnServerConfigurationName, nextLink, options }, listByVpnServerConfigurationNextOperationSpec);
    }
}
// Operation Specifications
const serializer$k = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}/configurationPolicyGroups/{configurationPolicyGroupName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnServerConfigurationPolicyGroup
        },
        201: {
            bodyMapper: VpnServerConfigurationPolicyGroup
        },
        202: {
            bodyMapper: VpnServerConfigurationPolicyGroup
        },
        204: {
            bodyMapper: VpnServerConfigurationPolicyGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnServerConfigurationPolicyGroupParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName,
        configurationPolicyGroupName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$k
};
const deleteOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}/configurationPolicyGroups/{configurationPolicyGroupName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName,
        configurationPolicyGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const getOperationSpec$g = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}/configurationPolicyGroups/{configurationPolicyGroupName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnServerConfigurationPolicyGroup
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName,
        configurationPolicyGroupName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByVpnServerConfigurationOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnServerConfigurations/{vpnServerConfigurationName}/configurationPolicyGroups",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationPolicyGroupsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        vpnServerConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};
const listByVpnServerConfigurationNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnServerConfigurationPolicyGroupsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        vpnServerConfigurationName
    ],
    headerParameters: [accept],
    serializer: serializer$k
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualHubs operations. */
class VirtualHubsImpl {
    /**
     * Initialize a new instance of the class VirtualHubs class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the VirtualHubs in a resource group.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VirtualHubs in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, getOperationSpec$f);
    }
    /**
     * Creates a VirtualHub resource if it doesn't exist else updates the existing VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param virtualHubParameters Parameters supplied to create or update VirtualHub.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, virtualHubParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    virtualHubParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$e
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a VirtualHub resource if it doesn't exist else updates the existing VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param virtualHubParameters Parameters supplied to create or update VirtualHub.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, virtualHubParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, virtualHubParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates VirtualHub tags.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param virtualHubParameters Parameters supplied to update VirtualHub tags.
     * @param options The options parameters.
     */
    updateTags(resourceGroupName, virtualHubName, virtualHubParameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, virtualHubParameters, options }, updateTagsOperationSpec$3);
    }
    /**
     * Deletes a VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualHubName, options },
                spec: deleteOperationSpec$e
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the VirtualHubs in a resource group.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$3);
    }
    /**
     * Lists all the VirtualHubs in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$c);
    }
    /**
     * Gets the effective routes configured for the Virtual Hub resource or the specified resource .
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    beginGetEffectiveVirtualHubRoutes(resourceGroupName, virtualHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualHubName, options },
                spec: getEffectiveVirtualHubRoutesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the effective routes configured for the Virtual Hub resource or the specified resource .
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    beginGetEffectiveVirtualHubRoutesAndWait(resourceGroupName, virtualHubName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetEffectiveVirtualHubRoutes(resourceGroupName, virtualHubName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the inbound routes configured for the Virtual Hub on a particular connection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param getInboundRoutesParameters Parameters supplied to get the inbound routes for a connection
     *                                   resource.
     * @param options The options parameters.
     */
    beginGetInboundRoutes(resourceGroupName, virtualHubName, getInboundRoutesParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    getInboundRoutesParameters,
                    options
                },
                spec: getInboundRoutesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the inbound routes configured for the Virtual Hub on a particular connection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param getInboundRoutesParameters Parameters supplied to get the inbound routes for a connection
     *                                   resource.
     * @param options The options parameters.
     */
    beginGetInboundRoutesAndWait(resourceGroupName, virtualHubName, getInboundRoutesParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetInboundRoutes(resourceGroupName, virtualHubName, getInboundRoutesParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the outbound routes configured for the Virtual Hub on a particular connection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param getOutboundRoutesParameters Parameters supplied to get the outbound routes for a connection
     *                                    resource.
     * @param options The options parameters.
     */
    beginGetOutboundRoutes(resourceGroupName, virtualHubName, getOutboundRoutesParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    getOutboundRoutesParameters,
                    options
                },
                spec: getOutboundRoutesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the outbound routes configured for the Virtual Hub on a particular connection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param getOutboundRoutesParameters Parameters supplied to get the outbound routes for a connection
     *                                    resource.
     * @param options The options parameters.
     */
    beginGetOutboundRoutesAndWait(resourceGroupName, virtualHubName, getOutboundRoutesParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetOutboundRoutes(resourceGroupName, virtualHubName, getOutboundRoutesParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$2);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$a);
    }
}
// Operation Specifications
const serializer$j = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$f = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualHub
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const createOrUpdateOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualHub
        },
        201: {
            bodyMapper: VirtualHub
        },
        202: {
            bodyMapper: VirtualHub
        },
        204: {
            bodyMapper: VirtualHub
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: virtualHubParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const updateTagsOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VirtualHub
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: virtualHubParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const deleteOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listByResourceGroupOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/virtualHubs",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$j
};
const getEffectiveVirtualHubRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/effectiveRoutes",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: effectiveRoutesParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const getInboundRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/inboundRoutes",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: getInboundRoutesParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const getOutboundRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/outboundRoutes",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: getOutboundRoutesParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$j
};
const listByResourceGroupNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$j
};
const listNextOperationSpec$a = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$j
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RouteMaps operations. */
class RouteMapsImpl {
    /**
     * Initialize a new instance of the class RouteMaps class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all RouteMaps.
     * @param resourceGroupName The resource group name of the RouteMap's resource group'.
     * @param virtualHubName The name of the VirtualHub containing the RouteMap.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualHubName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a RouteMap.
     * @param resourceGroupName The resource group name of the RouteMap's resource group.
     * @param virtualHubName The name of the VirtualHub containing the RouteMap.
     * @param routeMapName The name of the RouteMap.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, routeMapName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, routeMapName, options }, getOperationSpec$e);
    }
    /**
     * Creates a RouteMap if it doesn't exist else updates the existing one.
     * @param resourceGroupName The resource group name of the RouteMap's resource group.
     * @param virtualHubName The name of the VirtualHub containing the RouteMap.
     * @param routeMapName The name of the RouteMap.
     * @param routeMapParameters Parameters supplied to create or update a RouteMap.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, routeMapName, routeMapParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    routeMapName,
                    routeMapParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$d
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a RouteMap if it doesn't exist else updates the existing one.
     * @param resourceGroupName The resource group name of the RouteMap's resource group.
     * @param virtualHubName The name of the VirtualHub containing the RouteMap.
     * @param routeMapName The name of the RouteMap.
     * @param routeMapParameters Parameters supplied to create or update a RouteMap.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, routeMapName, routeMapParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, routeMapName, routeMapParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a RouteMap.
     * @param resourceGroupName The resource group name of the RouteMap's resource group.
     * @param virtualHubName The name of the VirtualHub containing the RouteMap.
     * @param routeMapName The name of the RouteMap.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, routeMapName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualHubName, routeMapName, options },
                spec: deleteOperationSpec$d
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a RouteMap.
     * @param resourceGroupName The resource group name of the RouteMap's resource group.
     * @param virtualHubName The name of the VirtualHub containing the RouteMap.
     * @param routeMapName The name of the RouteMap.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, routeMapName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, routeMapName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of all RouteMaps.
     * @param resourceGroupName The resource group name of the RouteMap's resource group'.
     * @param virtualHubName The name of the VirtualHub containing the RouteMap.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$b);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the RouteMap's resource group'.
     * @param virtualHubName The name of the VirtualHub containing the RouteMap.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$9);
    }
}
// Operation Specifications
const serializer$i = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$e = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeMaps/{routeMapName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RouteMap
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        routeMapName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const createOrUpdateOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeMaps/{routeMapName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RouteMap
        },
        201: {
            bodyMapper: RouteMap
        },
        202: {
            bodyMapper: RouteMap
        },
        204: {
            bodyMapper: RouteMap
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routeMapParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        routeMapName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$i
};
const deleteOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeMaps/{routeMapName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        routeMapName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeMaps",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListRouteMapsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};
const listNextOperationSpec$9 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListRouteMapsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$i
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing HubVirtualNetworkConnections operations. */
class HubVirtualNetworkConnectionsImpl {
    /**
     * Initialize a new instance of the class HubVirtualNetworkConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all HubVirtualNetworkConnections.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualHubName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a hub virtual network connection if it doesn't exist else updates the existing one.
     * @param resourceGroupName The resource group name of the HubVirtualNetworkConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the HubVirtualNetworkConnection.
     * @param hubVirtualNetworkConnectionParameters Parameters supplied to create or update a hub virtual
     *                                              network connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, connectionName, hubVirtualNetworkConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    connectionName,
                    hubVirtualNetworkConnectionParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$c
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a hub virtual network connection if it doesn't exist else updates the existing one.
     * @param resourceGroupName The resource group name of the HubVirtualNetworkConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the HubVirtualNetworkConnection.
     * @param hubVirtualNetworkConnectionParameters Parameters supplied to create or update a hub virtual
     *                                              network connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, connectionName, hubVirtualNetworkConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, connectionName, hubVirtualNetworkConnectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a HubVirtualNetworkConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the HubVirtualNetworkConnection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualHubName, connectionName, options },
                spec: deleteOperationSpec$c
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a HubVirtualNetworkConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the HubVirtualNetworkConnection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of a HubVirtualNetworkConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, connectionName, options }, getOperationSpec$d);
    }
    /**
     * Retrieves the details of all HubVirtualNetworkConnections.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$a);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$8);
    }
}
// Operation Specifications
const serializer$h = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubVirtualNetworkConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HubVirtualNetworkConnection
        },
        201: {
            bodyMapper: HubVirtualNetworkConnection
        },
        202: {
            bodyMapper: HubVirtualNetworkConnection
        },
        204: {
            bodyMapper: HubVirtualNetworkConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: hubVirtualNetworkConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$h
};
const deleteOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubVirtualNetworkConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const getOperationSpec$d = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubVirtualNetworkConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubVirtualNetworkConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubVirtualNetworkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHubVirtualNetworkConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};
const listNextOperationSpec$8 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHubVirtualNetworkConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$h
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnGateways operations. */
class VpnGatewaysImpl {
    /**
     * Initialize a new instance of the class VpnGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the VpnGateways in a resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the VpnGateways in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, options }, getOperationSpec$c);
    }
    /**
     * Creates a virtual wan vpn gateway if it doesn't exist else updates the existing gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param vpnGatewayParameters Parameters supplied to create or Update a virtual wan vpn gateway.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, gatewayName, vpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, vpnGatewayParameters, options },
                spec: createOrUpdateOperationSpec$b
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a virtual wan vpn gateway if it doesn't exist else updates the existing gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param vpnGatewayParameters Parameters supplied to create or Update a virtual wan vpn gateway.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, gatewayName, vpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, gatewayName, vpnGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates virtual wan vpn gateway tags.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param vpnGatewayParameters Parameters supplied to update a virtual wan vpn gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, gatewayName, vpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, vpnGatewayParameters, options },
                spec: updateTagsOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates virtual wan vpn gateway tags.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param vpnGatewayParameters Parameters supplied to update a virtual wan vpn gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, gatewayName, vpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, gatewayName, vpnGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, options },
                spec: deleteOperationSpec$b
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Resets the primary of the vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginReset(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, options },
                spec: resetOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resets the primary of the vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginResetAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReset(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts packet capture on vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginStartPacketCapture(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, options },
                spec: startPacketCaptureOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts packet capture on vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginStartPacketCaptureAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartPacketCapture(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops packet capture on vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginStopPacketCapture(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, options },
                spec: stopPacketCaptureOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stops packet capture on vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginStopPacketCaptureAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopPacketCapture(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the VpnGateways in a resource group.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$2);
    }
    /**
     * Lists all the VpnGateways in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$9);
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec$1);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$7);
    }
}
// Operation Specifications
const serializer$g = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$c = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const createOrUpdateOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnGateway
        },
        201: {
            bodyMapper: VpnGateway
        },
        202: {
            bodyMapper: VpnGateway
        },
        204: {
            bodyMapper: VpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnGatewayParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const updateTagsOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: VpnGateway
        },
        201: {
            bodyMapper: VpnGateway
        },
        202: {
            bodyMapper: VpnGateway
        },
        204: {
            bodyMapper: VpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnGatewayParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const deleteOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const resetOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/reset",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnGateway
        },
        201: {
            bodyMapper: VpnGateway
        },
        202: {
            bodyMapper: VpnGateway
        },
        204: {
            bodyMapper: VpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, ipConfigurationId],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const startPacketCaptureOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/startpacketcapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters81,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const stopPacketCaptureOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/stoppacketcapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters82,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$g
};
const listByResourceGroupOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/vpnGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$g
};
const listByResourceGroupNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};
const listNextOperationSpec$7 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$g
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnLinkConnections operations. */
class VpnLinkConnectionsImpl {
    /**
     * Initialize a new instance of the class VpnLinkConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all vpn site link connections for a particular virtual wan vpn gateway vpn connection.
     * @param resourceGroupName The resource group name of the vpn gateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    listByVpnConnection(resourceGroupName, gatewayName, connectionName, options) {
        const iter = this.listByVpnConnectionPagingAll(resourceGroupName, gatewayName, connectionName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByVpnConnectionPagingPage(resourceGroupName, gatewayName, connectionName, options, settings);
            }
        };
    }
    listByVpnConnectionPagingPage(resourceGroupName, gatewayName, connectionName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnConnectionPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByVpnConnection(resourceGroupName, gatewayName, connectionName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByVpnConnectionNext(resourceGroupName, gatewayName, connectionName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByVpnConnectionPagingAll(resourceGroupName, gatewayName, connectionName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnConnectionPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVpnConnectionPagingPage(resourceGroupName, gatewayName, connectionName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Resets the VpnLink connection specified.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn link connection.
     * @param options The options parameters.
     */
    beginResetConnection(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    gatewayName,
                    connectionName,
                    linkConnectionName,
                    options
                },
                spec: resetConnectionOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resets the VpnLink connection specified.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn link connection.
     * @param options The options parameters.
     */
    beginResetConnectionAndWait(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginResetConnection(resourceGroupName, gatewayName, connectionName, linkConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists IKE Security Associations for Vpn Site Link Connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn link connection.
     * @param options The options parameters.
     */
    beginGetIkeSas(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    gatewayName,
                    connectionName,
                    linkConnectionName,
                    options
                },
                spec: getIkeSasOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Lists IKE Security Associations for Vpn Site Link Connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn link connection.
     * @param options The options parameters.
     */
    beginGetIkeSasAndWait(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetIkeSas(resourceGroupName, gatewayName, connectionName, linkConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves all vpn site link connections for a particular virtual wan vpn gateway vpn connection.
     * @param resourceGroupName The resource group name of the vpn gateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    _listByVpnConnection(resourceGroupName, gatewayName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, connectionName, options }, listByVpnConnectionOperationSpec);
    }
    /**
     * ListByVpnConnectionNext
     * @param resourceGroupName The resource group name of the vpn gateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param nextLink The nextLink from the previous successful call to the ListByVpnConnection method.
     * @param options The options parameters.
     */
    _listByVpnConnectionNext(resourceGroupName, gatewayName, connectionName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, connectionName, nextLink, options }, listByVpnConnectionNextOperationSpec);
    }
}
// Operation Specifications
const serializer$f = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const resetConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}/vpnLinkConnections/{linkConnectionName}/resetconnection",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName,
        linkConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const getIkeSasOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}/vpnLinkConnections/{linkConnectionName}/getikesas",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: ErrorResponse
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName,
        linkConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByVpnConnectionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}/vpnLinkConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSiteLinkConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};
const listByVpnConnectionNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnSiteLinkConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$f
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VpnConnections operations. */
class VpnConnectionsImpl {
    /**
     * Initialize a new instance of the class VpnConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all vpn connections for a particular virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    listByVpnGateway(resourceGroupName, gatewayName, options) {
        const iter = this.listByVpnGatewayPagingAll(resourceGroupName, gatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options, settings);
            }
        };
    }
    listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnGatewayPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByVpnGateway(resourceGroupName, gatewayName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByVpnGatewayNext(resourceGroupName, gatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByVpnGatewayPagingAll(resourceGroupName, gatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnGatewayPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a vpn connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, connectionName, options }, getOperationSpec$b);
    }
    /**
     * Creates a vpn connection to a scalable vpn gateway if it doesn't exist else updates the existing
     * connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the connection.
     * @param vpnConnectionParameters Parameters supplied to create or Update a VPN Connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, gatewayName, connectionName, vpnConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    gatewayName,
                    connectionName,
                    vpnConnectionParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$a
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a vpn connection to a scalable vpn gateway if it doesn't exist else updates the existing
     * connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the connection.
     * @param vpnConnectionParameters Parameters supplied to create or Update a VPN Connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, gatewayName, connectionName, vpnConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, gatewayName, connectionName, vpnConnectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a vpn connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, gatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, connectionName, options },
                spec: deleteOperationSpec$a
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a vpn connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, gatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, gatewayName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Starts packet capture on Vpn connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param vpnConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    beginStartPacketCapture(resourceGroupName, gatewayName, vpnConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, vpnConnectionName, options },
                spec: startPacketCaptureOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Starts packet capture on Vpn connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param vpnConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    beginStartPacketCaptureAndWait(resourceGroupName, gatewayName, vpnConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStartPacketCapture(resourceGroupName, gatewayName, vpnConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Stops packet capture on Vpn connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param vpnConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    beginStopPacketCapture(resourceGroupName, gatewayName, vpnConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, vpnConnectionName, options },
                spec: stopPacketCaptureOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Stops packet capture on Vpn connection in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the gateway.
     * @param vpnConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    beginStopPacketCaptureAndWait(resourceGroupName, gatewayName, vpnConnectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginStopPacketCapture(resourceGroupName, gatewayName, vpnConnectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves all vpn connections for a particular virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    _listByVpnGateway(resourceGroupName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, options }, listByVpnGatewayOperationSpec$1);
    }
    /**
     * ListByVpnGatewayNext
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param nextLink The nextLink from the previous successful call to the ListByVpnGateway method.
     * @param options The options parameters.
     */
    _listByVpnGatewayNext(resourceGroupName, gatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, nextLink, options }, listByVpnGatewayNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$e = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$b = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const createOrUpdateOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnConnection
        },
        201: {
            bodyMapper: VpnConnection
        },
        202: {
            bodyMapper: VpnConnection
        },
        204: {
            bodyMapper: VpnConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const deleteOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const startPacketCaptureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{vpnConnectionName}/startpacketcapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters83,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName,
        vpnConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const stopPacketCaptureOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{vpnConnectionName}/stoppacketcapture",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: { type: { name: "String" } }
        },
        201: {
            bodyMapper: { type: { name: "String" } }
        },
        202: {
            bodyMapper: { type: { name: "String" } }
        },
        204: {
            bodyMapper: { type: { name: "String" } }
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters84,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName,
        vpnConnectionName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$e
};
const listByVpnGatewayOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};
const listByVpnGatewayNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnConnectionsResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$e
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VpnSiteLinkConnections operations. */
class VpnSiteLinkConnectionsImpl {
    /**
     * Initialize a new instance of the class VpnSiteLinkConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of a vpn site link connection.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param connectionName The name of the vpn connection.
     * @param linkConnectionName The name of the vpn connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, connectionName, linkConnectionName, options) {
        return this.client.sendOperationRequest({
            resourceGroupName,
            gatewayName,
            connectionName,
            linkConnectionName,
            options
        }, getOperationSpec$a);
    }
}
// Operation Specifications
const serializer$d = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$a = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/vpnConnections/{connectionName}/vpnLinkConnections/{linkConnectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnSiteLinkConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        gatewayName,
        linkConnectionName
    ],
    headerParameters: [accept],
    serializer: serializer$d
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing NatRules operations. */
class NatRulesImpl {
    /**
     * Initialize a new instance of the class NatRules class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves all nat rules for a particular virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    listByVpnGateway(resourceGroupName, gatewayName, options) {
        const iter = this.listByVpnGatewayPagingAll(resourceGroupName, gatewayName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options, settings);
            }
        };
    }
    listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnGatewayPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByVpnGateway(resourceGroupName, gatewayName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByVpnGatewayNext(resourceGroupName, gatewayName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByVpnGatewayPagingAll(resourceGroupName, gatewayName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByVpnGatewayPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByVpnGatewayPagingPage(resourceGroupName, gatewayName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a nat ruleGet.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, natRuleName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, natRuleName, options }, getOperationSpec$9);
    }
    /**
     * Creates a nat rule to a scalable vpn gateway if it doesn't exist else updates the existing nat
     * rules.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param natRuleParameters Parameters supplied to create or Update a Nat Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, gatewayName, natRuleName, natRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    gatewayName,
                    natRuleName,
                    natRuleParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$9
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a nat rule to a scalable vpn gateway if it doesn't exist else updates the existing nat
     * rules.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param natRuleParameters Parameters supplied to create or Update a Nat Rule.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, gatewayName, natRuleName, natRuleParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, gatewayName, natRuleName, natRuleParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a nat rule.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, gatewayName, natRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, natRuleName, options },
                spec: deleteOperationSpec$9
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a nat rule.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param natRuleName The name of the nat rule.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, gatewayName, natRuleName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, gatewayName, natRuleName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves all nat rules for a particular virtual wan vpn gateway.
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    _listByVpnGateway(resourceGroupName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, options }, listByVpnGatewayOperationSpec);
    }
    /**
     * ListByVpnGatewayNext
     * @param resourceGroupName The resource group name of the VpnGateway.
     * @param gatewayName The name of the gateway.
     * @param nextLink The nextLink from the previous successful call to the ListByVpnGateway method.
     * @param options The options parameters.
     */
    _listByVpnGatewayNext(resourceGroupName, gatewayName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, nextLink, options }, listByVpnGatewayNextOperationSpec);
    }
}
// Operation Specifications
const serializer$c = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/natRules/{natRuleName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VpnGatewayNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natRuleName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const createOrUpdateOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/natRules/{natRuleName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VpnGatewayNatRule
        },
        201: {
            bodyMapper: VpnGatewayNatRule
        },
        202: {
            bodyMapper: VpnGatewayNatRule
        },
        204: {
            bodyMapper: VpnGatewayNatRule
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: natRuleParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natRuleName,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$c
};
const deleteOperationSpec$9 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/natRules/{natRuleName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        natRuleName,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByVpnGatewayOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/vpnGateways/{gatewayName}/natRules",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewayNatRulesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};
const listByVpnGatewayNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVpnGatewayNatRulesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$c
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing P2SVpnGateways operations. */
class P2SVpnGatewaysImpl {
    /**
     * Initialize a new instance of the class P2SVpnGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all the P2SVpnGateways in a resource group.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        const iter = this.listByResourceGroupPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listByResourceGroupPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listByResourceGroupPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listByResourceGroup(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listByResourceGroupNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listByResourceGroupPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listByResourceGroupPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listByResourceGroupPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Lists all the P2SVpnGateways in a subscription.
     * @param options The options parameters.
     */
    list(options) {
        const iter = this.listPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(options, settings);
            }
        };
    }
    listPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Retrieves the details of a virtual wan p2s vpn gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, gatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, gatewayName, options }, getOperationSpec$8);
    }
    /**
     * Creates a virtual wan p2s vpn gateway if it doesn't exist else updates the existing gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param p2SVpnGatewayParameters Parameters supplied to create or Update a virtual wan p2s vpn
     *                                gateway.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    gatewayName,
                    p2SVpnGatewayParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$8
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a virtual wan p2s vpn gateway if it doesn't exist else updates the existing gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param p2SVpnGatewayParameters Parameters supplied to create or Update a virtual wan p2s vpn
     *                                gateway.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates virtual wan p2s vpn gateway tags.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param p2SVpnGatewayParameters Parameters supplied to update a virtual wan p2s vpn gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    gatewayName,
                    p2SVpnGatewayParameters,
                    options
                },
                spec: updateTagsOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates virtual wan p2s vpn gateway tags.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param p2SVpnGatewayParameters Parameters supplied to update a virtual wan p2s vpn gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, gatewayName, p2SVpnGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a virtual wan p2s vpn gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, options },
                spec: deleteOperationSpec$8
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a virtual wan p2s vpn gateway.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists all the P2SVpnGateways in a resource group.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param options The options parameters.
     */
    _listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec$1);
    }
    /**
     * Lists all the P2SVpnGateways in a subscription.
     * @param options The options parameters.
     */
    _list(options) {
        return this.client.sendOperationRequest({ options }, listOperationSpec$8);
    }
    /**
     * Resets the primary of the p2s vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginReset(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, options },
                spec: resetOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Resets the primary of the p2s vpn gateway in the specified resource group.
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param gatewayName The name of the gateway.
     * @param options The options parameters.
     */
    beginResetAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginReset(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Generates VPN profile for P2S client of the P2SVpnGateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param parameters Parameters supplied to the generate P2SVpnGateway VPN client package operation.
     * @param options The options parameters.
     */
    beginGenerateVpnProfile(resourceGroupName, gatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, parameters, options },
                spec: generateVpnProfileOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Generates VPN profile for P2S client of the P2SVpnGateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param parameters Parameters supplied to the generate P2SVpnGateway VPN client package operation.
     * @param options The options parameters.
     */
    beginGenerateVpnProfileAndWait(resourceGroupName, gatewayName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGenerateVpnProfile(resourceGroupName, gatewayName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the connection health of P2S clients of the virtual wan P2SVpnGateway in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param options The options parameters.
     */
    beginGetP2SVpnConnectionHealth(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, options },
                spec: getP2SVpnConnectionHealthOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the connection health of P2S clients of the virtual wan P2SVpnGateway in the specified resource
     * group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param options The options parameters.
     */
    beginGetP2SVpnConnectionHealthAndWait(resourceGroupName, gatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetP2SVpnConnectionHealth(resourceGroupName, gatewayName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the sas url to get the connection health detail of P2S clients of the virtual wan P2SVpnGateway
     * in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param request Request parameters supplied to get p2s vpn connections detailed health.
     * @param options The options parameters.
     */
    beginGetP2SVpnConnectionHealthDetailed(resourceGroupName, gatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, gatewayName, request, options },
                spec: getP2SVpnConnectionHealthDetailedOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gets the sas url to get the connection health detail of P2S clients of the virtual wan P2SVpnGateway
     * in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param gatewayName The name of the P2SVpnGateway.
     * @param request Request parameters supplied to get p2s vpn connections detailed health.
     * @param options The options parameters.
     */
    beginGetP2SVpnConnectionHealthDetailedAndWait(resourceGroupName, gatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGetP2SVpnConnectionHealthDetailed(resourceGroupName, gatewayName, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Disconnect P2S vpn connections of the virtual wan P2SVpnGateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param p2SVpnGatewayName The name of the P2S Vpn Gateway.
     * @param request The parameters are supplied to disconnect p2s vpn connections.
     * @param options The options parameters.
     */
    beginDisconnectP2SVpnConnections(resourceGroupName, p2SVpnGatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, p2SVpnGatewayName, request, options },
                spec: disconnectP2SVpnConnectionsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Disconnect P2S vpn connections of the virtual wan P2SVpnGateway in the specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param p2SVpnGatewayName The name of the P2S Vpn Gateway.
     * @param request The parameters are supplied to disconnect p2s vpn connections.
     * @param options The options parameters.
     */
    beginDisconnectP2SVpnConnectionsAndWait(resourceGroupName, p2SVpnGatewayName, request, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDisconnectP2SVpnConnections(resourceGroupName, p2SVpnGatewayName, request, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListByResourceGroupNext
     * @param resourceGroupName The resource group name of the P2SVpnGateway.
     * @param nextLink The nextLink from the previous successful call to the ListByResourceGroup method.
     * @param options The options parameters.
     */
    _listByResourceGroupNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listByResourceGroupNextOperationSpec);
    }
    /**
     * ListNext
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listNextOperationSpec$6);
    }
}
// Operation Specifications
const serializer$b = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const createOrUpdateOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        201: {
            bodyMapper: P2SVpnGateway
        },
        202: {
            bodyMapper: P2SVpnGateway
        },
        204: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: p2SVpnGatewayParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const updateTagsOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        201: {
            bodyMapper: P2SVpnGateway
        },
        202: {
            bodyMapper: P2SVpnGateway
        },
        204: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: p2SVpnGatewayParameters1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const deleteOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listByResourceGroupOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListP2SVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listOperationSpec$8 = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/p2svpnGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListP2SVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$b
};
const resetOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}/reset",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        201: {
            bodyMapper: P2SVpnGateway
        },
        202: {
            bodyMapper: P2SVpnGateway
        },
        204: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const generateVpnProfileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}/generatevpnprofile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnProfileResponse
        },
        201: {
            bodyMapper: VpnProfileResponse
        },
        202: {
            bodyMapper: VpnProfileResponse
        },
        204: {
            bodyMapper: VpnProfileResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters85,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const getP2SVpnConnectionHealthOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}/getP2sVpnConnectionHealth",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: P2SVpnGateway
        },
        201: {
            bodyMapper: P2SVpnGateway
        },
        202: {
            bodyMapper: P2SVpnGateway
        },
        204: {
            bodyMapper: P2SVpnGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const getP2SVpnConnectionHealthDetailedOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{gatewayName}/getP2sVpnConnectionHealthDetailed",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: P2SVpnConnectionHealth
        },
        201: {
            bodyMapper: P2SVpnConnectionHealth
        },
        202: {
            bodyMapper: P2SVpnConnectionHealth
        },
        204: {
            bodyMapper: P2SVpnConnectionHealth
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request3,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        gatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const disconnectP2SVpnConnectionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/p2svpnGateways/{p2sVpnGatewayName}/disconnectP2sVpnConnections",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: request1,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        p2SVpnGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$b
};
const listByResourceGroupNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListP2SVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};
const listNextOperationSpec$6 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListP2SVpnGatewaysResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$b
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VpnServerConfigurationsAssociatedWithVirtualWan operations. */
class VpnServerConfigurationsAssociatedWithVirtualWanImpl {
    /**
     * Initialize a new instance of the class VpnServerConfigurationsAssociatedWithVirtualWan class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gives the list of VpnServerConfigurations associated with Virtual Wan in a resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param options The options parameters.
     */
    beginList(resourceGroupName, virtualWANName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualWANName, options },
                spec: listOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Gives the list of VpnServerConfigurations associated with Virtual Wan in a resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param options The options parameters.
     */
    beginListAndWait(resourceGroupName, virtualWANName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginList(resourceGroupName, virtualWANName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$a = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/vpnServerConfigurations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnServerConfigurationsResponse
        },
        201: {
            bodyMapper: VpnServerConfigurationsResponse
        },
        202: {
            bodyMapper: VpnServerConfigurationsResponse
        },
        204: {
            bodyMapper: VpnServerConfigurationsResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName
    ],
    headerParameters: [accept],
    serializer: serializer$a
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualHubRouteTableV2S operations. */
class VirtualHubRouteTableV2SImpl {
    /**
     * Initialize a new instance of the class VirtualHubRouteTableV2S class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all VirtualHubRouteTableV2s.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualHubName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHubRouteTableV2.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, routeTableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, routeTableName, options }, getOperationSpec$7);
    }
    /**
     * Creates a VirtualHubRouteTableV2 resource if it doesn't exist else updates the existing
     * VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param virtualHubRouteTableV2Parameters Parameters supplied to create or update
     *                                         VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, routeTableName, virtualHubRouteTableV2Parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    routeTableName,
                    virtualHubRouteTableV2Parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a VirtualHubRouteTableV2 resource if it doesn't exist else updates the existing
     * VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param virtualHubRouteTableV2Parameters Parameters supplied to create or update
     *                                         VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, routeTableName, virtualHubRouteTableV2Parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, routeTableName, virtualHubRouteTableV2Parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHubRouteTableV2.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualHubName, routeTableName, options },
                spec: deleteOperationSpec$7
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a VirtualHubRouteTableV2.
     * @param resourceGroupName The resource group name of the VirtualHubRouteTableV2.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the VirtualHubRouteTableV2.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, routeTableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of all VirtualHubRouteTableV2s.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$6);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$5);
    }
}
// Operation Specifications
const serializer$9 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeTables/{routeTableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualHubRouteTableV2
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const createOrUpdateOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeTables/{routeTableName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: VirtualHubRouteTableV2
        },
        201: {
            bodyMapper: VirtualHubRouteTableV2
        },
        202: {
            bodyMapper: VirtualHubRouteTableV2
        },
        204: {
            bodyMapper: VirtualHubRouteTableV2
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    requestBody: virtualHubRouteTableV2Parameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$9
};
const deleteOperationSpec$7 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeTables/{routeTableName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: ErrorModel
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routeTables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubRouteTableV2SResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};
const listNextOperationSpec$5 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubRouteTableV2SResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$9
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ExpressRouteGateways operations. */
class ExpressRouteGatewaysImpl {
    /**
     * Initialize a new instance of the class ExpressRouteGateways class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists ExpressRoute gateways under a given subscription.
     * @param options The options parameters.
     */
    listBySubscription(options) {
        return this.client.sendOperationRequest({ options }, listBySubscriptionOperationSpec);
    }
    /**
     * Lists ExpressRoute gateways in a given resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    listByResourceGroup(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listByResourceGroupOperationSpec);
    }
    /**
     * Creates or updates a ExpressRoute gateway in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param putExpressRouteGatewayParameters Parameters required in an ExpressRoute gateway PUT
     *                                         operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, expressRouteGatewayName, putExpressRouteGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    expressRouteGatewayName,
                    putExpressRouteGatewayParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$6
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates or updates a ExpressRoute gateway in a specified resource group.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param putExpressRouteGatewayParameters Parameters required in an ExpressRoute gateway PUT
     *                                         operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, expressRouteGatewayName, putExpressRouteGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, expressRouteGatewayName, putExpressRouteGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Updates express route gateway tags.
     * @param resourceGroupName The resource group name of the ExpressRouteGateway.
     * @param expressRouteGatewayName The name of the gateway.
     * @param expressRouteGatewayParameters Parameters supplied to update a virtual wan express route
     *                                      gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTags(resourceGroupName, expressRouteGatewayName, expressRouteGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    expressRouteGatewayName,
                    expressRouteGatewayParameters,
                    options
                },
                spec: updateTagsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Updates express route gateway tags.
     * @param resourceGroupName The resource group name of the ExpressRouteGateway.
     * @param expressRouteGatewayName The name of the gateway.
     * @param expressRouteGatewayParameters Parameters supplied to update a virtual wan express route
     *                                      gateway tags.
     * @param options The options parameters.
     */
    beginUpdateTagsAndWait(resourceGroupName, expressRouteGatewayName, expressRouteGatewayParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginUpdateTags(resourceGroupName, expressRouteGatewayName, expressRouteGatewayParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Fetches the details of a ExpressRoute gateway in a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param options The options parameters.
     */
    get(resourceGroupName, expressRouteGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRouteGatewayName, options }, getOperationSpec$6);
    }
    /**
     * Deletes the specified ExpressRoute gateway in a resource group. An ExpressRoute gateway resource can
     * only be deleted when there are no connection subresources.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, expressRouteGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, expressRouteGatewayName, options },
                spec: deleteOperationSpec$6
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the specified ExpressRoute gateway in a resource group. An ExpressRoute gateway resource can
     * only be deleted when there are no connection subresources.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, expressRouteGatewayName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, expressRouteGatewayName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$8 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listBySubscriptionOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteGatewayList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$8
};
const listByResourceGroupOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteGatewayList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const createOrUpdateOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteGateway
        },
        201: {
            bodyMapper: ExpressRouteGateway
        },
        202: {
            bodyMapper: ExpressRouteGateway
        },
        204: {
            bodyMapper: ExpressRouteGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: putExpressRouteGatewayParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const updateTagsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ExpressRouteGateway
        },
        201: {
            bodyMapper: ExpressRouteGateway
        },
        202: {
            bodyMapper: ExpressRouteGateway
        },
        204: {
            bodyMapper: ExpressRouteGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: expressRouteGatewayParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$8
};
const getOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteGateway
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};
const deleteOperationSpec$6 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$8
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ExpressRouteConnections operations. */
class ExpressRouteConnectionsImpl {
    /**
     * Initialize a new instance of the class ExpressRouteConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a connection between an ExpressRoute gateway and an ExpressRoute circuit.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the connection subresource.
     * @param putExpressRouteConnectionParameters Parameters required in an ExpressRouteConnection PUT
     *                                            operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, expressRouteGatewayName, connectionName, putExpressRouteConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    expressRouteGatewayName,
                    connectionName,
                    putExpressRouteConnectionParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a connection between an ExpressRoute gateway and an ExpressRoute circuit.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the connection subresource.
     * @param putExpressRouteConnectionParameters Parameters required in an ExpressRouteConnection PUT
     *                                            operation.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, expressRouteGatewayName, connectionName, putExpressRouteConnectionParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, expressRouteGatewayName, connectionName, putExpressRouteConnectionParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Gets the specified ExpressRouteConnection.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the ExpressRoute connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, expressRouteGatewayName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRouteGatewayName, connectionName, options }, getOperationSpec$5);
    }
    /**
     * Deletes a connection to a ExpressRoute circuit.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the connection subresource.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, expressRouteGatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    expressRouteGatewayName,
                    connectionName,
                    options
                },
                spec: deleteOperationSpec$5
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a connection to a ExpressRoute circuit.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param connectionName The name of the connection subresource.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, expressRouteGatewayName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, expressRouteGatewayName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Lists ExpressRouteConnections.
     * @param resourceGroupName The name of the resource group.
     * @param expressRouteGatewayName The name of the ExpressRoute gateway.
     * @param options The options parameters.
     */
    list(resourceGroupName, expressRouteGatewayName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, expressRouteGatewayName, options }, listOperationSpec$5);
    }
}
// Operation Specifications
const serializer$7 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}/expressRouteConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: ExpressRouteConnection
        },
        201: {
            bodyMapper: ExpressRouteConnection
        },
        202: {
            bodyMapper: ExpressRouteConnection
        },
        204: {
            bodyMapper: ExpressRouteConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: putExpressRouteConnectionParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        expressRouteGatewayName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$7
};
const getOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}/expressRouteConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const deleteOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}/expressRouteConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};
const listOperationSpec$5 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/expressRouteGateways/{expressRouteGatewayName}/expressRouteConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteConnectionList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        expressRouteGatewayName
    ],
    headerParameters: [accept],
    serializer: serializer$7
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing VirtualHubBgpConnection operations. */
class VirtualHubBgpConnectionImpl {
    /**
     * Initialize a new instance of the class VirtualHubBgpConnection class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of a Virtual Hub Bgp Connection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, connectionName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, connectionName, options }, getOperationSpec$4);
    }
    /**
     * Creates a VirtualHubBgpConnection resource if it doesn't exist else updates the existing
     * VirtualHubBgpConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param parameters Parameters of Bgp connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, connectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    connectionName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a VirtualHubBgpConnection resource if it doesn't exist else updates the existing
     * VirtualHubBgpConnection.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param parameters Parameters of Bgp connection.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, connectionName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, connectionName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a VirtualHubBgpConnection.
     * @param resourceGroupName The resource group name of the VirtualHubBgpConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualHubName, connectionName, options },
                spec: deleteOperationSpec$4
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a VirtualHubBgpConnection.
     * @param resourceGroupName The resource group name of the VirtualHubBgpConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param connectionName The name of the connection.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
}
// Operation Specifications
const serializer$6 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/bgpConnections/{connectionName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BgpConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};
const createOrUpdateOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/bgpConnections/{connectionName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: BgpConnection
        },
        201: {
            bodyMapper: BgpConnection
        },
        202: {
            bodyMapper: BgpConnection
        },
        204: {
            bodyMapper: BgpConnection
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters86,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$6
};
const deleteOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/bgpConnections/{connectionName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$6
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualHubBgpConnections operations. */
class VirtualHubBgpConnectionsImpl {
    /**
     * Initialize a new instance of the class VirtualHubBgpConnections class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all VirtualHubBgpConnections.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualHubName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of all VirtualHubBgpConnections.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$4);
    }
    /**
     * Retrieves a list of routes the virtual hub bgp connection has learned.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the virtual hub.
     * @param connectionName The name of the virtual hub bgp connection.
     * @param options The options parameters.
     */
    beginListLearnedRoutes(resourceGroupName, hubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, hubName, connectionName, options },
                spec: listLearnedRoutesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves a list of routes the virtual hub bgp connection has learned.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the virtual hub.
     * @param connectionName The name of the virtual hub bgp connection.
     * @param options The options parameters.
     */
    beginListLearnedRoutesAndWait(resourceGroupName, hubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListLearnedRoutes(resourceGroupName, hubName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves a list of routes the virtual hub bgp connection is advertising to the specified peer.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the virtual hub.
     * @param connectionName The name of the virtual hub bgp connection.
     * @param options The options parameters.
     */
    beginListAdvertisedRoutes(resourceGroupName, hubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, hubName, connectionName, options },
                spec: listAdvertisedRoutesOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Retrieves a list of routes the virtual hub bgp connection is advertising to the specified peer.
     * @param resourceGroupName The name of the resource group.
     * @param hubName The name of the virtual hub.
     * @param connectionName The name of the virtual hub bgp connection.
     * @param options The options parameters.
     */
    beginListAdvertisedRoutesAndWait(resourceGroupName, hubName, connectionName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginListAdvertisedRoutes(resourceGroupName, hubName, connectionName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$4);
    }
}
// Operation Specifications
const serializer$5 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec$4 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/bgpConnections",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubBgpConnectionResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listLearnedRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{hubName}/bgpConnections/{connectionName}/learnedRoutes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PeerRouteList
        },
        201: {
            bodyMapper: PeerRouteList
        },
        202: {
            bodyMapper: PeerRouteList
        },
        204: {
            bodyMapper: PeerRouteList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        hubName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listAdvertisedRoutesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{hubName}/bgpConnections/{connectionName}/advertisedRoutes",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: PeerRouteList
        },
        201: {
            bodyMapper: PeerRouteList
        },
        202: {
            bodyMapper: PeerRouteList
        },
        204: {
            bodyMapper: PeerRouteList
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        connectionName,
        hubName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};
const listNextOperationSpec$4 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubBgpConnectionResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$5
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing VirtualHubIpConfiguration operations. */
class VirtualHubIpConfigurationImpl {
    /**
     * Initialize a new instance of the class VirtualHubIpConfiguration class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all VirtualHubIpConfigurations.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualHubName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Retrieves the details of a Virtual Hub Ip configuration.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, ipConfigName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, ipConfigName, options }, getOperationSpec$3);
    }
    /**
     * Creates a VirtualHubIpConfiguration resource if it doesn't exist else updates the existing
     * VirtualHubIpConfiguration.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param parameters Hub Ip Configuration parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, ipConfigName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    ipConfigName,
                    parameters,
                    options
                },
                spec: createOrUpdateOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a VirtualHubIpConfiguration resource if it doesn't exist else updates the existing
     * VirtualHubIpConfiguration.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param parameters Hub Ip Configuration parameters.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, ipConfigName, parameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, ipConfigName, parameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Deletes a VirtualHubIpConfiguration.
     * @param resourceGroupName The resource group name of the VirtualHubBgpConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, ipConfigName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualHubName, ipConfigName, options },
                spec: deleteOperationSpec$3
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a VirtualHubIpConfiguration.
     * @param resourceGroupName The resource group name of the VirtualHubBgpConnection.
     * @param virtualHubName The name of the VirtualHub.
     * @param ipConfigName The name of the ipconfig.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, ipConfigName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, ipConfigName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of all VirtualHubIpConfigurations.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$3);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$3);
    }
}
// Operation Specifications
const serializer$4 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/ipConfigurations/{ipConfigName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubIpConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        ipConfigName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const createOrUpdateOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/ipConfigurations/{ipConfigName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HubIpConfiguration
        },
        201: {
            bodyMapper: HubIpConfiguration
        },
        202: {
            bodyMapper: HubIpConfiguration
        },
        204: {
            bodyMapper: HubIpConfiguration
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters87,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        ipConfigName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$4
};
const deleteOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/ipConfigurations/{ipConfigName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        ipConfigName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listOperationSpec$3 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/ipConfigurations",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubIpConfigurationResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};
const listNextOperationSpec$3 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListVirtualHubIpConfigurationResults
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$4
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing HubRouteTables operations. */
class HubRouteTablesImpl {
    /**
     * Initialize a new instance of the class HubRouteTables class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all RouteTables.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualHubName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a RouteTable resource if it doesn't exist else updates the existing RouteTable.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param routeTableParameters Parameters supplied to create or update RouteTable.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, routeTableName, routeTableParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    routeTableName,
                    routeTableParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a RouteTable resource if it doesn't exist else updates the existing RouteTable.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param routeTableParameters Parameters supplied to create or update RouteTable.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, routeTableName, routeTableParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, routeTableName, routeTableParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of a RouteTable.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, routeTableName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, routeTableName, options }, getOperationSpec$2);
    }
    /**
     * Deletes a RouteTable.
     * @param resourceGroupName The resource group name of the RouteTable.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualHubName, routeTableName, options },
                spec: deleteOperationSpec$2
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a RouteTable.
     * @param resourceGroupName The resource group name of the RouteTable.
     * @param virtualHubName The name of the VirtualHub.
     * @param routeTableName The name of the RouteTable.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, routeTableName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, routeTableName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of all RouteTables.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$2);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$2);
    }
}
// Operation Specifications
const serializer$3 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubRouteTables/{routeTableName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: HubRouteTable
        },
        201: {
            bodyMapper: HubRouteTable
        },
        202: {
            bodyMapper: HubRouteTable
        },
        204: {
            bodyMapper: HubRouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routeTableParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$3
};
const getOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubRouteTables/{routeTableName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: HubRouteTable
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const deleteOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubRouteTables/{routeTableName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        routeTableName,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listOperationSpec$2 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/hubRouteTables",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHubRouteTablesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};
const listNextOperationSpec$2 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListHubRouteTablesResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$3
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing RoutingIntentOperations operations. */
class RoutingIntentOperationsImpl {
    /**
     * Initialize a new instance of the class RoutingIntentOperations class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieves the details of all RoutingIntent child resources of the VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    list(resourceGroupName, virtualHubName, options) {
        const iter = this.listPagingAll(resourceGroupName, virtualHubName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, virtualHubName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, virtualHubName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, virtualHubName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, virtualHubName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, virtualHubName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, virtualHubName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Creates a RoutingIntent resource if it doesn't exist else updates the existing RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the per VirtualHub singleton Routing Intent resource.
     * @param routingIntentParameters Parameters supplied to create or update RoutingIntent.
     * @param options The options parameters.
     */
    beginCreateOrUpdate(resourceGroupName, virtualHubName, routingIntentName, routingIntentParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: {
                    resourceGroupName,
                    virtualHubName,
                    routingIntentName,
                    routingIntentParameters,
                    options
                },
                spec: createOrUpdateOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "azure-async-operation"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Creates a RoutingIntent resource if it doesn't exist else updates the existing RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the per VirtualHub singleton Routing Intent resource.
     * @param routingIntentParameters Parameters supplied to create or update RoutingIntent.
     * @param options The options parameters.
     */
    beginCreateOrUpdateAndWait(resourceGroupName, virtualHubName, routingIntentName, routingIntentParameters, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginCreateOrUpdate(resourceGroupName, virtualHubName, routingIntentName, routingIntentParameters, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of a RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the RoutingIntent.
     * @param options The options parameters.
     */
    get(resourceGroupName, virtualHubName, routingIntentName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, routingIntentName, options }, getOperationSpec$1);
    }
    /**
     * Deletes a RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the RoutingIntent.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, virtualHubName, routingIntentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualHubName, routingIntentName, options },
                spec: deleteOperationSpec$1
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes a RoutingIntent.
     * @param resourceGroupName The resource group name of the RoutingIntent.
     * @param virtualHubName The name of the VirtualHub.
     * @param routingIntentName The name of the RoutingIntent.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, virtualHubName, routingIntentName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, virtualHubName, routingIntentName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Retrieves the details of all RoutingIntent child resources of the VirtualHub.
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param options The options parameters.
     */
    _list(resourceGroupName, virtualHubName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, options }, listOperationSpec$1);
    }
    /**
     * ListNext
     * @param resourceGroupName The resource group name of the VirtualHub.
     * @param virtualHubName The name of the VirtualHub.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, virtualHubName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, virtualHubName, nextLink, options }, listNextOperationSpec$1);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const createOrUpdateOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routingIntent/{routingIntentName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: RoutingIntent
        },
        201: {
            bodyMapper: RoutingIntent
        },
        202: {
            bodyMapper: RoutingIntent
        },
        204: {
            bodyMapper: RoutingIntent
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: routingIntentParameters,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        routingIntentName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$2
};
const getOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routingIntent/{routingIntentName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: RoutingIntent
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        routingIntentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const deleteOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routingIntent/{routingIntentName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName,
        routingIntentName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listOperationSpec$1 = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualHubs/{virtualHubName}/routingIntent",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListRoutingIntentResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};
const listNextOperationSpec$1 = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ListRoutingIntentResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        virtualHubName
    ],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
/** Class containing WebApplicationFirewallPolicies operations. */
class WebApplicationFirewallPoliciesImpl {
    /**
     * Initialize a new instance of the class WebApplicationFirewallPolicies class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Lists all of the protection policies within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    list(resourceGroupName, options) {
        const iter = this.listPagingAll(resourceGroupName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listPagingPage(resourceGroupName, options, settings);
            }
        };
    }
    listPagingPage(resourceGroupName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._list(resourceGroupName, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listNext(resourceGroupName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listPagingAll(resourceGroupName, options) {
        return tslib.__asyncGenerator(this, arguments, function* listPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listPagingPage(resourceGroupName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets all the WAF policies in a subscription.
     * @param options The options parameters.
     */
    listAll(options) {
        const iter = this.listAllPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.listAllPagingPage(options, settings);
            }
        };
    }
    listAllPagingPage(options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._listAll(options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._listAllNext(continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    listAllPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listAllPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listAllPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Lists all of the protection policies within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param options The options parameters.
     */
    _list(resourceGroupName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, options }, listOperationSpec);
    }
    /**
     * Gets all the WAF policies in a subscription.
     * @param options The options parameters.
     */
    _listAll(options) {
        return this.client.sendOperationRequest({ options }, listAllOperationSpec);
    }
    /**
     * Retrieve protection policy with specified name within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param policyName The name of the policy.
     * @param options The options parameters.
     */
    get(resourceGroupName, policyName, options) {
        return this.client.sendOperationRequest({ resourceGroupName, policyName, options }, getOperationSpec);
    }
    /**
     * Creates or update policy with specified rule set name within a resource group.
     * @param resourceGroupName The name of the resource group.
     * @param policyName The name of the policy.
     * @param parameters Policy to be created.
     * @param options The options parameters.
     */
    createOrUpdate(resourceGroupName, policyName, parameters, options) {
        return this.client.sendOperationRequest({ resourceGroupName, policyName, parameters, options }, createOrUpdateOperationSpec);
    }
    /**
     * Deletes Policy.
     * @param resourceGroupName The name of the resource group.
     * @param policyName The name of the policy.
     * @param options The options parameters.
     */
    beginDelete(resourceGroupName, policyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.client.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, policyName, options },
                spec: deleteOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes Policy.
     * @param resourceGroupName The name of the resource group.
     * @param policyName The name of the policy.
     * @param options The options parameters.
     */
    beginDeleteAndWait(resourceGroupName, policyName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDelete(resourceGroupName, policyName, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * ListNext
     * @param resourceGroupName The name of the resource group.
     * @param nextLink The nextLink from the previous successful call to the List method.
     * @param options The options parameters.
     */
    _listNext(resourceGroupName, nextLink, options) {
        return this.client.sendOperationRequest({ resourceGroupName, nextLink, options }, listNextOperationSpec);
    }
    /**
     * ListAllNext
     * @param nextLink The nextLink from the previous successful call to the ListAll method.
     * @param options The options parameters.
     */
    _listAllNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, listAllNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const listOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listAllOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [$host, subscriptionId],
    headerParameters: [accept],
    serializer: serializer$1
};
const getOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const createOrUpdateOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "PUT",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicy
        },
        201: {
            bodyMapper: WebApplicationFirewallPolicy
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters88,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer: serializer$1
};
const deleteOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/ApplicationGatewayWebApplicationFirewallPolicies/{policyName}",
    httpMethod: "DELETE",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        policyName
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};
const listAllNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: WebApplicationFirewallPolicyListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        subscriptionId,
        nextLink
    ],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
class NetworkManagementClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the NetworkManagementClient class.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param subscriptionId The subscription credentials which uniquely identify the Microsoft Azure
     *                       subscription. The subscription ID forms part of the URI for every service call.
     * @param options The parameter options
     */
    constructor(credentials, subscriptionId, options) {
        var _a, _b, _c;
        if (credentials === undefined) {
            throw new Error("'credentials' cannot be null");
        }
        if (subscriptionId === undefined) {
            throw new Error("'subscriptionId' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8",
            credential: credentials
        };
        const packageDetails = `azsdk-js-arm-network/30.2.0`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "https://management.azure.com" });
        super(optionsWithDefaults);
        let bearerTokenAuthenticationPolicyFound = false;
        if ((options === null || options === void 0 ? void 0 : options.pipeline) && options.pipeline.getOrderedPolicies().length > 0) {
            const pipelinePolicies = options.pipeline.getOrderedPolicies();
            bearerTokenAuthenticationPolicyFound = pipelinePolicies.some((pipelinePolicy) => pipelinePolicy.name ===
                coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName);
        }
        if (!options ||
            !options.pipeline ||
            options.pipeline.getOrderedPolicies().length == 0 ||
            !bearerTokenAuthenticationPolicyFound) {
            this.pipeline.removePolicy({
                name: coreRestPipeline__namespace.bearerTokenAuthenticationPolicyName
            });
            this.pipeline.addPolicy(coreRestPipeline__namespace.bearerTokenAuthenticationPolicy({
                credential: credentials,
                scopes: (_c = optionsWithDefaults.credentialScopes) !== null && _c !== void 0 ? _c : `${optionsWithDefaults.endpoint}/.default`,
                challengeCallbacks: {
                    authorizeRequestOnChallenge: coreClient__namespace.authorizeRequestOnClaimChallenge
                }
            }));
        }
        // Parameter assignments
        this.subscriptionId = subscriptionId;
        // Assigning values to Constant parameters
        this.$host = options.$host || "https://management.azure.com";
        this.applicationGateways = new ApplicationGatewaysImpl(this);
        this.applicationGatewayPrivateLinkResources = new ApplicationGatewayPrivateLinkResourcesImpl(this);
        this.applicationGatewayPrivateEndpointConnections = new ApplicationGatewayPrivateEndpointConnectionsImpl(this);
        this.applicationGatewayWafDynamicManifestsDefault = new ApplicationGatewayWafDynamicManifestsDefaultImpl(this);
        this.applicationGatewayWafDynamicManifests = new ApplicationGatewayWafDynamicManifestsImpl(this);
        this.applicationSecurityGroups = new ApplicationSecurityGroupsImpl(this);
        this.availableDelegations = new AvailableDelegationsImpl(this);
        this.availableResourceGroupDelegations = new AvailableResourceGroupDelegationsImpl(this);
        this.availableServiceAliases = new AvailableServiceAliasesImpl(this);
        this.azureFirewalls = new AzureFirewallsImpl(this);
        this.azureFirewallFqdnTags = new AzureFirewallFqdnTagsImpl(this);
        this.webCategories = new WebCategoriesImpl(this);
        this.bastionHosts = new BastionHostsImpl(this);
        this.networkInterfaces = new NetworkInterfacesImpl(this);
        this.publicIPAddresses = new PublicIPAddressesImpl(this);
        this.vipSwap = new VipSwapImpl(this);
        this.customIPPrefixes = new CustomIPPrefixesImpl(this);
        this.ddosCustomPolicies = new DdosCustomPoliciesImpl(this);
        this.ddosProtectionPlans = new DdosProtectionPlansImpl(this);
        this.dscpConfigurationOperations = new DscpConfigurationOperationsImpl(this);
        this.availableEndpointServices = new AvailableEndpointServicesImpl(this);
        this.expressRouteCircuitAuthorizations = new ExpressRouteCircuitAuthorizationsImpl(this);
        this.expressRouteCircuitPeerings = new ExpressRouteCircuitPeeringsImpl(this);
        this.expressRouteCircuitConnections = new ExpressRouteCircuitConnectionsImpl(this);
        this.peerExpressRouteCircuitConnections = new PeerExpressRouteCircuitConnectionsImpl(this);
        this.expressRouteCircuits = new ExpressRouteCircuitsImpl(this);
        this.expressRouteServiceProviders = new ExpressRouteServiceProvidersImpl(this);
        this.expressRouteCrossConnections = new ExpressRouteCrossConnectionsImpl(this);
        this.expressRouteCrossConnectionPeerings = new ExpressRouteCrossConnectionPeeringsImpl(this);
        this.expressRoutePortsLocations = new ExpressRoutePortsLocationsImpl(this);
        this.expressRoutePorts = new ExpressRoutePortsImpl(this);
        this.expressRouteLinks = new ExpressRouteLinksImpl(this);
        this.expressRoutePortAuthorizations = new ExpressRoutePortAuthorizationsImpl(this);
        this.expressRouteProviderPortsLocation = new ExpressRouteProviderPortsLocationImpl(this);
        this.firewallPolicies = new FirewallPoliciesImpl(this);
        this.firewallPolicyRuleCollectionGroups = new FirewallPolicyRuleCollectionGroupsImpl(this);
        this.firewallPolicyIdpsSignatures = new FirewallPolicyIdpsSignaturesImpl(this);
        this.firewallPolicyIdpsSignaturesOverrides = new FirewallPolicyIdpsSignaturesOverridesImpl(this);
        this.firewallPolicyIdpsSignaturesFilterValues = new FirewallPolicyIdpsSignaturesFilterValuesImpl(this);
        this.ipAllocations = new IpAllocationsImpl(this);
        this.ipGroups = new IpGroupsImpl(this);
        this.loadBalancers = new LoadBalancersImpl(this);
        this.loadBalancerBackendAddressPools = new LoadBalancerBackendAddressPoolsImpl(this);
        this.loadBalancerFrontendIPConfigurations = new LoadBalancerFrontendIPConfigurationsImpl(this);
        this.inboundNatRules = new InboundNatRulesImpl(this);
        this.loadBalancerLoadBalancingRules = new LoadBalancerLoadBalancingRulesImpl(this);
        this.loadBalancerOutboundRules = new LoadBalancerOutboundRulesImpl(this);
        this.loadBalancerNetworkInterfaces = new LoadBalancerNetworkInterfacesImpl(this);
        this.loadBalancerProbes = new LoadBalancerProbesImpl(this);
        this.natGateways = new NatGatewaysImpl(this);
        this.networkInterfaceIPConfigurations = new NetworkInterfaceIPConfigurationsImpl(this);
        this.networkInterfaceLoadBalancers = new NetworkInterfaceLoadBalancersImpl(this);
        this.networkInterfaceTapConfigurations = new NetworkInterfaceTapConfigurationsImpl(this);
        this.networkManagers = new NetworkManagersImpl(this);
        this.networkManagerCommits = new NetworkManagerCommitsImpl(this);
        this.networkManagerDeploymentStatusOperations = new NetworkManagerDeploymentStatusOperationsImpl(this);
        this.subscriptionNetworkManagerConnections = new SubscriptionNetworkManagerConnectionsImpl(this);
        this.managementGroupNetworkManagerConnections = new ManagementGroupNetworkManagerConnectionsImpl(this);
        this.connectivityConfigurations = new ConnectivityConfigurationsImpl(this);
        this.networkGroups = new NetworkGroupsImpl(this);
        this.staticMembers = new StaticMembersImpl(this);
        this.scopeConnections = new ScopeConnectionsImpl(this);
        this.securityAdminConfigurations = new SecurityAdminConfigurationsImpl(this);
        this.adminRuleCollections = new AdminRuleCollectionsImpl(this);
        this.adminRules = new AdminRulesImpl(this);
        this.networkProfiles = new NetworkProfilesImpl(this);
        this.networkSecurityGroups = new NetworkSecurityGroupsImpl(this);
        this.securityRules = new SecurityRulesImpl(this);
        this.defaultSecurityRules = new DefaultSecurityRulesImpl(this);
        this.networkVirtualAppliances = new NetworkVirtualAppliancesImpl(this);
        this.virtualApplianceSites = new VirtualApplianceSitesImpl(this);
        this.virtualApplianceSkus = new VirtualApplianceSkusImpl(this);
        this.inboundSecurityRuleOperations = new InboundSecurityRuleOperationsImpl(this);
        this.networkWatchers = new NetworkWatchersImpl(this);
        this.packetCaptures = new PacketCapturesImpl(this);
        this.connectionMonitors = new ConnectionMonitorsImpl(this);
        this.flowLogs = new FlowLogsImpl(this);
        this.operations = new OperationsImpl(this);
        this.privateEndpoints = new PrivateEndpointsImpl(this);
        this.availablePrivateEndpointTypes = new AvailablePrivateEndpointTypesImpl(this);
        this.privateDnsZoneGroups = new PrivateDnsZoneGroupsImpl(this);
        this.privateLinkServices = new PrivateLinkServicesImpl(this);
        this.publicIPPrefixes = new PublicIPPrefixesImpl(this);
        this.routeFilters = new RouteFiltersImpl(this);
        this.routeFilterRules = new RouteFilterRulesImpl(this);
        this.routeTables = new RouteTablesImpl(this);
        this.routes = new RoutesImpl(this);
        this.securityPartnerProviders = new SecurityPartnerProvidersImpl(this);
        this.bgpServiceCommunities = new BgpServiceCommunitiesImpl(this);
        this.serviceEndpointPolicies = new ServiceEndpointPoliciesImpl(this);
        this.serviceEndpointPolicyDefinitions = new ServiceEndpointPolicyDefinitionsImpl(this);
        this.serviceTags = new ServiceTagsImpl(this);
        this.serviceTagInformationOperations = new ServiceTagInformationOperationsImpl(this);
        this.usages = new UsagesImpl(this);
        this.virtualNetworks = new VirtualNetworksImpl(this);
        this.subnets = new SubnetsImpl(this);
        this.resourceNavigationLinks = new ResourceNavigationLinksImpl(this);
        this.serviceAssociationLinks = new ServiceAssociationLinksImpl(this);
        this.virtualNetworkPeerings = new VirtualNetworkPeeringsImpl(this);
        this.virtualNetworkGateways = new VirtualNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayConnections = new VirtualNetworkGatewayConnectionsImpl(this);
        this.localNetworkGateways = new LocalNetworkGatewaysImpl(this);
        this.virtualNetworkGatewayNatRules = new VirtualNetworkGatewayNatRulesImpl(this);
        this.virtualNetworkTaps = new VirtualNetworkTapsImpl(this);
        this.virtualRouters = new VirtualRoutersImpl(this);
        this.virtualRouterPeerings = new VirtualRouterPeeringsImpl(this);
        this.virtualWans = new VirtualWansImpl(this);
        this.vpnSites = new VpnSitesImpl(this);
        this.vpnSiteLinks = new VpnSiteLinksImpl(this);
        this.vpnSitesConfiguration = new VpnSitesConfigurationImpl(this);
        this.vpnServerConfigurations = new VpnServerConfigurationsImpl(this);
        this.configurationPolicyGroups = new ConfigurationPolicyGroupsImpl(this);
        this.virtualHubs = new VirtualHubsImpl(this);
        this.routeMaps = new RouteMapsImpl(this);
        this.hubVirtualNetworkConnections = new HubVirtualNetworkConnectionsImpl(this);
        this.vpnGateways = new VpnGatewaysImpl(this);
        this.vpnLinkConnections = new VpnLinkConnectionsImpl(this);
        this.vpnConnections = new VpnConnectionsImpl(this);
        this.vpnSiteLinkConnections = new VpnSiteLinkConnectionsImpl(this);
        this.natRules = new NatRulesImpl(this);
        this.p2SVpnGateways = new P2SVpnGatewaysImpl(this);
        this.vpnServerConfigurationsAssociatedWithVirtualWan = new VpnServerConfigurationsAssociatedWithVirtualWanImpl(this);
        this.virtualHubRouteTableV2S = new VirtualHubRouteTableV2SImpl(this);
        this.expressRouteGateways = new ExpressRouteGatewaysImpl(this);
        this.expressRouteConnections = new ExpressRouteConnectionsImpl(this);
        this.virtualHubBgpConnection = new VirtualHubBgpConnectionImpl(this);
        this.virtualHubBgpConnections = new VirtualHubBgpConnectionsImpl(this);
        this.virtualHubIpConfiguration = new VirtualHubIpConfigurationImpl(this);
        this.hubRouteTables = new HubRouteTablesImpl(this);
        this.routingIntentOperations = new RoutingIntentOperationsImpl(this);
        this.webApplicationFirewallPolicies = new WebApplicationFirewallPoliciesImpl(this);
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginListPutBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings);
            }
        };
    }
    putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* putBastionShareableLinkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield tslib.__await(this._putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
                result = yield tslib.__await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    putBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__asyncGenerator(this, arguments, function* putBastionShareableLinkPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.putBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    listBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        const iter = this.getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings);
            }
        };
    }
    getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getBastionShareableLinkPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getBastionShareableLinkPagingAll(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__asyncGenerator(this, arguments, function* getBastionShareableLinkPagingAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getBastionShareableLinkPagingPage(resourceGroupName, bastionHostName, bslRequest, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    beginListActiveSessionsAndWait(resourceGroupName, bastionHostName, options) {
        const iter = this.getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options, settings);
            }
        };
    }
    getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* getActiveSessionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                const poller = yield tslib.__await(this._getActiveSessions(resourceGroupName, bastionHostName, options));
                result = yield tslib.__await(poller.pollUntilDone());
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._getActiveSessionsNext(resourceGroupName, bastionHostName, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    getActiveSessionsPagingAll(resourceGroupName, bastionHostName, options) {
        return tslib.__asyncGenerator(this, arguments, function* getActiveSessionsPagingAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.getActiveSessionsPagingPage(resourceGroupName, bastionHostName, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    listDisconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        const iter = this.disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                if (settings === null || settings === void 0 ? void 0 : settings.maxPageSize) {
                    throw new Error("maxPageSize is not supported by this operation.");
                }
                return this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options, settings);
            }
        };
    }
    disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options, settings) {
        return tslib.__asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingPage_1() {
            let result;
            let continuationToken = settings === null || settings === void 0 ? void 0 : settings.continuationToken;
            if (!continuationToken) {
                result = yield tslib.__await(this._disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options));
                let page = result.value || [];
                continuationToken = result.nextLink;
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
            while (continuationToken) {
                result = yield tslib.__await(this._disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, continuationToken, options));
                continuationToken = result.nextLink;
                let page = result.value || [];
                setContinuationToken(page, continuationToken);
                yield yield tslib.__await(page);
            }
        });
    }
    disconnectActiveSessionsPagingAll(resourceGroupName, bastionHostName, sessionIds, options) {
        return tslib.__asyncGenerator(this, arguments, function* disconnectActiveSessionsPagingAll_1() {
            var e_4, _a;
            try {
                for (var _b = tslib.__asyncValues(this.disconnectActiveSessionsPagingPage(resourceGroupName, bastionHostName, sessionIds, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_4) throw e_4.error; }
            }
        });
    }
    /**
     * Creates a Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    _putBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, bastionHostName, bslRequest, options },
                spec: putBastionShareableLinkOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, bastionHostName, bslRequest, options },
                spec: deleteBastionShareableLinkOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Deletes the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    beginDeleteBastionShareableLinkAndWait(resourceGroupName, bastionHostName, bslRequest, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginDeleteBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * Return the Bastion Shareable Links for all the VMs specified in the request.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param options The options parameters.
     */
    _getBastionShareableLink(resourceGroupName, bastionHostName, bslRequest, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, options }, getBastionShareableLinkOperationSpec);
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param options The options parameters.
     */
    _getActiveSessions(resourceGroupName, bastionHostName, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, bastionHostName, options },
                spec: getActiveSessionsOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Returns the list of currently active sessions on the Bastion.
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param options The options parameters.
     */
    _disconnectActiveSessions(resourceGroupName, bastionHostName, sessionIds, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, options }, disconnectActiveSessionsOperationSpec);
    }
    /**
     * Checks whether a domain name in the cloudapp.azure.com zone is available for use.
     * @param location The location of the domain name.
     * @param domainNameLabel The domain name to be verified. It must conform to the following regular
     *                        expression: ^[a-z][a-z0-9-]{1,61}[a-z0-9]$.
     * @param options The options parameters.
     */
    checkDnsNameAvailability(location, domainNameLabel, options) {
        return this.sendOperationRequest({ location, domainNameLabel, options }, checkDnsNameAvailabilityOperationSpec);
    }
    /**
     * Retrieves detail of a provider port.
     * @param providerport The name of the provider port.
     * @param options The options parameters.
     */
    expressRouteProviderPort(providerport, options) {
        return this.sendOperationRequest({ providerport, options }, expressRouteProviderPortOperationSpec);
    }
    /**
     * Lists active connectivity configurations in a network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Active Configuration Parameter.
     * @param options The options parameters.
     */
    listActiveConnectivityConfigurations(resourceGroupName, networkManagerName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, networkManagerName, parameters, options }, listActiveConnectivityConfigurationsOperationSpec);
    }
    /**
     * Lists active security admin rules in a network manager.
     * @param resourceGroupName The name of the resource group.
     * @param networkManagerName The name of the network manager.
     * @param parameters Active Configuration Parameter.
     * @param options The options parameters.
     */
    listActiveSecurityAdminRules(resourceGroupName, networkManagerName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, networkManagerName, parameters, options }, listActiveSecurityAdminRulesOperationSpec);
    }
    /**
     * List all effective connectivity configurations applied on a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to list correct page.
     * @param options The options parameters.
     */
    listNetworkManagerEffectiveConnectivityConfigurations(resourceGroupName, virtualNetworkName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualNetworkName, parameters, options }, listNetworkManagerEffectiveConnectivityConfigurationsOperationSpec);
    }
    /**
     * List all effective security admin rules applied on a virtual network.
     * @param resourceGroupName The name of the resource group.
     * @param virtualNetworkName The name of the virtual network.
     * @param parameters Parameters supplied to list correct page.
     * @param options The options parameters.
     */
    listNetworkManagerEffectiveSecurityAdminRules(resourceGroupName, virtualNetworkName, parameters, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualNetworkName, parameters, options }, listNetworkManagerEffectiveSecurityAdminRulesOperationSpec);
    }
    /**
     * Gives the supported security providers for the virtual wan.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN for which supported security providers are needed.
     * @param options The options parameters.
     */
    supportedSecurityProviders(resourceGroupName, virtualWANName, options) {
        return this.sendOperationRequest({ resourceGroupName, virtualWANName, options }, supportedSecurityProvidersOperationSpec);
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const directSendOperation = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                return this.sendOperationRequest(args, spec);
            });
            const sendOperationFn = (args, spec) => tslib.__awaiter(this, void 0, void 0, function* () {
                var _a;
                let currentRawResponse = undefined;
                const providedCallback = (_a = args.options) === null || _a === void 0 ? void 0 : _a.onResponse;
                const callback = (rawResponse, flatResponse) => {
                    currentRawResponse = rawResponse;
                    providedCallback === null || providedCallback === void 0 ? void 0 : providedCallback(rawResponse, flatResponse);
                };
                const updatedArgs = Object.assign(Object.assign({}, args), { options: Object.assign(Object.assign({}, args.options), { onResponse: callback }) });
                const flatResponse = yield directSendOperation(updatedArgs, spec);
                return {
                    flatResponse,
                    rawResponse: {
                        statusCode: currentRawResponse.status,
                        body: currentRawResponse.parsedBody,
                        headers: currentRawResponse.headers.toJSON()
                    }
                };
            });
            const lro = createLroSpec({
                sendOperationFn,
                args: { resourceGroupName, virtualWANName, vpnClientParams, options },
                spec: generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec
            });
            const poller = yield coreLro.createHttpPoller(lro, {
                restoreFrom: options === null || options === void 0 ? void 0 : options.resumeFrom,
                intervalInMs: options === null || options === void 0 ? void 0 : options.updateIntervalInMs,
                resourceLocationConfig: "location"
            });
            yield poller.poll();
            return poller;
        });
    }
    /**
     * Generates a unique VPN profile for P2S clients for VirtualWan and associated VpnServerConfiguration
     * combination in the specified resource group.
     * @param resourceGroupName The resource group name.
     * @param virtualWANName The name of the VirtualWAN whose associated VpnServerConfigurations is needed.
     * @param vpnClientParams Parameters supplied to the generate VirtualWan VPN profile generation
     *                        operation.
     * @param options The options parameters.
     */
    beginGeneratevirtualwanvpnserverconfigurationvpnprofileAndWait(resourceGroupName, virtualWANName, vpnClientParams, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const poller = yield this.beginGeneratevirtualwanvpnserverconfigurationvpnprofile(resourceGroupName, virtualWANName, vpnClientParams, options);
            return poller.pollUntilDone();
        });
    }
    /**
     * PutBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the PutBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _putBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, putBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetBastionShareableLinkNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param bslRequest Post request for all the Bastion Shareable Link endpoints.
     * @param nextLink The nextLink from the previous successful call to the GetBastionShareableLink
     *                 method.
     * @param options The options parameters.
     */
    _getBastionShareableLinkNext(resourceGroupName, bastionHostName, bslRequest, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, bslRequest, nextLink, options }, getBastionShareableLinkNextOperationSpec);
    }
    /**
     * GetActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param nextLink The nextLink from the previous successful call to the GetActiveSessions method.
     * @param options The options parameters.
     */
    _getActiveSessionsNext(resourceGroupName, bastionHostName, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, nextLink, options }, getActiveSessionsNextOperationSpec);
    }
    /**
     * DisconnectActiveSessionsNext
     * @param resourceGroupName The name of the resource group.
     * @param bastionHostName The name of the Bastion Host.
     * @param sessionIds The list of sessionids to disconnect.
     * @param nextLink The nextLink from the previous successful call to the DisconnectActiveSessions
     *                 method.
     * @param options The options parameters.
     */
    _disconnectActiveSessionsNext(resourceGroupName, bastionHostName, sessionIds, nextLink, options) {
        return this.sendOperationRequest({ resourceGroupName, bastionHostName, sessionIds, nextLink, options }, disconnectActiveSessionsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const putBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/createShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BastionShareableLinkListResult
        },
        201: {
            bodyMapper: BastionShareableLinkListResult
        },
        202: {
            bodyMapper: BastionShareableLinkListResult
        },
        204: {
            bodyMapper: BastionShareableLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: bslRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const deleteBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/deleteShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {},
        201: {},
        202: {},
        204: {},
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: bslRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getBastionShareableLinkOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getShareableLinks",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BastionShareableLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: bslRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/getActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BastionActiveSessionListResult
        },
        201: {
            bodyMapper: BastionActiveSessionListResult
        },
        202: {
            bodyMapper: BastionActiveSessionListResult
        },
        204: {
            bodyMapper: BastionActiveSessionListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept],
    serializer
};
const disconnectActiveSessionsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/bastionHosts/{bastionHostName}/disconnectActiveSessions",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: BastionSessionDeleteResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: sessionIds,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const checkDnsNameAvailabilityOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/locations/{location}/CheckDnsNameAvailability",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DnsNameAvailabilityResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion, domainNameLabel],
    urlParameters: [
        $host,
        subscriptionId,
        location
    ],
    headerParameters: [accept],
    serializer
};
const expressRouteProviderPortOperationSpec = {
    path: "/subscriptions/{subscriptionId}/providers/Microsoft.Network/expressRouteProviderPorts/{providerport}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ExpressRouteProviderPort
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        subscriptionId,
        providerport
    ],
    headerParameters: [accept],
    serializer
};
const listActiveConnectivityConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/listActiveConnectivityConfigurations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ActiveConnectivityConfigurationsListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listActiveSecurityAdminRulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/networkManagers/{networkManagerName}/listActiveSecurityAdminRules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: ActiveSecurityAdminRulesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters6,
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        networkManagerName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listNetworkManagerEffectiveConnectivityConfigurationsOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/listNetworkManagerEffectiveConnectivityConfigurations",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NetworkManagerEffectiveConnectivityConfigurationListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listNetworkManagerEffectiveSecurityAdminRulesOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/listNetworkManagerEffectiveSecurityAdminRules",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: NetworkManagerEffectiveSecurityAdminRulesListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: parameters7,
    queryParameters: [apiVersion, top],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualNetworkName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const supportedSecurityProvidersOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/supportedSecurityProviders",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: VirtualWanSecurityProviders
        },
        default: {
            bodyMapper: CloudError
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName
    ],
    headerParameters: [accept],
    serializer
};
const generatevirtualwanvpnserverconfigurationvpnprofileOperationSpec = {
    path: "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/virtualWans/{virtualWANName}/GenerateVpnProfile",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: VpnProfileResponse
        },
        201: {
            bodyMapper: VpnProfileResponse
        },
        202: {
            bodyMapper: VpnProfileResponse
        },
        204: {
            bodyMapper: VpnProfileResponse
        },
        default: {
            bodyMapper: CloudError
        }
    },
    requestBody: vpnClientParams,
    queryParameters: [apiVersion],
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        virtualWANName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const putBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionShareableLinkListResult
        },
        202: {},
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getBastionShareableLinkNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionShareableLinkListResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const getActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionActiveSessionListResult
        },
        202: {},
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        bastionHostName
    ],
    headerParameters: [accept],
    serializer
};
const disconnectActiveSessionsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: BastionSessionDeleteResult
        },
        default: {
            bodyMapper: CloudError
        }
    },
    urlParameters: [
        $host,
        resourceGroupName,
        subscriptionId,
        nextLink,
        bastionHostName
    ],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};

exports.NetworkManagementClient = NetworkManagementClient;
exports.getContinuationToken = getContinuationToken;
//# sourceMappingURL=index.js.map
